#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass memoir
\begin_preamble
%used by the cover
\usepackage{graphicx}

%used to insert tab stops in itemize or enumerate
\usepackage{tabto}

\usepackage[utf8]{inputenc}
\DeclareUnicodeCharacter{2190}{\ifmmode \leftarrow \else \textleftarrow \fi} % override

% T1 Helvetica scaled
\usepackage[T1]{fontenc}
\usepackage[scaled]{helvet}
\renewcommand*{\familydefault}{\sfdefault}

% Chapter style
\usepackage{xcolor,calc}

\makechapterstyle{combined}{
  \setlength{\beforechapskip}{30pt}
  \setlength{\midchapskip}{-60pt}
  \setlength{\afterchapskip}{60pt}
  \renewcommand*{\printchaptername}{}
  \renewcommand*{\chapnumfont}{\normalfont\sffamily\bfseries\fontsize{80}{0}\selectfont}
  \renewcommand*{\printchapternum}{\flushright\chapnumfont\textcolor[rgb]{.64,.79,.87}{\thechapter}}
  \renewcommand*{\chaptitlefont}{\normalfont\sffamily\Huge\bfseries}
  \renewcommand*{\printchaptertitle}[1]{%
    \raggedright\chaptitlefont\parbox[t]{\textwidth-3cm}{\raggedright##1}}
}

\chapterstyle{combined}

% Code listing
\usepackage{listings,color}

\definecolor{dkgreen}{RGB}{63,127,95}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{light-gray}{rgb}{0.925,0.925,0.925}
\definecolor{mauve}{RGB}{127,0,85}

 \lstset{
        language=Java,
        backgroundcolor=\color{light-gray},
         basicstyle=\footnotesize\ttfamily, % Standardschrift
         numbers=left,               % Ort der Zeilennummern
         numberstyle=\tiny,          % Stil der Zeilennummern
         %stepnumber=2,               % Abstand zwischen den Zeilennummern
         numbersep=5pt,              % Abstand der Nummern zum Text
         tabsize=2,                  % Groesse von Tabs
         extendedchars=true,         %
         breaklines=true,            % Zeilen werden Umgebrochen
        emph={LEFT,RIGHT,CENTER,TOP,BOTTOM,FILL,FIT,CENTER_OF,BOTTOM_OF,AFTER,BEFORE},
        emphstyle=\color{blue}\textit,
         keywordstyle=\color{mauve}\textbf,
         frame=b,
 %        keywordstyle=[2]\textbf,    % Stil der Keywords
 %        keywordstyle=[2]\textbf,    %
 %        keywordstyle=[3]\textbf,    %
 %        keywordstyle=[4]\textbf,   \sqrt{\sqrt{}} %
         commentstyle=\color{dkgreen},       % comment style
         stringstyle=\color{blue},         % string literal style
  %       stringstyle=\color{white}\ttfamily, % Farbe der String
         showspaces=false,           % Leerzeichen anzeigen ?
         showtabs=false,             % Tabs anzeigen ?
         xleftmargin=17pt,
         framexleftmargin=17pt,
         framexrightmargin=5pt,
         framexbottommargin=4pt,
         %backgroundcolor=\color{lightgray},
         showstringspaces=false      % Leerzeichen in Strings anzeigen ?        
 }
 \lstloadlanguages{% Check Dokumentation for further languages ...
         %[Visual]Basic
         %Pascal
         %C
         %C++
         %XML
         %HTML
         Java
 }
    %\DeclareCaptionFont{blue}{\color{blue}} 

  %\captionsetup[lstlisting]{singlelinecheck=false, labelfont={blue}, textfont={blue}}
  \usepackage{caption}
\DeclareCaptionFont{white}{\color{white}}
\DeclareCaptionFormat{listing}{\colorbox[cmyk]{0.43, 0.35, 0.35,0.01}{\parbox{\textwidth}{\hspace{15pt}#1#2#3}}}
\captionsetup[lstlisting]{format=listing,labelfont=white,textfont=white, singlelinecheck=false, margin=0pt, font={bf,footnotesize}}

% New style chapter star, so we can have unumbered chapters to show in ToC
\newcommand{\tocchap}[1]{\addcontentsline{toc}{chapter}{\protect\numberline
{}#1}\markboth{\textsc{#1}}{\textsc{#1}}\thispagestyle{plain}}
\newcommand{\chapterstar}[1]{\chapter*{#1}\tocchap{#1}}

% Sections are not numbered
\setcounter{secnumdepth}{0}

% Vertical gap between paragraphs
\setlength{\parskip}{\medskipamount}
\end_preamble
\use_default_options true
\begin_modules
enumitem
\end_modules
\maintain_unincluded_children false
\begin_local_layout
Input fieldlist.inc

Style Chapterstar
Copystyle Chapter
LatexName chapterstar
LabelType Top_Environment
LabelString "Unnumbered chapter"
LabelFont
Series Bold
Size LARGE
EndFont
End
\end_local_layout
\language english
\language_package default
\inputencoding default
\fontencoding global
\font_roman lmodern
\font_sans default
\font_typewriter courier
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize 11
\spacing single
\use_hyperref true
\pdf_title "TotalCross Companion"
\pdf_author "SuperWaba"
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder true
\pdf_colorlinks true
\pdf_backref section
\pdf_pdfusetitle true
\pdf_quoted_options "linkcolor=black"
\papersize a4paper
\use_geometry true
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 2.5cm
\topmargin 2.5cm
\rightmargin 2.5cm
\bottommargin 4cm
\footskip 1cm
\secnumdepth 0
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 2
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
clearpage
\end_layout

\begin_layout Plain Layout

%% temporary titles 
\end_layout

\begin_layout Plain Layout

% command to provide stretchy vertical space in proportion
\end_layout

\begin_layout Plain Layout


\backslash
newcommand
\backslash
nbvspace[1][3]{
\backslash
vspace*{
\backslash
stretch{#1}}}
\end_layout

\begin_layout Plain Layout

% allow some slack to avoid under/overfull boxes
\end_layout

\begin_layout Plain Layout


\backslash
newcommand
\backslash
nbstretchyspace{
\backslash
spaceskip0.5em plus 0.25em minus 0.25em}
\end_layout

\begin_layout Plain Layout

% To improve spacing on titlepages
\end_layout

\begin_layout Plain Layout


\backslash
newcommand{
\backslash
nbtitlestretch}{
\backslash
spaceskip0.6em}
\end_layout

\begin_layout Plain Layout


\backslash
pagestyle{empty}
\end_layout

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
bfseries
\end_layout

\begin_layout Plain Layout


\backslash
nbvspace[1]
\end_layout

\begin_layout Plain Layout


\backslash
Huge
\end_layout

\begin_layout Plain Layout

{
\backslash
nbtitlestretch
\backslash
huge
\backslash
textcolor[RGB]{25,60,240} 
\end_layout

\begin_layout Plain Layout

{The TotalCross Companion}}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
nbvspace[2]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
includegraphics[scale=1]{companion_resources/images/TotalCross_cor_vertical}
 
\end_layout

\begin_layout Plain Layout


\backslash
nbvspace[5] 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
large 
\end_layout

\begin_layout Plain Layout

Version 1.50
\end_layout

\begin_layout Plain Layout


\backslash
nbvspace[1] 
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\begin_inset Newpage newpage
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
pagestyle{companion}
\end_layout

\end_inset


\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\begin_inset Newpage cleardoublepage
\end_inset


\end_layout

\begin_layout Part
THE PLATFORM
\end_layout

\begin_layout Chapterstar
Welcome
\end_layout

\begin_layout Standard
Welcome to TotalCross.
 This tutorial assumes that you know how to write Java programs.
 If not, I suggest that you take a basic course in Java at 
\begin_inset CommandInset href
LatexCommand href
target "http://java.sun.com/docs/books/tutorial/java/index.html"

\end_inset


\end_layout

\begin_layout Standard
However, you'll have to forget the JDK API and use the TotalCross API.
 Make a good read of the API javadocs: they will show you the differences
 between the JDK and the TotalCross API.
\end_layout

\begin_layout Standard
Some conventions used in this tutorial:
\end_layout

\begin_layout Itemize
When a code sample has ...
 (ellipses) between two parts, it means that some part of that code has
 been omitted.
\end_layout

\begin_layout Itemize
Measurements are always in 
\emph on
pixels
\emph default
, unless otherwise specified.
\end_layout

\begin_layout Itemize
The  symbol means 
\emph on
attention
\emph default
.
\end_layout

\begin_layout Standard
This tutorial follows the Object Oriented naming convention: a class containing
 methods (~functions) and properties or fields (~variables).
\end_layout

\begin_layout Standard

\series bold
WINDOWS CE
\series default
 refers to all the possible names deriving from that platform: Windows CE
 (up to 2.x), Pocket PC (Windows CE 3.x), .NET (Windows CE 4.x), Windows Mobile
 (5.x and 6.x).
 
\end_layout

\begin_layout Standard

\series bold
TC
\series default
 refers to TotalCross.
 
\end_layout

\begin_layout Standard

\series bold
TCVM
\series default
 refers to the TotalCross virtual machine.
\end_layout

\begin_layout Standard
The term “
\series bold
main class
\series default
” always refers to the class that extends totalcross.ui.MainWindow.
\end_layout

\begin_layout Standard
The term “
\series bold
<TOTALCROSS_HOME>
\series default
” refers to the directory where the TotalCrossSDK is located.
 The default location is “C:
\backslash
TotalCrossSDK”.
\end_layout

\begin_layout Standard
Please read the Copyright terms in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Copyright"

\end_inset

.
 By reading this book, you're agreeing with them.
\end_layout

\begin_layout Chapter
TotalCross Overview
\end_layout

\begin_layout Standard
Thank you for your interest in TotalCross.
 If you don't know where to start, here's a quick overview of the platform:
\end_layout

\begin_layout Section
Supported Platforms
\end_layout

\begin_layout Itemize
Android 1.6 and above.
\end_layout

\begin_layout Itemize
iOS 3.2 and above (using jailbreak and cydia).
 
\end_layout

\begin_layout Itemize
BlackBerry 4.3.0 and above.
 
\end_layout

\begin_layout Itemize
Palm OS 5 with NVFS.
 
\end_layout

\begin_layout Itemize
Windows CE: Pocket PC ARM/SH3/MIPS (3.0, .NET, Windows Mobile 5 and 6), PPC
 2.11 ARM, HPC2000 ARM.
 
\end_layout

\begin_layout Itemize
Windows 2000 and above
\end_layout

\begin_layout Itemize
Linux.
 
\end_layout

\begin_layout Itemize
Browser as Java applet (JDK 1.1 and above).
 
\end_layout

\begin_layout Section
Virtual Machine Features
\end_layout

\begin_layout Standard
The TotalCross Virtual Machine (TCVM) is a shared library written from scratch,
 and has the following features: 
\end_layout

\begin_layout Itemize
It interprets a proprietary set of opcodes instead of Java Bytecodes.
\end_layout

\begin_layout Itemize
It is a register-based VM, not stack-based as Java, which results in better
 performance.
\end_layout

\begin_layout Itemize
It has support for real multi-threading.
 Note that the TotalCross API does not supports concurrency, which must
 be implemented by your own.
\end_layout

\begin_layout Itemize
The tclass files stores internal information in little endian, since its
 the most widely used format of actual microprocessors.
\end_layout

\begin_layout Itemize
The tclass files are highly optimized to save space.
 For instance, the constant pool (where Strings, constants and identifiers
 are stored) is shared among all deployed classes, and each class entry
 is compressed using zlib.
\end_layout

\begin_layout Itemize
Supports headless applications (like daemon applications, without user interface
): just implement the interface totalcross.MainClass and this class will
 be loaded by the TCVM.
 The appStarting and appEnding methods are called and the application exits.
\end_layout

\begin_layout Itemize
Supports the method “finalize”, ran every time the garbage collector (gc)
 finishes its job.
 There's a limitation: no objects can be created inside a finally method,
 otherwise the method will silently abort itself.
 Optionally, to improve GC's performance, you can define in your class a
 public non-static field named “dontFinalize” that, if present and set to
 “true”, will skip the finalize call.
 In most cases, the finalize is used to ensure that a class that holds system
 resources (like File or Socket) and should be closed to release these resources
 is always closed, either because the programmer forgot to do it himself
 or because the program was halted by an exception.
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
Note that you must define the field “dontFinalize” and set it to true when
 the close method is run for the first time.
 Otherwise the gc will try to finalize an object that was already closed
 by the programmer, which may cause trouble.
 Doing so also speeds up the gc.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The TotalCross vm also has a drawback:
\end_layout

\begin_layout Itemize
It does not support the float type, only double.
 This option was adopted because all actual PDA processors have a math co-proces
sor, and also because the vast majority of mobile applications are not scientifi
c programs.
 During our research, we found that float types are two times faster than
 double, but this small performance difference does not make up for the
 overhead needed to add float type support to the virtual machine.
 The change from float to double will be done by the translator to let legacy
 applications work, however, you should change your application to use double,
 since there's no benefit by using float.
\end_layout

\begin_layout Section
Thread support
\end_layout

\begin_layout Standard
TotalCross supports preemptive threads using the native thread mechanism
 of each supported platform.
 On Android, iPhone and Linux, it uses pthread; on Palm OS, it uses the
 undocumented (and quite limited) thread api; on Windows, it uses the quite
 well documented thread api, in Blackberry, it uses the Java's thread scheduler.
\end_layout

\begin_layout Standard
The API does not support concurrency.
 If your program needs to access the same object from many threads, you
 must use the 
\family typewriter
synchronized
\family default
 keyword.
 The support for synchronized is limited: it does not support synchronized
 methods, neither classes, neither standard objects.
 You must use the 
\family typewriter
synchronized(object)
\family default
, and the only object type that can be used as parameter is the totalcross.util.co
ncurrent.Lock.
 If you use 
\family typewriter
synchronized(this)
\family default
, the tc.Deploy will abort during deploy; if you use synchronized with an
 object from any other class besides the Lock class, a 
\family typewriter
RuntimeException
\family default
 will be thrown when your program runs in the TotalCross virtual machine.
 Note that these problems will not occur when running under Java desktop,
 only when running at the TCVM.
 Here's a sample that shows how to use it:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinputlisting[label=samplecode,caption=A sample]{companion_resources/listings/
TestConcurrent.java}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In the sample above, commenting out the line marked with *****, the log
 ListBox will be filled randomly by the threads.
 With the lock, it will be filled in sequence, because each thread will
 gain the lock once, and the other threads will have to wait the main loop
 of the lock owner finish before starting their loops.
 There's no limit in the number of locks used.
\end_layout

\begin_layout Standard
Generally speaking, you can create a thread to listen to a socket or a file
 or even a Litebase table in background, but be aware that if you try to
 access the same resource by different threads your application might just
 blow up.
 We also don't recommend running the user interface in a background thread,
 due to system event concurrency.
 Threads should be used for I/O and other tasks, but not for showing user
 interface screens that could receive events.
\end_layout

\begin_layout Section
Graphics, Palette and Color
\end_layout

\begin_layout Standard
TotalCross has a Graphics engine written from scratch, and some important
 performance-tailored decisions were taken.
\end_layout

\begin_layout Standard
Regardless of the device's color depth, the screen and images are stored
 in a 24 bpp RGB array.
 All drawings are made into a single off screen, which is then converted
 on the fly to the device's screen color depth when the 
\family typewriter
updateScreen
\family default
 method is called.
\end_layout

\begin_layout Standard
If the screen is 8 bpp, a variant of the 685 palette (6 bits for red, 8
 for green and 5 for blue, plus 16 shades of gray) is used.
 (see Appendix C – 685 palette).
 Note: since 2011, no devices with 8 bpp are released to the market; all
 of them use 16 bpp (65536 colors).
\end_layout

\begin_layout Standard
The Graphics class supports real clipping, which allowed us to support container
s that automatically show scrollbars if components are placed beyond its
 limits.
\end_layout

\begin_layout Standard
TotalCross also supports screen rotation and collapsible input area.
 If the user interface is implemented using only relative coordinates, it
 will automatically reposition itself whenever the screen resolution is
 changed.
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
Note that 
\family typewriter
aControl.setRect(getClientRect())
\family default
 should never be used, otherwise the automatic repositioning will not work.
 Instead, 
\family typewriter
aControl.setRect(LEFT, TOP, FILL, FILL)
\family default
 should be used to produce the same result without affecting the repositioning.
 If you really have to use 
\family typewriter
getClientRect
\family default
, you must also override the 
\family typewriter
reposition
\family default
 method to support screen rotation.
 (see the WorldWatch sample)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Colors are represented by int values in the 0xRRGGBB format.
 A null color is represented by the value -1.
\end_layout

\begin_layout Section
Images
\end_layout

\begin_layout Standard
Images in TotalCross supports transparency (also known as alpha-channel).
 The best way to show images is to generate a PNG image from a vectorized
 image through Photoshop or any other good editor.
 Prefer creating a big image (for example, 96x96), then decrease its size
 at runtime using 
\family typewriter
Image.getSmoothScaledInstance
\family default
.
\end_layout

\begin_layout Section
Inheritance and Delegation event models
\end_layout

\begin_layout Standard
TotalCross supports both Inheritance (Java 1.0) and Delegation (Java 1.1)
 event models.
 However, the usage of the later one is not recommended.
 The Inheritance model will make your code smaller and faster, but there
 are some situations that require the usage of the Delegation model.
\end_layout

\begin_layout Section
Security
\end_layout

\begin_layout Standard
TotalCross applications are currently impossible to be decompiled, because,
 as mentioned before, TotalCross uses a proprietary set of opcodes instead
 of Java Bytecodes.
 The translation between Java Bytecodes to TotalCross opcodes is done automatica
lly when the application is deployed.
\end_layout

\begin_layout Standard
However, this also means that you cannot retrieve the your application's
 source files from the deployed application, so don't forget to backup your
 source files!
\end_layout

\begin_layout Section
Getting Started
\end_layout

\begin_layout Standard
Be sure to read the API javadocs at 
\series bold
TotalCrossSDK/docs/html/index.html
\series default
.
 
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
The javadocs and this book are complementary, and the javadocs are updated
 more often than this book.
 So make sure to read them for more information.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
There are some examples in the 
\series bold
TotalCrossSDK/src/java/tc/samples
\series default
 directories.
 These samples covers the usage of a great portion of TotalCross' class
 library, so it's a good source of information from where you can start
 your applications.
\end_layout

\begin_layout Standard
Our official forum (
\begin_inset CommandInset href
LatexCommand href
target "http://forum.totalcross.net"

\end_inset

) is a good place to seek for help from fellow TotalCross users and share
 your knowledge.
\end_layout

\begin_layout Section
Bug Reporting
\end_layout

\begin_layout Standard
If you'd like to report a bug or problem within the TotalCrossSDK – including,
 but not limited to:
\end_layout

\begin_layout Itemize
Documentation problems, grammar errors or typos.
\end_layout

\begin_layout Itemize
TotalCross platform bug.
\end_layout

\begin_layout Itemize
Sample bug.
\end_layout

\begin_layout Standard
You should first take a look at the 
\begin_inset CommandInset href
LatexCommand href
name "TotalCross changelog"
target "http://www.superwaba.com.br/en/changelogs.asp"

\end_inset

 and check if your bug was already fixed on a later version of the TotalCrossSDK.
\end_layout

\begin_layout Standard
You may then use the forum to report the bug, however, its not guaranteed
 that we will fix the bug.
 If you want the bug fixed in a few days and receive a fixed virtual machine,
 you must purchase a 
\begin_inset CommandInset href
LatexCommand href
name "support plan"
target "http://www.superwaba.com.br/en/suporte.asp"

\end_inset

 at the site.
\end_layout

\begin_layout Standard
Here's a rough template of a bug report for TotalCross:
\end_layout

\begin_layout Itemize
TotalCross version, e.g.
 1.0 beta 4.
\end_layout

\begin_layout Itemize
Platform used and OS version, e.g.
 JDK 1.5, Windows XP, Windows Mobile 5
\end_layout

\begin_layout Itemize
Devices used, e.g.
 Android, iPhone, Java Standard Edition (desktop).
\end_layout

\begin_layout Itemize
Bug description.
\end_layout

\begin_layout Itemize
How to reproduce the bug?
\end_layout

\begin_layout Standard
For documentation problems and such, just pointing the resource and the
 problem is enough.
\end_layout

\begin_layout Chapter
The TotalCross SDK
\end_layout

\begin_layout Standard
The TotalCross SDK Java files are covered by the LGPL version 3.
 By installing the SDK you are agreeing with this.
 The TotalCross virtual machine follows another license.
\end_layout

\begin_layout Standard
The VM provided in the SDK is a demo version.
 It will work for 80 non-contiguous hours, regardless of the platform.
 The remaining time is updated every 5 seconds.
\end_layout

\begin_layout Standard
On devices, performing a hard-reset allows you to reinstall the VM and have
 more 80 hours to test.
 This is NOT considered a license violation.
\end_layout

\begin_layout Standard
On Win32, this can only be done by reformatting your hard drive and reinstalling
 Windows.
\end_layout

\begin_layout Standard
In order to deploy applications, the JDK 1.6 or higher is required.
\end_layout

\begin_layout Standard
In most situations, you will install several programs that will share the
 same TCVM.
 For instance, you can install 10 or more samples and a single virtual machine.
 However, if you're deploying an application to your costumer, you can package
 the vm with your application, using the tc.Deploy's /p option.
 In this case, a single package is needed.
\end_layout

\begin_layout Section
Directory structure
\end_layout

\begin_layout Standard
The SDK has the following structure: 
\end_layout

\begin_layout Description

\family typewriter
TotalCrossSDK
\end_layout

\begin_deeper
\begin_layout Description

\family typewriter
- dist
\end_layout

\begin_layout Description

\family typewriter
+ samples
\end_layout

\begin_deeper
\begin_layout Description

\family typewriter
+ vm
\end_layout

\begin_layout Description

\family typewriter
+ docs
\end_layout

\begin_layout Description

\family typewriter
+ etc
\end_layout

\begin_layout Description

\family typewriter
+ src
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
Inside dist, we have:
\end_layout

\begin_layout Itemize
TotalCrossSDK/dist/tc.jar : This file contains all totalcross.* base classes
 and deploy tools, and it should be added to the classpath of your chosen
 IDE.
\end_layout

\begin_layout Itemize
TotalCrossSDK/dist/tcweb.jar : This file contains all totalcross.* base classes
 and fonts, to be used if you want to run the application in a browser.
\end_layout

\begin_layout Itemize
TotalCrossSDK
\backslash
dist
\backslash
samples : Installation files for all samples.
 Lets take the UIGadgets sample, located at TotalCrossSDK
\backslash
dist
\backslash
samples
\backslash
UIGadgets.
 Inside there's an install folder, and below the following folders:
\end_layout

\begin_deeper
\begin_layout Itemize
applet: contains some html files (representing most used devices) and the
 application's jar.
 Using a multi-tabbed browser, you should close it every time you open one
 of the samples html, otherwise errors may occur.
\end_layout

\begin_layout Itemize
bb: blackberry installation files.
 The alx, cod and jad files are used to deploy the file to the device, and
 the csl and cso to sign the file.
 (more information on the BlackBerry installation section)
\end_layout

\begin_layout Itemize
iphone2+: for newer versions of the iPhone OS, contains a .deb file.
 
\end_layout

\begin_layout Itemize
palm: contains the pdb and prc files to be installed on the device.
 Optionally, you may use the install.exe file, which installs the same files,
 but provides a simple installation interface.
\end_layout

\begin_layout Itemize
win32: there are two files, an exe and a tcz, which must be copied to the
 same folder where the TotalCross VM for Win32 is located, or to a sub folder.
 The executable will search for the VM on these locations.
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
If your desktop has the SDK installed, you may run the application from
 any place, as long as the environment variables set during the installation
 are not changed and the SDK installation folder is not moved
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
wince: there are 6 cab files.
 Just run the bat file inside that folder and the correct cab file for the
 currently connected Windows CE device will be chosen.
 If it doesn't work, you may copy the cab file to your device and open it
 using the device's file explorer.
\end_layout

\begin_layout Itemize
linux:a tcz file and a binary file.
 They must be copied to where the vm is, or a folder below.
\end_layout

\begin_layout Itemize
Android: an apk file that contains the binary and the tcz files.
\end_layout

\end_deeper
\begin_layout Itemize
TotalCrossSDK
\backslash
dist
\backslash
vm : virtual machine files that which will interpret your TotalCross code
 at the device.
 Below are instructions of how install them in each platform:
\end_layout

\begin_deeper
\begin_layout Itemize
bb: open the TotalCross.alx file in your blackberry desktop software.
\end_layout

\begin_layout Itemize
iphone2+: copy the .deb file into the device and execute a “dpkg -i <deb
 file>”
\end_layout

\begin_layout Itemize
palm: install TCBase.pdb, TCFont.pdb and TCVM.prc.
 Optionally, you may simply execute the Install.exe file which installs the
 same files.
\end_layout

\begin_layout Itemize
win32: have the files TCSync.dll, TCSyncLib.tcz and TCVM.dll, TCBase.tcz and
 TCFont.tcz on the same folder of the application.
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
If your desktop has the SDK installed, this is not required, as long as
 the environment variables set during the installation are not changed and
 the SDK installation folder is not moved
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
wince: just run the _CEInstall-RunMe.bat file and the correct cab file will
 be installed in the device (if the installation fails, there's also a bat
 file that can be used in Windows Mobile).
 Optionally, you can grab the TCVM.dll file inside the target plaform's folder
 and copy it to the device (preferrably, to 
\backslash
TotalCross).
 In this case, you must also copy the files TCBase.tcz and TCFont.tcz to the
 same folder.
\end_layout

\end_deeper
\begin_layout Standard
Inside docs, we have:
\end_layout

\begin_layout Itemize
TotalCross Companion.pdf.
\end_layout

\begin_layout Itemize
The folder “html”, which contains the generated javadocs.
 Open the file index.html to see the javadocs start page.
\end_layout

\begin_layout Standard
Inside etc, we have the following folders:
\end_layout

\begin_layout Itemize
images: contains images used by the SDK.
\end_layout

\begin_layout Itemize
launchers: contains files used by the tc.Deploy.
\end_layout

\begin_layout Itemize
security: contains signature files.
\end_layout

\begin_layout Itemize
tools: contains tools used by the tc.Deploy.
 Inside this folder, you may have to use the apache folder, which contains
 a xml-rpc server, and the commapi, which contains files that must be added
 to the classpath to use the PortConnector class at desktop.
 There's also a high resolution fix for TreoPro devices, and a folder with
 some Android tools used to install the application at the device.
\end_layout

\begin_layout Standard
Inside src:
\end_layout

\begin_layout Itemize
tc/samples: the sources files of all samples.
\end_layout

\begin_layout Itemize
totalcross: the sources files of the TotalCross API used at desktop.
\end_layout

\begin_layout Section
Running the Samples
\end_layout

\begin_layout Standard
The TotalCrossSDK comes with various sample applications along with their
 source code.
 The samples are simple and most of them address a specific feature.
 They were designed to show you the TotalCross main features and to provide
 a starting point for your own applications.
\end_layout

\begin_layout Standard
The built samples can be found on 
\series bold
TotalCrossSDK/dist/samples
\series default
.
 Just follow the installation instructions from chapter 6 and run the sample
 on your target platform.
\end_layout

\begin_layout Chapter
Building and deploying your first TotalCross application
\end_layout

\begin_layout Standard
TotalCross applications are developed almost exactly like Java applications,
 so anyone familiar with Java should be able to start small TotalCross applicati
ons in a few minutes.
\end_layout

\begin_layout Standard
However, this similarity is often also source of problems, so before writing
 any code, we must first be aware of the differences between Java and TotalCross
 development.
\end_layout

\begin_layout Itemize
The entry point of a TotalCross application is always a class that extends
 the class MainWindow (directly or indirectly) or implements the interface
 MainClass.
 It is not possible to directly run TotalCross applications in Java, in
 this case, you must use the Launcher provided with the SDK.
 (see Chapter 4 for details about the totalcross.Launcher)
\end_layout

\begin_layout Itemize
For your convenience, the TotalCross package “totalcross.lang” is directly
 mapped to the Java package “java.lang”.
 Therefore, you may refer to classes from this package, like Object or String,
 like you would in any Java application, without requiring any explicit
 import.
\end_layout

\begin_deeper
\begin_layout Standard
Unfortunately this feature can be misleading, because the opposite is NOT
 true.
 The java.lang package does have members (interfaces, classes, exceptions
 or errors) that are not available in totalcross.lang – and some of the members
 that are available, may not implement all the methods provided by the homonymou
s member.
 Some examples are the Integer class and the String method “split”, which
 are not implemented by TotalCross.
\end_layout

\begin_layout Standard
This is one of the most common pitfalls when developing TotalCross applications
 using a Java IDE, because its content assist will show classes and methods
 that are not implemented by TotalCross, and therefore, not available on
 the device.
\end_layout

\begin_layout Standard
To avoid this problem, the TotalCross deployer verifies the class files,
 reporting any invalid references found.
 The deployer will throw an Exception if you try to deploy an application
 with references to classes not available in totalcross.lang.
\end_layout

\end_deeper
\begin_layout Itemize
TotalCross is compatible only with the Java 1.1 class file format, therefore
 the class files MUST be generated targeting the JDK 1.1 and the source files
 must be compatible with JDK 1.2.
\end_layout

\begin_deeper
\begin_layout Standard
If you're compiling using javac from command line (or an ANT file), add
 this to your command line: "-target 1.1 -source 1.2".
\end_layout

\begin_layout Standard
If you're using a Java IDE, look for its Java Compiler settings and set
 its compliance level to 1.3.
\end_layout

\begin_layout Standard
Again, the deployer will throw an Exception if it detects an invalid class
 file format.
\end_layout

\end_deeper
\begin_layout Section
Building a sample application
\end_layout

\begin_layout Standard
For our first application, let's make a typical “Hello World” application
 using just your preferred plain text editor.
\end_layout

\begin_layout Standard
First, make sure you have a JDK installed (preferably the JDK 6) and the
 environment variables are set.
 There should be a JAVA_HOME variable set with the installation path of
 your JDK, like “C:
\backslash
Program Files
\backslash
Java
\backslash
jdk1.6.0_11”.
\end_layout

\begin_layout Standard
And another variable named PATH, which should contain a list of paths, separated
 by semicolons, with the path to the JDK's bin directory, like “%JAVA_HOME%
\backslash
bin”.
 If you don't do this, you will get the error: “[preverify] JAR file creation
 failed with error -1”.
\end_layout

\begin_layout Standard
You may also add the path to the TotalCross jar file (located in TotalCrossSDK/d
ist/tc.jar) to your CLASSPATH environment variable (or create one if the
 variables does not exists).
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
The usage of the CLASSPATH variable is usually not advised, because it may
 cause conflicts when different classes share the same package structure.
 Creating an ANT build file and using the command line option -classpath
 is a better choice.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Open your text editor and write the code below, saving the file as HelloWorld.jav
a:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinputlisting[label=samplecode,caption=A sample]{companion_resources/listings/
HelloWorld.java}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Don't worry about understanding the code, this will be covered later.
\end_layout

\begin_layout Standard
Now open a command shell at the directory where the HelloWorld.java was saved,
 and execute the following command:
\end_layout

\begin_layout Standard

\family typewriter
javac -target 1.1 -source 1.2 HelloWorld.java
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
Remember, If you preferred to not use the CLASSPATH variable, you must ALWAYS
 specify the path to the tc.jar file using the -classpath option, like this:
\end_layout

\begin_layout Plain Layout

\family typewriter
javac -classpath C:
\backslash
TotalCrossSDK
\backslash
dist
\backslash
tc.jar -target 1.1 -source 1.2 HelloWorld.java
\end_layout

\begin_layout Plain Layout
Otherwise, the Java compiler won't be able to find the TotalCross classes
 used by the application.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
If successful, the Java compiler should finish silently, creating a new
 file named HelloWorld.class.
\end_layout

\begin_layout Section
Running with the Launcher (on JDK)
\end_layout

\begin_layout Standard
Using the Launcher, we can run our application and take a look at the result.
 Using a command shell, execute the following command:
\end_layout

\begin_layout Standard

\family typewriter
java -classpath .;%CLASSPATH% totalcross.Launcher HelloWorld
\end_layout

\begin_layout Standard
Here we are executing the Java application totalcross.Launcher, passing the
 name of our main class (case sensitive) as argument.
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
In this case, the usage of the option -classpath is needed because the HelloWorl
d.class is not in a valid package directory structure, so we must add the
 current folder to the classpath.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The following window should appear on your screen
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename companion_resources/images/companion_HelloWorld_JDK.png
	scale 75

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Congratulations, you just started your first TotalCross application running
 on JDK!
\end_layout

\begin_layout Section
Deploying and running on Win32
\end_layout

\begin_layout Standard
The Launcher provided us a quick way to look at our application's appearance,
 but that's still a Java application.
 To actually deploy our application to all platforms supported by TotalCross,
 go back to the command shell and execute this command:
\end_layout

\begin_layout Standard

\family typewriter
java tc.Deploy HelloWorld -all
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
Remember to use the -classpath option with the tc.jar path if you're not
 using the CLASSPATH environment variable.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This time, we are executing the program tc.Deploy, passing the name of our
 main class as the first argument, and the platforms to deploy as the second
 argument – in this case all platforms.
 (see Chapter 5 for more information about the Deployment process)
\end_layout

\begin_layout Standard
A new folder named “install” will be created, and inside it you should find
 several folders, each one containing the installer (or the executable)
 for each supported platform.
\end_layout

\begin_layout Standard
We should be able now to run the Win32 version of our application, so let's
 move to ./install/win32 and run the executable HelloWorld.exe, which should
 look like this:
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename companion_resources/images/companion_HelloWorld_Win32.png
	scale 75

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The default screen size is 240x320.
 You can change the screen size and position by editing the exe shortcut
 and adding the parameter 
\family typewriter
/scr x,y,width,height
\family default
.
 The possible values are: -1 to use the default and -2 to center on screen.
 Ex: "
\family typewriter
/scr -2,100,320,-1
\family default
" will open a window horizontally centered at y=100, w=320, h=320 (default
 is 0,0,240,320).
\end_layout

\begin_layout Standard
On the next chapter we'll see installation instructions for each platform.
 Practice by installing our application on different devices and see how
 it looks like on each one.
\end_layout

\begin_layout Chapter
The Launcher 
\end_layout

\begin_layout Standard
The TotalCross Launcher, is a Java application that allows you to run a
 TotalCross application over the installed JDK, providing you a quick way
 to run and test your application.
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
Some people think that running the application at desktop under an IDE (such
 as Eclipse or Netbeans) will use the TotalCross virtual machine.
 This is not true: the actual virtual machine used is the one provided in
 the Java Development Kit installed (or java.exe).
\end_layout

\end_inset


\end_layout

\begin_layout Standard
You may also pass arguments to the Launcher to simulate different resolutions
 and styles, and have an idea of how your application is going to look like
 on a particular device.
\end_layout

\begin_layout Standard
The basic format for using the Launcher is:
\end_layout

\begin_layout Standard

\family typewriter
totalcross.Launcher [optional arguments] <main class>
\end_layout

\begin_layout Standard
The optional arguments can be any combination of the following (not case
 sensitive):
\end_layout

\begin_layout Itemize
Screen resolution and color depth 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
TabPositions{3.5cm}
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Labeling
\labelwidthstring /scr.<W>x<H>x<BPP>
/scr
\begin_inset space ~
\end_inset

<W>x<H> : sets the width and height.
\end_layout

\begin_layout Labeling
\labelwidthstring /scr.<W>x<H>x<BPP>
/scr
\begin_inset space ~
\end_inset

<W>x<H>x<BPP> : sets the width, height and color depth.
\end_layout

\begin_layout Labeling
\labelwidthstring /scr.<W>x<H>x<BPP>
/scr
\begin_inset space ~
\end_inset

PalmLo : Palm OS low 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
tab
\end_layout

\end_inset

 (same of /scr 160x160x8)
\end_layout

\begin_layout Labeling
\labelwidthstring /scr.<W>x<H>x<BPP>
/scr
\begin_inset space ~
\end_inset

PalmHI : Palm OS high 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
tab
\end_layout

\end_inset

 (same of /scr 320x320x16) 
\series bold
default
\end_layout

\begin_layout Labeling
\labelwidthstring /scr.<W>x<H>x<BPP>
/scr
\begin_inset space ~
\end_inset

PalmTall : Palm OS tall 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
tab
\end_layout

\end_inset

 (same of /scr 320x480x16)
\end_layout

\begin_layout Labeling
\labelwidthstring /scr.<W>x<H>x<BPP>
/scr
\begin_inset space ~
\end_inset

PalmWide : Palm OS wide 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
tab
\end_layout

\end_inset

 (same of /scr 480x320x16)
\end_layout

\begin_layout Labeling
\labelwidthstring /scr.<W>x<H>x<BPP>
/scr
\begin_inset space ~
\end_inset

WinCE : Windows CE 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
tab
\end_layout

\end_inset

 (same of /scr 240x320x16)
\end_layout

\begin_layout Labeling
\labelwidthstring /scr.<W>x<H>x<BPP>
/scr
\begin_inset space ~
\end_inset

Win32 : Windows 32 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
tab
\end_layout

\end_inset

 (same of /scr 240x320x24)
\end_layout

\begin_layout Labeling
\labelwidthstring /scr.<W>x<H>x<BPP>
/scr
\begin_inset space ~
\end_inset

bbLo : BlackBerry low 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
tab
\end_layout

\end_inset

 (same of /scr 320x240x16)
\end_layout

\begin_layout Labeling
\labelwidthstring /scr.<W>x<H>x<BPP>
/scr
\begin_inset space ~
\end_inset

bbBold : BlackBerry Bold 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
tab
\end_layout

\end_inset

 (same of /scr 480x360x16)
\end_layout

\begin_layout Labeling
\labelwidthstring /scr.<W>x<H>x<BPP>
/scr
\begin_inset space ~
\end_inset

bbStorm : BlackBerry Storm 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
tab
\end_layout

\end_inset

 (same of /scr 480x320x16)
\end_layout

\begin_layout Labeling
\labelwidthstring /scr.<W>x<H>x<BPP>
/scr
\begin_inset space ~
\end_inset

iPhone : iPhone 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
tab
\end_layout

\end_inset

 (same of /scr 320x480x24)
\end_layout

\begin_layout Labeling
\labelwidthstring /scr.<W>x<H>x<BPP>
/scr
\begin_inset space ~
\end_inset

android : Android 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
tab
\end_layout

\end_inset

 (same of /scr 320x480x16)
\end_layout

\end_deeper
\begin_layout Itemize
Color depth
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
TabPositions{6cm}
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Labeling
\labelwidthstring bpp.320
/bpp
\begin_inset space ~
\end_inset

8 : emulates 8 bits per pixel screens.
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
tab
\end_layout

\end_inset

 (256 colors)
\end_layout

\begin_layout Labeling
\labelwidthstring bpp.320
/bpp
\begin_inset space ~
\end_inset

16 : emulates 16 bits per pixel screens.
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
tab
\end_layout

\end_inset

 (64K colors)
\end_layout

\begin_layout Labeling
\labelwidthstring bpp.320
/bpp
\begin_inset space ~
\end_inset

24 : emulates 24 bits per pixel screens.
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
tab
\end_layout

\end_inset

 (16M colors)
\end_layout

\begin_layout Labeling
\labelwidthstring bpp.320
/bpp
\begin_inset space ~
\end_inset

32 : emulates 32 bits per pixel screens.
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
tab
\end_layout

\end_inset

 (16M colors without transparency)
\end_layout

\end_deeper
\begin_layout Itemize
User interface style
\end_layout

\begin_deeper
\begin_layout Labeling
\labelwidthstring uiStyle.Android0
/uiStyle
\begin_inset space ~
\end_inset

WinCE : Windows CE user interface style
\end_layout

\begin_layout Labeling
\labelwidthstring uiStyle.Android0
/uiStyle
\begin_inset space ~
\end_inset

PalmOS : Palm OS user interface style
\end_layout

\begin_layout Labeling
\labelwidthstring uiStyle.Android0
/uiStyle
\begin_inset space ~
\end_inset

Flat : Flat user interface style
\end_layout

\begin_layout Labeling
\labelwidthstring uiStyle.Android0
/uiStyle
\begin_inset space ~
\end_inset

Vista : Vista user interface style
\end_layout

\begin_layout Labeling
\labelwidthstring uiStyle.Android0
/uiStyle
\begin_inset space ~
\end_inset

Android : Android user interface style
\end_layout

\end_deeper
\begin_layout Itemize
Device characteristics
\end_layout

\begin_deeper
\begin_layout Labeling
\labelwidthstring virtualKeyboard0
/penlessDevice : acts as a device that has no touch screen.
\end_layout

\begin_layout Labeling
\labelwidthstring virtualKeyboard0
/geofocus : uses geographical focus (also activates penlessDevice)
\end_layout

\begin_layout Labeling
\labelwidthstring virtualKeyboard0
/fingerTouch : simulates the use of fingers (since a finger is less precise
 than a pen, uses an algorithm to find the control near the finger and also
 activates drag and flick).
\end_layout

\begin_layout Labeling
\labelwidthstring virtualKeyboard0
/unmovableSip : specifies that the Soft Input Panel is unmovable, and simulates
 the screen shift that's made when an Edit or MultiEdit gains focus.
\end_layout

\begin_layout Labeling
\labelwidthstring virtualKeyboard0
/keypadOnly : acts as a device that has only the 0-9{*}
\backslash
# keys
\end_layout

\begin_layout Labeling
\labelwidthstring virtualKeyboard0
/virtualKeyboard : specifies that the device does not have a physical keyboard
 (or it has but the keyboard is closed)
\end_layout

\end_deeper
\begin_layout Itemize
Others
\end_layout

\begin_deeper
\begin_layout Labeling
\labelwidthstring showmousepos00
/pos
\begin_inset space ~
\end_inset

x,y : sets the opening position of the application.
\end_layout

\begin_layout Labeling
\labelwidthstring showmousepos00
/scale
\begin_inset space ~
\end_inset

<0.1
\begin_inset space ~
\end_inset

to
\begin_inset space ~
\end_inset

4> : scales the screen, magnifying the contents (if greater than 1) or shrinking
 (if between 0 and 1).
\end_layout

\begin_layout Labeling
\labelwidthstring showmousepos00
/dataPath
\begin_inset space ~
\end_inset

<path> : sets where the PDB and media files are stored.
\end_layout

\begin_layout Labeling
\labelwidthstring showmousepos00
/cmdLine
\begin_inset space ~
\end_inset

<...> : the rest of the arguments (except the last one) are passed as the command
 line to the application being launched.
\end_layout

\begin_layout Labeling
\labelwidthstring showmousepos00
/showmousepos : shows the mouse position (only when running under JavaSE).
\end_layout

\end_deeper
\begin_layout Standard
The last argument passed to the Launcher is always the qualified name of
 the main class of the application to be launched (for example, tc.samples.ui.gadge
ts.UIGadgets)
\end_layout

\begin_layout Standard
When running the application, the emulator shows some function keys that
 can be used to emulate a device key.
 For example, F9 tests the screen rotation using the Launcher and F11 opens
 the keyboard (or calendar) in an Edit field.
\end_layout

\begin_layout Chapter
Deployment Process
\end_layout

\begin_layout Standard
To deploy your TotalCross application, you must use the Java application
 named tc.Deploy, packaged with the tc.jar located at 
\series bold
TotalCrossSDK/dist
\series default
.
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
To run a Java application from a jar file, you must specify the source jar
 to the Java classpath, e.g.
 
\family typewriter
java -classpath C:
\backslash
TotalCrossSDK
\backslash
dist
\backslash
tc.jar tc.Deploy […]
\family default
.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The tc.Deploy program will, starting in the working directory, create folders
 with the installation files for each platform.
 A .tcz file is outputted with all classes and its dependencies, already
 translated to the target opcodes, and compressed with ZLib to save space.
 We recommend that the original classes are compiled with debug information,
 because line numbers will be included in the tcz and will be available
 in the stack trace (all other debug information are discarded).
 Bmp and Gif files are automatically converted to 24bpp Png files (JPeg
 are kept in its original format – read more about images below).
 The tcz file is not compliant with the .zip format, although ZLib is used,
 because we need to store more information in the tcz file.
 Note that, since we translate the programs to our opcodes, there's no need
 to run obfuscators in the class file, because obfuscation is already done
 by the converter.
 Actually, tcz files are 1/4 of the original .class size, 50% due to our
 tclass file format and 50% more due to the zlib compression.
 
\end_layout

\begin_layout Section
Parameters
\end_layout

\begin_layout Standard
The basic format is: 
\end_layout

\begin_layout Standard

\family typewriter
tc.Deploy <application/library to deploy> <target platforms> [other options]
\end_layout

\begin_layout Standard
Where:
\end_layout

\begin_layout Enumerate
<application/library to deploy> must be one of the following:
\end_layout

\begin_deeper
\begin_layout Itemize
The main class file name (the .class, not the .java).
 You can pass the full path to the main class file instead of its fully
 qualified name (App x my.sample.App).
\begin_inset Newline newline
\end_inset

For example, to deploy my.sample.App at C:/myprogram/classes/my/sample/App.class:
\begin_inset Newline newline
\end_inset


\family typewriter
cd C:/myprogram/classes
\begin_inset Newline newline
\end_inset

tc.Deploy my/sample/App.class
\family default

\begin_inset Newline newline
\end_inset

or
\begin_inset Newline newline
\end_inset


\family typewriter
tc.Deploy c:/myprogram/classes/my/sample/App.class
\family default

\begin_inset Newline newline
\end_inset

The correct package is automatically detected from the class file.
\end_layout

\begin_layout Itemize
The folder that contains a single class that implements MainClass or directly
 extends one of the following classes: MainWindow, Conduit, TestSuite or
 GameEngineMainWindow.
\end_layout

\begin_deeper
\begin_layout Standard
This option will not work if your main class extends a class which in turn
 extends one of the classes listed above.
\end_layout

\begin_layout Standard
For instance:
\end_layout

\begin_layout Standard
Assuming App is the main class, “MainWindow 
\begin_inset Formula $\Leftarrow$
\end_inset

 App” will work, but “MainWindow 
\begin_inset Formula $\Leftarrow$
\end_inset

 AnotherClass 
\begin_inset Formula $\Leftarrow$
\end_inset

 App” will not work.
\end_layout

\begin_layout Standard
This option will also fail if the given folder contains more than one valid
 main class.
\end_layout

\begin_layout Standard
The deployer automatically detects and includes Class.forName references.
\end_layout

\end_deeper
\begin_layout Itemize
A jar or zip file containing all the required files, like “tc.Deploy App.jar”
 or “tc.Deploy App.zip” (a jar file is basically a zip file with a new extension).
 To create a jar file, open the command prompt, change to the class files
 folder (usually /bin or /classes), and type: jar cvf App.jar .
\end_layout

\begin_deeper
\begin_layout Standard
Please notice this is the only option that does not require a main class
 to be used, therefore, it's the only valid option to create libraries (which
 usually does not have a main class).
\end_layout

\begin_layout Standard
However, if you use this option to deploy an application, the jar/zip file
 must have the same name of the main class.
 (e.g.
 if your main class is App.class, the resulting jar/zip file must be either
 App.jar or App.zip).
\end_layout

\end_deeper
\end_deeper
\begin_layout Enumerate
<platforms to deploy> must be any combination of the following:
\end_layout

\begin_deeper
\begin_layout Labeling
\labelwidthstring -palm.or.-palmos0
-palm
\begin_inset space ~
\end_inset

or
\begin_inset space ~
\end_inset

-palmos Creates the PalmOS files (pdb and prc if a main class is detected,
 otherwise only a pdb file) and also an installer, which is an executable
 that contains the created files.
\end_layout

\begin_layout Labeling
\labelwidthstring -palm.or.-palmos0
-ce
\begin_inset space ~
\end_inset

or
\begin_inset space ~
\end_inset

-wince Creates the cab files for WinCE, and a batch installer which invokes
 your synchronization software (ActiveSync or Windows Mobile Device Center).
\end_layout

\begin_layout Labeling
\labelwidthstring -palm.or.-palmos0
-winmo Creates a cab file for Windows Mobile only.
\end_layout

\begin_layout Labeling
\labelwidthstring -palm.or.-palmos0
-win32 Creates an executable file to run the application in Win32.
\end_layout

\begin_layout Labeling
\labelwidthstring -palm.or.-palmos0
-bb
\begin_inset space ~
\end_inset

or
\begin_inset space ~
\end_inset

-blackberry Creates the cod file for BlackBerry.
\end_layout

\begin_layout Labeling
\labelwidthstring -palm.or.-palmos0
-applet
\begin_inset space ~
\end_inset

or
\begin_inset space ~
\end_inset

-html Creates the HTML files and a jar file.
\end_layout

\begin_layout Labeling
\labelwidthstring -palm.or.-palmos0
-android Creates the apk file for Android.
\end_layout

\begin_layout Labeling
\labelwidthstring -palm.or.-palmos0
-linux Creates the binary and the tcz files for Linux
\end_layout

\begin_layout Labeling
\labelwidthstring -palm.or.-palmos0
-all Single command to create all of the above.
\end_layout

\end_deeper
\begin_layout Enumerate
[other options] may be any combination of the following options:
\end_layout

\begin_deeper
\begin_layout Labeling
\labelwidthstring 00.00.0000
/a
\begin_inset space ~
\end_inset

ApId : Assigns the application id; can only be used for libraries or passing
 a tcz file.
 Under normal situations, set the Settings.applicationId.
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
/autostart : automatically starts the application after a boot is completed.
 Currently works for Android only.
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
/c
\begin_inset space ~
\end_inset

cmd : Specify a command line to be passed to the application.
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
/i
\begin_inset space ~
\end_inset

platforms : Pass a list of comma-separated platforms to let the generated
 file be installed.
 Currently works on for Android.
 E.G.: “/i android”.
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
/k : Keep the exe and other temporary files during WinCE generation (the
 files needed for manual installation).
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
/kn : As /k, but does not create the cab files for wince
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
/m
\begin_inset space ~
\end_inset

path : Specifies a path to the mobileprovision and certificate store to
 deploy an ipa file for iOS
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
/n
\begin_inset space ~
\end_inset

name : Override the name of the tcz file with the given one.
 Only works when deploying a jar or a tcz file.
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
/o
\begin_inset space ~
\end_inset

path : Override the output folder (defaults to the current folder) to the
 given one.
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
/p
\begin_inset space ~
\end_inset

type : Package the vm (and optionally Litebase) with the application, creating
 a single installation file.
 The type parameter can be one of the following: demo, demo+litebase, release,
 release+litebase (where demo/release are the virtual machine types you
 want to include: the time-limited demonstration, or the release that requires
 activation).
 The DEMO SDKs must be in the path or in the TOTALCROSS_HOME/LITEBASE_HOME
 environment variables, and the RELEASE SDKs must be in the same parent
 folder of the DEMO ones.
 Example: if TOTALCROSS_HOME points to t:
\backslash
sdks
\backslash
TotalCrossSDK, then the VMS must be at t:
\backslash
sdks
\backslash
TotalCrossVMS.
 If the TOTALCROSS_HOME and LITEBASE_HOME are not set, then all SDKs must
 be at the top-level folder of the TotalCrossSDK
\backslash
etc folder.
\begin_inset Newline newline
\end_inset

The files are always installed at the same folder of the application, so
 each application will have its own vm/litebase.
 You can optionally set four environment variables, pointing to the folder
 of each SDK (these will have priority over the other locations previously
 described): 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
TabPositions{4.5cm}
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
TOTALCROSS_DEMO 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
tab
\end_layout

\end_inset

 : must point to TotalCrossSDK folder
\end_layout

\begin_layout Itemize
TOTALCROSS_RELEASE 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
tab
\end_layout

\end_inset

 : must point to TotalCross VMS folder
\end_layout

\begin_layout Itemize
LITEBASE_DEMO 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
tab
\end_layout

\end_inset

 : must point to LitebaseSDK folder
\end_layout

\begin_layout Itemize
LITEBASE_RELEASE 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
tab
\end_layout

\end_inset

 : must point to LitebaseVMS folder
\end_layout

\end_deeper
\begin_layout Labeling
\labelwidthstring 00.00.0000
/r
\begin_inset space ~
\end_inset

key : signs the tcz file with the given registration key (used when you
 purchase a vm license).
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
/s
\begin_inset space ~
\end_inset

pass : Launch the BlackBerry SignatureTool and automatically sign the COD
 module using the password provided.
 If no password is provided, the SignatureTool will be launched and you
 will have to specify a password manually.
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
/t : only tests if the class is ok to be deployed; no tcz files not installation
 files are generated.
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
/v : Verbose output for information messages.
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
/w : if an error occurs, waits for the ENTER key to be pressed before the
 window closes.
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
/x
\begin_inset space ~
\end_inset

list : Comma-separated list of class names that must be excluded (in a starts-wi
th manner).
\end_layout

\end_deeper
\begin_layout Section
Options retrieved from the static initializer
\end_layout

\begin_layout Standard
You may have noticed that there's no need to pass any parameters for the
 application, like creator id or the icon's title.
 All these are inferred from the default constructor and the static initializer
 of the main class.
\end_layout

\begin_layout Standard
The following patterns are used:
\end_layout

\begin_layout Standard
\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Subsection
Icon
\begin_inset space ~
\end_inset

Title
\end_layout

\begin_layout Labeling
\labelwidthstring Resulting.property0
Default
\begin_inset space ~
\end_inset

value Main class' name.
\end_layout

\begin_layout Labeling
\labelwidthstring Resulting.property0
Code
\begin_inset space ~
\end_inset

inferred 
\family typewriter
super(“My application”, border_type);
\end_layout

\begin_layout Labeling
\labelwidthstring Resulting.property0
Resulting
\begin_inset space ~
\end_inset

property "My application" is used as the icon's title.
 You may change the application's title to something else if desired: 
\family typewriter
super("My icon title", border_type); setTitle("My app title");
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Subsection
Application Title
\end_layout

\begin_layout Labeling
\labelwidthstring Resulting.property0
Default
\begin_inset space ~
\end_inset

value 
\family typewriter
null
\end_layout

\begin_layout Labeling
\labelwidthstring Resulting.property0
Code
\begin_inset space ~
\end_inset

inferred 
\family typewriter
super("My application" + “ “ + Settings.appVersion, border_type);
\end_layout

\begin_layout Labeling
\labelwidthstring Resulting.property0
Resulting
\begin_inset space ~
\end_inset

property "My application" is used as the icon's title, but the application
 title would be something like “My application 1.3”.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Subsection
Application
\begin_inset space ~
\end_inset

ID
\end_layout

\begin_layout Labeling
\labelwidthstring Resulting.property0
Default
\begin_inset space ~
\end_inset

value An ID is created based on the name of the main class.
\end_layout

\begin_layout Labeling
\labelwidthstring Resulting.property0
Code
\begin_inset space ~
\end_inset

inferred 
\family typewriter
static {Settings.applicationId = "Crtr";}
\end_layout

\begin_layout Labeling
\labelwidthstring Resulting.property0
Resulting
\begin_inset space ~
\end_inset

property "Crtr" will be the creator id (in TotalCross it is called application
 id, which is the correct name that Palm should have used).
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Subsection
Application
\begin_inset space ~
\end_inset

Version
\end_layout

\begin_layout Labeling
\labelwidthstring Resulting.property0
Default
\begin_inset space ~
\end_inset

value 
\family typewriter
null
\end_layout

\begin_layout Labeling
\labelwidthstring Resulting.property0
Code
\begin_inset space ~
\end_inset

inferred 
\family typewriter
static {Settings.appVersion = "1.3";}
\end_layout

\begin_layout Labeling
\labelwidthstring Resulting.property0
Resulting
\begin_inset space ~
\end_inset

property "1.3" will be used to set the version of the application in the
 stubs.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Subsection
Company
\begin_inset space ~
\end_inset

Informations
\end_layout

\begin_layout Labeling
\labelwidthstring Resulting.property0
Default
\begin_inset space ~
\end_inset

value 
\family typewriter
null
\end_layout

\begin_layout Labeling
\labelwidthstring Resulting.property0
Code
\begin_inset space ~
\end_inset

inferred 
\family typewriter
static {
\end_layout

\begin_deeper
\begin_layout Plain Layout

\family typewriter
Settings.companyInfo = "My company information";
\end_layout

\begin_layout Plain Layout

\family typewriter
Settings.companyContact = “me@company.com”;
\end_layout

\begin_layout Plain Layout

\family typewriter
}
\end_layout

\end_deeper
\begin_layout Labeling
\labelwidthstring Resulting.property0
Resulting
\begin_inset space ~
\end_inset

property "This is my company information" will be used as the company's
 information.
 You may also use this in an About box in your program.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Subsection
Application
\begin_inset space ~
\end_inset

Information
\end_layout

\begin_layout Labeling
\labelwidthstring Resulting.property0
Default
\begin_inset space ~
\end_inset

value 
\family typewriter
null
\end_layout

\begin_layout Labeling
\labelwidthstring Resulting.property0
Code
\begin_inset space ~
\end_inset

inferred 
\family typewriter
static {
\end_layout

\begin_deeper
\begin_layout Plain Layout

\family typewriter
Settings.appCategory = “my products”;
\end_layout

\begin_layout Plain Layout

\family typewriter
Settings.appLocation = “www.mycompany.com”;
\end_layout

\begin_layout Plain Layout

\family typewriter
Settings.appDescription = “This is my program”;
\end_layout

\begin_layout Plain Layout

\family typewriter
}
\end_layout

\end_deeper
\begin_layout Labeling
\labelwidthstring Resulting.property0
Resulting
\begin_inset space ~
\end_inset

property The appCategory is used in the iphone and palm platforms.
\begin_inset Newline newline
\end_inset

The appLocation is used in the iphone platform.
\begin_inset Newline newline
\end_inset

The appDescription is used in the iphone and blackberry platforms.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
If you specify these outside the static initializer, like in the constructor,
 default values will be assumed.
\end_layout

\begin_layout Standard
There are other options that are set by the programmer in the static initializer
: 
\end_layout

\begin_layout Itemize
Settings.closeButtonType: for WinCE only, can assume three options: NO_BUTTON,
 which shows no button in the task bar; CLOSE_BUTTON, which shows the default
 OK button that closes the application, or MINIMIZE_BUTTON, which uses a
 x button to minimize the application.
\end_layout

\begin_layout Itemize
Settings.fullScreen: makes it full screen at startup.
\end_layout

\begin_layout Itemize
Settings.fullScreenPlatforms: select which platforms the fullScreen member
 will be applied to.
\end_layout

\begin_layout Itemize
Settings.useNewFont: use the new font format introduced in version 1.3
\end_layout

\begin_layout Itemize
Settings.activationServerURI and activationServerNamespace: define the middleware
 server that will be used to restrict the activations.
 Read more in the Activation Server chapter.
\end_layout

\begin_layout Section
Specifying the Icon
\end_layout

\begin_layout Standard
The easiest way to create an icon is to provide an 'appicon.gif' file of
 any SQUARE size (80x80 preferable) and any palette, which will be automatically
 converted to the target icon sizes.
 Put the file in the src folder.
\end_layout

\begin_layout Standard
If the appearance of the icons does not satisfy, you can create some bmp
 and png files for each platform: 
\end_layout

\begin_layout Itemize
Palm OS: icon15x9x8.bmp, icon30x18x8.bmp, icon22x22x8.bmp, icon44x44x8.bmp
\end_layout

\begin_layout Itemize
Windows: icon16x16x8.bmp icon32x32x8.bmp icon48x48x8.bmp
\end_layout

\begin_layout Itemize
iPhone: icon60x60.png
\end_layout

\begin_layout Itemize
Blackberry: icon80x80.png
\end_layout

\begin_layout Itemize
Android: icon72x72.png.
 Use alpha-channel on PNG for better appearance).
 
\end_layout

\begin_layout Standard
Be careful with the palette of the bmp files, never use the MSPaint program;
 instead, get the bmp files that are in the etc/images folder and edit them
 in a software that keeps the original palette, like Photoshop and PaintShopPro.
\end_layout

\begin_layout Section
Adding other files to the package
\end_layout

\begin_layout Standard
Optionally, you can create a PKG file with additional files that will be
 added to the install.exe or to the cab files.
 The file must have a set of [G] and/or [L] lines followed by the file name
 (which is searched in the classpath and in current folder).
 Files prefixed with [G] are placed in the same folder of the tcvm, and
 [L] in the application's folder.
 If the file ends with a slash, indicating that its a path, all files inside
 that path will be added.
\end_layout

\begin_layout Standard
The possible pkg files are: palm.pkg, wince.pkg, iphone.pkg, android.pkg, bb.pkg,
 linux.pkg, win32.pkg – for each platform, or all.pkg for all platforms.
\end_layout

\begin_layout Standard
See other options running tc.
 Deploy without parameters.
\end_layout

\begin_layout Chapter
Installing your application
\end_layout

\begin_layout Section
BlackBerry
\end_layout

\begin_layout Subsection
Deployment
\end_layout

\begin_layout Standard
You must update your ROM to version 4.3.
 TotalCross will not run on versions before that one.
\end_layout

\begin_layout Standard
To deploy a TotalCross application or library for BlackBerry devices, run
 tc.Deploy as follows:
\end_layout

\begin_layout Standard

\family typewriter
tc.Deploy [-Drim.root=“rim_root”] [-Drim.class.path=“rim_class_path”] [/s [password]
] “application” -bb 
\end_layout

\begin_layout Standard
Where:
\end_layout

\begin_layout Itemize
“rim_root” is the path to the BlackBerry JDE or BlackBerry Component Package
 root directory.
 If not specified, tc.Deploy will use the internal BlackBerry Component Package
 distribution: “…/TotalCrossSDK/etc/tools/bb”.
\end_layout

\begin_layout Itemize
“rim_class_path” is the set of paths to search for BlackBerry libraries
 (.jar files).
 This path must include the BlackBerry library (net_rim_api.jar), the TotalCross
 for BlackBerry (tcbb.jar) and any other TotalCross libraries needed by your
 application (like Litebase, for example).
 If not specified, tc.Deploy will search for libraries only under the default
 library directory: “rim.root/lib”.
\end_layout

\begin_layout Itemize
“application” is path to the main class of your application, or the .jar
 file containing the application or the library to be deployed.
\end_layout

\begin_layout Standard
If the optional parameter “/s” is specified, tc.Deploy will automatically
 open the SignatureTool after the TotalCross application or library has
 been deployed, so you can type the password (you may also give the password
 as a parameter to /s).
 It is important to say that the two signature files (see the Signature
 section for details) must be placed under the TotalCrossSDK/etc/tools/bb/bin
 directory, otherwise the deployer will claim that no signature key was
 found.
\end_layout

\begin_layout Subsection
Installation
\end_layout

\begin_layout Standard
To install a TotalCross application or library on BlackBerry devices or
 the simulators, first you have to deploy it.
 Then, make sure tc.Deploy has generated the following files under the “…/install
/bb” directory:
\end_layout

\begin_layout Itemize
“application_name”.cod contains the application modules for BlackBerry.
 It is used both in desktop and OTA (over-the-air, refer to http://www.blackberry.
com/developers) installations.
\end_layout

\begin_layout Itemize
“application_name”.alx is used together with “application_name”.cod to install
 the application or library using the BlackBerry Desktop Software.
\end_layout

\begin_layout Itemize
“application_name”.jad is used together with “application_name”.cod to install
 the application or library using the OTA method.
\end_layout

\begin_layout Standard
The Desktop installation method is pretty straightforward.
 In the BlackBerry Desktop Software, open the “Application Loader” and follow
 the instructions.
 When the list box containing all the applications that are currently installed
 on the device is displayed, click “Add…”, select the “application_name”.alx
 file and confirm.
 The selected application should appear on the list.
 If so, click “Next” and wait until the process is finished.
 
\end_layout

\begin_layout Standard
You must always install TotalCross.cod, then Litebase.cod, then your application's
 cod file.
 If you don't follow this order, you will have problems.
\end_layout

\begin_layout Subsection
Signature
\end_layout

\begin_layout Standard
Before a TotalCross application can be installed on a BlackBerry device
 it is necessary to sign its module using the SignatureTool and the keys
 provided by RIM – Research In Motion.
 
\end_layout

\begin_layout Standard
If you do not have the signature keys, you must request them directly to
 RIM.
 More information can be found here: http://na.blackberry.com/eng/developers/javaa
ppdev/codekeys.jsp (if this link Is broken, go to www.blackberry.com, click
 Developers at the top row, then click “Java Application Development” at
 left menu, and then “Development Tools and Downloads”) .
 After receiving and registering your keys in your computer, you will see
 the two key files in your BlackBerry JDE or BlackBerry Component Package
 root directory: sigtool.csk and sigtool.db.
 
\end_layout

\begin_layout Standard
Signing a TotalCross application or library is the same as signing any other
 BlackBerry application: you must open SignatureTool (the RIM signature
 application) and load the application .cod module.
 Then, click request, type your password and wait until the signing process
 is finished.
 
\end_layout

\begin_layout Standard
You can also automatically sign TotalCross applications or libraries during
 the deployment process.
 To do this, you must specify the option “/s” when running tc.Deploy (see
 the Deployment section for details).
 
\end_layout

\begin_layout Section
iPhone/iPad
\end_layout

\begin_layout Subsection
Deploying as IPA for enterprise distribution
\end_layout

\begin_layout Standard
After joining Apple's enterprise development program, you'll be able to
 create a certificate to distribute in-house applications.
 Applications signed with this certificate may be distributed 
\emph on
only
\emph default
 for employees of the company that owns the certificate, and may not be
 distributed for third companies.
\end_layout

\begin_layout Standard
First, download and install openssl for your OS.
 (For Win32 
\begin_inset CommandInset href
LatexCommand href
target "http://slproweb.com/products/Win32OpenSSL.html"

\end_inset

)
\end_layout

\begin_layout Standard
Now create a config file with your certificate request info, like this:
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\family typewriter
[ req ]
\end_layout

\begin_layout Plain Layout

\family typewriter
distinguished_name = req_distinguished_name
\end_layout

\begin_layout Plain Layout

\family typewriter
prompt = no
\end_layout

\begin_layout Plain Layout

\family typewriter
[ req_distinguished_name ]
\end_layout

\begin_layout Plain Layout

\family typewriter
emailAddress = john@webmail.com 
\end_layout

\begin_layout Plain Layout

\family typewriter
commonName = John Doe 
\end_layout

\begin_layout Plain Layout

\family typewriter
countryName = BR 
\end_layout

\begin_layout Plain Layout

\family typewriter
stateOrProvinceName = Rio de Janeiro 
\end_layout

\begin_layout Plain Layout

\family typewriter
localityName = Rio de Janeiro
\end_layout

\begin_layout Plain Layout

\family typewriter
organizationName = John's Company
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Now run the following command on the shell:
\end_layout

\begin_layout Standard

\family typewriter
openssl req -nodes -newkey rsa:2048 -keyout request.key -out request.csr -config
 config
\end_layout

\begin_layout Standard
If successful, there will be two new files on the folder: request.key and
 request.csr.
\end_layout

\begin_layout Standard
Now go to the iOS Provisioning Portal and request a new distribution certificate.
 When prompted for a certificate request, use the file request.csr.
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100line%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
Uploading the certificate request may fail on some browsers, but it should
 work on Safari, Chrome or Firefox.
 Try using a different browser if the certificate request is not accepted.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Download the newly created certificate (which name is by default ios_distributio
n.cer) and run the following command:
\end_layout

\begin_layout Standard

\family typewriter
openssl x509 -in ios_distribution.cer -inform DER -out ios_distribution.pem
 -outform PEM
\end_layout

\begin_layout Standard
This command will create the file ios_distribution.pem, now run:
\end_layout

\begin_layout Standard

\family typewriter
openssl pkcs12 -export -inkey request.key -in ios_distribution.pem -out ios_distri
bution.p12
\end_layout

\begin_layout Standard
When prompted for a password, just hit enter and leave it empty.
\end_layout

\begin_layout Standard
Now go back to the iOS Provisioning Portal to create a new mobile provision,
 selecting the same distribution certificate created by our request.
 Download the mobile provision to the same folder.
\end_layout

\begin_layout Standard
After completing this steps you should have the following files:
\end_layout

\begin_layout Description
config used to create a request certificate, may be deleted now.
\end_layout

\begin_layout Description
request.key RSA key used to sign your certificate request, it is no longer
 necessary but you should keep it as it is required to create ios_distribution.p1
2
\end_layout

\begin_layout Description
request.csr certificate request sent to the iOS Provisioning Portal, may
 be deleted now.
\end_layout

\begin_layout Description
ios_distribution.cer certificate downloaded from the iOS Provisioning Portal.
 Required to deploy the application, but it may be redownloaded if lost.
\end_layout

\begin_layout Description
ios_distribution.pem intermediary file used to create ios_distribution.p12,
 may be deleted now.
\end_layout

\begin_layout Description
ios_distribution.p12 key store that contains the keys used to generate the
 certificate.
 Required to deploy the application and must not be password protected.
\end_layout

\begin_layout Standard
When deploying your application you must use the argument /m with the path
 to the certificate and key store that will be used to sign your iOS application.
\end_layout

\begin_layout Standard

\family typewriter
java tc.Deploy .....
 -iphone (or -all) /m <cert-and-keystore-path>
\end_layout

\begin_layout Subsection
Deploying as DEB for jailbroken devices
\end_layout

\begin_layout Standard
First, to deploy TotalCross in your iPhone/iPad, you will have to JailBreak
 it.
\end_layout

\begin_layout Standard
To install a TotalCross application on iPhone, you have two choices: perform
 a manual install or support the package manager named “Cydia”.
\end_layout

\begin_layout Standard
When the iOS is jailbroken, most programs have problems to keep the wifi
 connection working.
 We found an easy way to bypass this: all you have to do is ping to the
 device.
 The best way to do this is to give your iOS device a fixed ip.
 Suppose it is 192.168.2.100; open a command prompt, and type: ping 192.168.2.100
 -n 1000000.
 This will keep pinging the device 1 million times.
 If at the start of the ping you get that the ip is unreachable, open any
 URL at Safari.
 Note that the device's wifi will continue to work even if the screen is
 dimmed, thus, consuming batteries.
 To completely turn off the device, you must press the on-off button.
\end_layout

\begin_layout Subsubsection
"Cydia" support 
\end_layout

\begin_layout Standard
Upload the 2 files (bz2 and deb) that were created by tc.Deploy to a site.
 For example, we will use www.totalcross.com/androidui.
\end_layout

\begin_layout Standard
Run Cydia on the iphone/ipad, press Manage and then the Sources button.
 Press Edit, then Add button.
 Then type the site url you created (e.g.: http://www.totalcross.com/androidui).
 Cydia will then add this site as a source.
 When it returns to the list, select the url in the list and select the
 application you want to install.
 
\end_layout

\begin_layout Standard
If you're running a Windows server, you must add two mimetypes to it: bz2
 (application/bzip2) and deb (application/x-deb).
 Otherwise, Cydia will fail to locate the files in the folder.
\end_layout

\begin_layout Standard
By default, the -iphone will create a bz2 file with a simple program.
 You can join bz2 files of many programs using the tc.tools.deployer.IPhoneBuildSou
rce tool.
\end_layout

\begin_layout Subsubsection
Manual installation of DEB files 
\end_layout

\begin_layout Standard
You can also follow these instructions, which shows two ways to install
 a deb file manually:
\end_layout

\begin_layout Standard
Prerequisites: 
\end_layout

\begin_layout Itemize
A Jailbroken iPhone/iPad/iPodTouch
\end_layout

\begin_layout Itemize
iSpirit.exe (for Windows) installed.
\begin_inset Newline newline
\end_inset

This free software can be found at http://www.ithemesky.com/ispirit
\end_layout

\begin_layout Itemize
Optional: you may also use WinSCP, which can be found at http://winscp.net/eng/do
wnload.php.
 Note that ispirit is much easier.
\end_layout

\begin_layout Standard
Using iSpirit
\end_layout

\begin_layout Enumerate
Select the [Connection Mode].
 If you want to use Wifi, select wifi and put the ip address of the phone.
\end_layout

\begin_layout Enumerate
Press the [Install app] button from the iSpirit menu
\end_layout

\begin_layout Enumerate
From the file browser dialog box that appears below, navigate to and select
 the desired .DEB file by tapping the Select File button.
 
\end_layout

\begin_layout Enumerate
After selecting the desired .DEB file, press the install button shown in
 the above dialog box, and ispirit will do the rest.
 When it completes, your application will be installed and ready to run.
\end_layout

\begin_layout Section
Palm OS
\end_layout

\begin_layout Standard
By default, the application will be installed under a "TotalCross Apps"
 category.
 To change it to another category, set the Settings.appCategory field to
 the desired category.
 Note that there's a limit in the number of categories a Palm device can
 have, the new category is ignored if this limit is reached.
\end_layout

\begin_layout Subsection
Using the installer
\end_layout

\begin_layout Standard
Just execute the installer created by the deployer under the palm directory.
\end_layout

\begin_layout Subsection
Manual installation
\end_layout

\begin_layout Standard
If the installer fails for some reason (required libraries not found or
 incompatible version), you can manually install the pdb and prc files using
 the Palm Quick Install.
\end_layout

\begin_layout Section
Windows CE
\end_layout

\begin_layout Subsection
Using the installer
\end_layout

\begin_layout Standard
Just execute the batch file created by the deployer under the wince directory.
 There are two bat files: one for windows mobile (suffix WMOBILE), and one
 for all others.
 We recommend that you first try the generic one, and only if the installation
 fails, try the WMOBILE version.
 Note that if you created the cab file using tc.Deploy -winmo, only the WMOBILE
 bat file will be installed.
\end_layout

\begin_layout Subsection
Manual installation
\end_layout

\begin_layout Standard
Copy the right cab file to your device and run it from the device's file
 explorer.
 If it doesn't succeed, copy the following files to 
\backslash
TotalCross (or any other folder):
\end_layout

\begin_layout Standard
TotalCrossSDK
\backslash
dist
\backslash
vm
\backslash
wince
\backslash
POCKETPC
\backslash
ARM
\backslash
tcvm.dll
\end_layout

\begin_layout Standard
TotalCrossSDK
\backslash
dist
\backslash
vm
\backslash
TCBase.tcz
\end_layout

\begin_layout Standard
TotalCrossSDK
\backslash
dist
\backslash
vm
\backslash
TCFont.tcz
\end_layout

\begin_layout Standard
If you're using Litebase, you must also copy Litebase.dll and Litebase.tcz.
\end_layout

\begin_layout Subsection
Identifying the right installation for your device
\end_layout

\begin_layout Standard
Each cab file targets a different platform:
\end_layout

\begin_layout Itemize
HPC211 – Handheld PC with Windows CE 2.11
\end_layout

\begin_layout Itemize
HPC2000 – Handheld PC 2000
\end_layout

\begin_layout Itemize
POCKETPC – PocketPC with Windows CE 3.0+
\end_layout

\begin_layout Itemize
WMOBILE – Windows Mobile.
\end_layout

\begin_layout Standard
The Pocket PC also supports the given processors: ARM, MIPS, SH3
\end_layout

\begin_layout Section
Android
\end_layout

\begin_layout Subsection
Installing the device
\end_layout

\begin_layout Standard
After you purchase the device, you have to install the USB driver, which
 can be downloaded from here:
\end_layout

\begin_layout Standard
http://developer.android.com/sdk/oem-usb.html
\end_layout

\begin_layout Standard
If a device that is not recognized, search for “adb driver <device name>”
 in your preferred search engine.
\end_layout

\begin_layout Subsection
Deployment
\end_layout

\begin_layout Standard
How to deploy your application to Android:
\end_layout

\begin_layout Standard

\family typewriter
java tc.Deploy .....
 -android (or -all)
\end_layout

\begin_layout Standard
A directory named install
\backslash
android will be created with a single apk inside.
 This apk contains your application's TCZ and the launcher.
 You can install additional files by creating an android.pkg (or all.pkg).
 The deployer will search for a file named icon72x72.png as a special icon
 for it (remember to use alpha channel in the PNG for better appearance);
 if it don't find the file, it will resize the appicon.gif (already used
 in other platforms) to 72x72 and use it.
 The first time that TotalCross, Litebase and your application runs, it
 will take longer because the TCZ (and possibly other libs) will be being
 decompressed and installed in the application's data folder.
 
\end_layout

\begin_layout Standard
IMPORTANT: In Android you can only read/write from Settings.appPath (which
 is /data/data/totalcross.app.<your application name here>.
 Trying to load from anything else will fail with permission error.
 You can't even list the files elsewhere.
\end_layout

\begin_layout Subsection
Installing in Device
\end_layout

\begin_layout Standard
The ADB (Android Debugging Bridge) is the tool that is used to install applicati
ons in the device, and also to get the log from it.
 This tool is released with the TotalCross SDK and is located at TotalCrossSDK
\backslash
etc
\backslash
tools
\backslash
android.
 If you plan to use it from the command-line, add it to the PATH environment
 variable of your computer.
\end_layout

\begin_layout Standard
Be sure that the Android device is connected to USB and that the driver
 was installed.
 To be able to find if the Android device is ok, type (from cmd):
\end_layout

\begin_layout Standard

\family typewriter
adb devices
\end_layout

\begin_layout Standard
If the device is ok, it will be listed (like this):
\end_layout

\begin_layout Standard

\family typewriter
List of devices attached
\end_layout

\begin_layout Standard

\family typewriter
HT9A3LV00045 device
\end_layout

\begin_layout Standard
The number above is the serial number of the device.
\end_layout

\begin_layout Standard
To install the file in the device, you can use:
\end_layout

\begin_layout Standard

\family typewriter
adb install -r xxx.apk
\end_layout

\begin_layout Standard
Note: if you're running on Windows and installed the TotalCrossSDK.exe, the
 setup.bat file at the root has created a registry entry that adds an “Install
 APK” file to the right-button click in Windows Explorer.
 This greatly helps installing any application in the device.
 So, just open Windows Explorer, select the APK file, right-click your mouse
 button, and select “Install APK”.
 The file will then be downloaded to the device.
 Note that the registry key adds this menu option to all file types, so,
 be careful to use it only with APK files.
\end_layout

\begin_layout Standard
So, if you want to test the UIGadgets.apk, from the command line, use:
\end_layout

\begin_layout Standard

\family typewriter
adb install -r UIGadgets.apk
\end_layout

\begin_layout Standard
Remember to install the TotalCrossVM and Litebase apks as:
\end_layout

\begin_layout Standard

\family typewriter
adb install -r 
\backslash
TotalCrossSDK
\backslash
dist
\backslash
vm
\backslash
android
\backslash
android-tcvm.apk
\end_layout

\begin_layout Standard

\family typewriter
adb install -r 
\backslash
LitebaseSDK
\backslash
dist
\backslash
lib
\backslash
android
\backslash
android-litebase.apk
\end_layout

\begin_layout Standard
You can look at other adb command just typing:
\end_layout

\begin_layout Standard

\family typewriter
adb
\end_layout

\begin_layout Subsection
Debugging
\end_layout

\begin_layout Standard
The Vm.debug outputs to a file named DebugConsole.txt at the application's
 folder.
 You can alternatively set the output to the ADB logger by calling 
\family typewriter
Vm.debug(Vm.ALTERNATIVE_DEBUG)
\family default
.
 Open the command prompt and type:
\end_layout

\begin_layout Standard

\family typewriter
adb logcat TotalCross:I *:S
\end_layout

\begin_layout Standard
You can use the bat file located at: etc/tools/android/debug_console.bat.
 It greatly helps debugging.
\end_layout

\begin_layout Standard
If, for some reason, the application crashes, do this:
\end_layout

\begin_layout Standard

\family typewriter
adb bugreport >bug.txt
\end_layout

\begin_layout Standard
Then zip this 1MB file and send to us.
\end_layout

\begin_layout Chapter
Using the Release Vms
\end_layout

\begin_layout Standard
When you decide to release the application to your client, you must purchase
 TotalCross+Litebase licenses.
 See the correct approach going to the SuperWaba site and clicking the buy
 item at the horizontal menu.
 Once we detect the payment, we will then create an activation key and enable
 it at the site.
 Login in the account and press the “Check activation keys and licenses”.
\end_layout

\begin_layout Standard
The SuperWaba site has two types of accounts: one for the user that downloads
 the SDK, and one for the user that purchases licenses.
 They can even have the same e-mail, however, the passwords are necessarily
 different.
 The account that is used to download the SDK cannot see the activation
 VMs, however, the account that is used to download the activation VMs can
 see both.
 So, if you login using the SDK user and password, you will NOT be able
 to download the VMs, neither see the “Check activation keys and licenses”
 submenu.
\end_layout

\begin_layout Standard
If you have lots of costumers, you can create new activation keys and transfer
 credits between them.
 All this can be done at the site.
 Note that an activation key cannot be deleted.
\end_layout

\begin_layout Standard
More information can be found at the SuperWaba site, under the Products
 menu.
\end_layout

\begin_layout Section
Signing your application
\end_layout

\begin_layout Standard
Once you get access to the activation key, you must sign your application
 with it, using the deploy's /r option.
 Just do something like:
\end_layout

\begin_layout Standard

\family typewriter
java tc.Deploy … /r <activation key>
\end_layout

\begin_layout Section
Activating your application
\end_layout

\begin_layout Standard
After you login with the right account, download the TotalCrossVMS package.
 This package is complimentary to the TotalCrossSDK: it only contains special
 virtual machines that will authenticate to our server (hosted at Rackspace
 – Boston USA) at the first time that the application runs.
\end_layout

\begin_layout Standard
The VM uses the port 80 and connects a webservice located at www.superwaba.net
 server.
 So, if you're behind a firewall or a proxy, remember to allow connections
 to this site.
\end_layout

\begin_layout Standard
The first time that the application runs at the device, it generate a file
 named tcreq.pdb at the application's folder, containing the IMEI and the
 serial number.
 Then it connects to the server and, if succeed, replaces the file with
 a tcsuc.pdb.
\end_layout

\begin_layout Standard
If the device is hard-reseted (looses everything), a new connection to the
 server will be made once the program runs again.
 However, a new license will NOT be consumed, since the device was already
 activated once.
\end_layout

\begin_layout Standard
If you upgrade the device's firmware, the serial number may change.
 In this case, when a new activation is done, it will consume a new license,
 since the information that is used to track the device was changed.
\end_layout

\begin_layout Standard
The license is per-device.
 If the device is stolen, broken, or the costumer replaces it by another
 one, a new license is consumed.
\end_layout

\begin_layout Standard
There's a special contract that can be made with us that will allow you
 to replace a device and return the license.
 Contact us at the site if you desire to be covered by this special agreement.
\end_layout

\begin_layout Standard
Some devices may not have an IMEI nor a serial number accessible by software.
 On these devices, a hard-reset will result in the consumption of one more
 key.
\end_layout

\begin_layout Standard
If you sign your application with two activation keys, the license will
 be discounted again.
\end_layout

\begin_layout Section
Manual Activation
\end_layout

\begin_layout Standard
If you don't have internet connection from the device, you can do a manual
 activation:
\end_layout

\begin_layout Enumerate
Try to activate the device once.
\end_layout

\begin_layout Enumerate
Copy the tcreq.pdb from the application's folder in the device.
\end_layout

\begin_layout Enumerate
Run the manual activation application, located at:
\end_layout

\begin_deeper
\begin_layout Description

\family typewriter
- TotalCrossSDK
\end_layout

\begin_deeper
\begin_layout Description

\family typewriter
- dist
\end_layout

\begin_deeper
\begin_layout Description

\family typewriter
- samples
\end_layout

\begin_deeper
\begin_layout Labeling
\labelwidthstring 00.00.0000

\family typewriter
ManualActivation
\backslash
install
\backslash
win32
\backslash
ManualActivation.exe
\end_layout

\end_deeper
\end_deeper
\end_deeper
\begin_layout Standard
(a linux version is available at install
\backslash
linux folder).
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
If a message stating that the tcvm.dll was not found, copy the tcvm.dll, tcbase.tcz
 and tcfont.tcz for Windows 32 to this folder and try again.
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Select the tcreq.pdb file from within the program.
\end_layout

\begin_layout Enumerate
Our server will be contacted and will write back a tcsuc.pdb file.
\end_layout

\begin_layout Enumerate
Replace the tcreq.pdb by the tcsuc.pdb at the same folder in the device.
\end_layout

\begin_layout Standard
The ManualActivation also accepts a tcreq.pdb from the command line.
\end_layout

\begin_layout Section
Using a third server to control licenses
\end_layout

\begin_layout Standard
Suppose that you release your signed application to the customer and he
 starts spreading the application to other people.
 We created a way to allow a company to control which costumers will use
 the activation vm.
\end_layout

\begin_layout Standard
You can instruct the vm to call a custom webservice created by yourself.
 This webservice will process the login/password to allow or deny the activation
, and then will call our webservice which will return data to the application
 running at the device.
\end_layout

\begin_layout Standard
Follow these steps:
\end_layout

\begin_layout Enumerate
Download the webservice sample at: http://www.totalcross.com/activation/Activation
_sample.rar 
\end_layout

\begin_layout Enumerate
In the folder “Sample Webservice” there's a class named ActivationService,
 which is an Axis webservice created in Java (like the sample in this companion)
, but which also uses TotalCross classes 
\end_layout

\begin_deeper
\begin_layout Itemize
You can host the webservice in any kind of server, such as Tomcat, .NET and
 Ruby.
\end_layout

\end_deeper
\begin_layout Enumerate
In the folder "Sample Application", there's a sample application named Activatio
nTest.
 Change the Settings.activationServerURI field (at your application's static
 initializer!) to point to your webservice, and make the deploy using the
 build_sdk.bat (demo version) or build_vms.bat (release version).
 In build_vms.bat, change the KEY to your activation key.
 Execute the application to see the results.
 
\end_layout

\begin_layout Enumerate
You can change the file activation.html as you wish, but the property 'name'
 of the confirmation button must be 'SubmitActivation'.
\end_layout

\begin_layout Enumerate
From your webservice, you can check the data that was received and you may
 return an error message to interrupt the activation.
\begin_inset Newline newline
\end_inset

So, this is a resume of what you have to do in your application:
\end_layout

\begin_deeper
\begin_layout Itemize
Specify the address of the webservice using Settings.activationServerURI
 (and optionally also the namespace using Settings.activationServerNamespace).
 This must be done inside the static initializer of your MainWindow class.
\end_layout

\begin_layout Itemize
Optionally, if you want to create a custom screen to show at startup, follow
 the instructions described previously.
\end_layout

\begin_layout Itemize
Note that its impossible to run any code from your application before the
 activation.
 The only possible way to show a custom screen is from the html.
\end_layout

\begin_layout Itemize
Your webservice must obey the given interface:
\begin_inset Newline newline
\end_inset


\family typewriter
public static String[] activate(String request, String[] keys, String[]
 values) throws Exception
\end_layout

\begin_deeper
\begin_layout Itemize
The request parameter cannot be changed and must be passed to our webservice.
\end_layout

\begin_layout Itemize
The keys and values contains some basic informations used by the activation,
 such as the device model, the serial number, the IMEI, and also any other
 parameters defined in the html.
\end_layout

\begin_layout Standard
After you apply your own logic to confirm if this is a valid user (like
 checking the login and password), you must connect to our webservice, sending
 the request string as parameter.
\end_layout

\begin_layout Standard
The return of this method must be:
\end_layout

\begin_layout Itemize
if error: an array with a single element with the error message that will
 be displayed to the user (like new 
\family typewriter
String[]{“Invalid password
\begin_inset Quotes erd
\end_inset

}
\family default
).
\end_layout

\begin_layout Itemize
If success: a two dimension array, where the first element is a message
 that will be displayed to the user, and the second element is the answer
 received from our server.
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
Attention: the activation server that this webservice uses is our production
 server, so, one credit will be consumed each time that the activation succeeds
 in a computer that was never activated.
 In other words, be aware that your tests will consume a license.
\end_layout

\begin_layout Chapter
SuperWaba to TotalCross conversion
\end_layout

\begin_layout Standard
In order to make the conversion easier, we created a program, 
\family typewriter
tc.tools.SW2TC
\family default
 (included in tc.jar), which recursively reads a set of folders and change
 the names of the old SuperWaba packages, classes and methods, to the new
 ones.
\end_layout

\begin_layout Standard
This program does not create a backup, it simply overwrites the original
 files, so you should backup your files before running the program.
\end_layout

\begin_layout Standard
This converter takes care of about 99% of the problems, remaining only 1%
 for you to manually update.
 Also, the program is just a token replacer, therefore, it cannot find that
 in "xxx.yyy", xxx is a ListBox nor a hotdog, so it cannot replace tokens
 based on the type.
 Always refer to this table, where we summarize the package, class and method
 changes.
\end_layout

\begin_layout Section
General Tips
\end_layout

\begin_layout Standard
Some important tips to finish the conversion after running the SW2TC:
\end_layout

\begin_layout Itemize
SW2TC cannot change some method names, refer to the javadocs for the new
 name of these methods.
\end_layout

\begin_layout Itemize
The return type of some methods were changed, most of them used to return
 a boolean or int value to indicate success or failure and now return void.
 Errors handling is done with Exceptions.
\end_layout

\begin_layout Itemize
Many methods now throw checked Exceptions, which must be handled accordingly.
 In SuperWaba, there were almost no validation on the arguments passed to
 the methods; in TotalCross, nearly all methods perform argument validation,
 throwing the appropriate exception for each case (in the future, this will
 be extended to all arguments and methods).
 To easily display the exception to the user, you can use the static method
 
\family typewriter
MessageBox.showException
\family default
.
 Read the tip described in the next section.
\end_layout

\begin_layout Standard
ALWAYS handle the exceptions thrown.
 Ignoring exceptions or simply logging the error without handling the exception
 is just wrong.
 Also remember that unchecked exceptions are usually caused by bad programming
 and are not supposed to be caught, unless you're using an unchecked exception
 instead of testing a condition.
\end_layout

\begin_layout Standard
E.g., instead of:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}[label=samplecode,caption=A sample]
\end_layout

\begin_layout Plain Layout

int sum = 0;
\end_layout

\begin_layout Plain Layout

for (int i = 0 ; i < values.length ; i++)
\end_layout

\begin_layout Plain Layout

	sum += values[i];
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
You may use:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}[label=samplecode,caption=A sample]
\end_layout

\begin_layout Plain Layout

int sum = 0;
\end_layout

\begin_layout Plain Layout

try
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	for (int = 0 ; ; i++)
\end_layout

\begin_layout Plain Layout

		sum+= values[i];
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

catch (ArrayIndexOutOfBoundsException e)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	// do nothing, it only means we finished reading the array.
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Please notice we are not discussing the performance of each approach, just
 showing an example.
\end_layout

\begin_layout Itemize
Some packages and classes were removed or changed, like the DateRGF package
 and the IntVector(DataStream) method.
 Most of them can be easily replaced by other classes or methods on TotalCross.
 But if needed, you may grab their code from SuperWaba, convert to TotalCross
 and add to your project.
 
\end_layout

\begin_layout Itemize
Color is now an int, in the format 0xRRGGBB.
 Change all Color to int.
 Instead of comparing or initializing the color to null, use -1.
\end_layout

\begin_layout Standard
Instead of:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}[label=samplecode,caption=A sample]
\end_layout

\begin_layout Plain Layout

Color c1 = ...;
\end_layout

\begin_layout Plain Layout

Color c2 = c1.brighter();
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Use:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}[label=samplecode,caption=A sample]
\end_layout

\begin_layout Plain Layout

int c1 = ...;
\end_layout

\begin_layout Plain Layout

int c2 = Color.brighter(c1);
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
The PIMAL API is not available on the version 1.0, but it will be completely
 revised, fixed, and placed back in a future version.
 
\end_layout

\begin_layout Itemize
The method isOpen was removed from all streams.
 Their constructors now throw an IOException (or a subclass of it, like
 FileNotFoundException) if the operation fails.
\end_layout

\begin_layout Itemize
In SuperWaba some classes had a lastError field that had a platform dependent
 error code; in TotalCross this field no longer exists, the exception message
 contains a platform dependent error message identifying the error.
 This error message is provided by the underlying OS and may not be as helpful
 as expected, but it's still better than an error value.
 If the OS is unable to find a given error code on its error table, the
 exception message will have only the error code.
\end_layout

\begin_layout Itemize
The methods onStart and onAdd were respectively renamed to initUI and onAddAgain.
 The SW2TC should perform these changes, but if the screen appears blank
 for some reason, check if the method onStart was not renamed.
\end_layout

\begin_layout Itemize
The WINDOW_MOVED event was removed.
 It was usually used to update the myg (my Graphics) object.
 Now the correct approach is to do a getGraphics in all places myg was used.
 
\end_layout

\begin_layout Itemize
Settings.onDevice is now called onJavaSE (Standard Edition), but notice it
 has the opposite meaning! Be sure to search for this field and make sure
 it is being used correctly.
 For instance:
\end_layout

\begin_layout Standard
if (Settings.onDevice) replaced for if(!Settings.onJavaSE)
\end_layout

\begin_layout Itemize
All classes that extend Container must explicitly set “focusTraversable
 = true“ in the constructor, otherwise the class will not be able to receive
 focus using the keyboard in penless devices.
 This flag defaults to true in SuperWaba, but to false in TotalCross.
 
\end_layout

\begin_layout Section
Correct way to handle Exceptions
\end_layout

\begin_layout Standard
I decided to write this to explain to programmers how to deal with exceptions.
 It does not apply only to TotalCross, but also to all other languages that
 make use of exceptions.
 One of the main differences between SuperWaba and TotalCross is the dispatch
 of exceptions by the API.
 Careless programmers tend to code this way:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

try
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	File f = new File(...);
\end_layout

\begin_layout Plain Layout

	...
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

catch (Exception e){}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In other words, just ignore the exception that is being thrown.
 A programmer that codes this way should be fired for carelessness.
 A variation of this approach is:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

try
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	...
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

catch (Exception e)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	Vm.debug("An exception was thrown");
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Here the programmer informs itself that the exception was thrown but completely
 ignores crucial informations that can help to resolve the problem.
 And he will see the exception only if he opens the DebugConsole.txt.
\end_layout

\begin_layout Standard
The second error is to handle exceptions in the same method it was thrown,
 like in this sample:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

class Report
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	File f;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	void createReport()
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		createFile();
\end_layout

\begin_layout Plain Layout

		runReport();
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	void createFile()
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

	try
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		f = new File("report.txt", File.CREATE_EMPTY);
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	catch (Exception e)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		e.printStackTrace();
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
What's the problem here? Simple: the createReport method is unable to confirm
 that the file was created or failed.
 
\end_layout

\begin_layout Standard
So, what's the correct way? The correct implementation is always throw the
 exception to the caller, and this to its caller, and so on, until you reach
 a root method that cannot pass the exception along, like the initUI and
 onEvent methods (since these methods are overriden and you cannot change
 the method's signature).
\end_layout

\begin_layout Standard
Therefore, the correct implementation is:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

class Report
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	File f;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	void createReport() throws IOException
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		createFile();
\end_layout

\begin_layout Plain Layout

		runReport();
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	void createFile() throws IOException
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		f = new File("report.txt", File.CREATE_EMPTY);
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Implementing this way, in the root method, we would do:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

try 
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	createReport();
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\begin_layout Plain Layout

catch (Exception e)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	MessageBox.showException(e,true);
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Note that this approach is not yet perfect, because the createFile method
 is throwing Exception, while "new File" throws three exceptions: IllegalArgumen
tIOException, FileNotFoundException and IOException.
 Hence, the correct is that each exception be declared on its own in the
 throws clause of the method, and that your program handle them in the correct
 way.
 For example, IllegalArgumentIOException occurs most times by a coding error
 and should never occur in production code.
 However, there may exist some exceptions that are less serious than others
 and can be ignored or handled locally, letting others to be passed along
 to the caller.
 Under situations that the handling is the same for all exceptions, is ok
 to catch them in a single "catch (Exception e)" block.
 
\end_layout

\begin_layout Standard
Finally, what's the correct way to handle the exception? The most common
 is call e.printStackTrace().
 This is a classic and BAD coding, because the stack trace is logged in
 the debug console (same output of Vm.debug), and thus the programmer will
 NOT know that the exception was thrown unless he exits the program and
 looks at the output file (note that in Eclipse or any other IDE the printStackT
race shows up in the console panel, not in the file).
 The ideal is that the exceptions are informed in real time, even if this
 can cause some bad impressions in your costumer.
 
\end_layout

\begin_layout Standard
TotalCross has a method in the MessageBox class that shows the exception
 in a dialog.
 Its format is shown in the previous example:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

try
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	...
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

catch (Exception e)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	totalcross.ui.dialog.MessageBox.showException(e,true);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The first parameter is the exception itself, and the second parameter indicates
 if printStackTrace should be called.
 This method shows the stack trace on screen, along with the exception's
 class name and a description message, if any.
 You can change the title through the MessageBox.showExceptionTitle member.
\end_layout

\begin_layout Standard
The use of exceptions is one of the most powerful features of Java, and
 can greatly simplify finding errors, if it is used correctly.
\end_layout

\begin_layout Part
USER INTERFACE
\end_layout

\begin_layout Chapterstar
Overview
\end_layout

\begin_layout Standard
The following chapters will introduce you to the main aspects of user interface
 in TotalCross, including graphical interface controls and events support.
\end_layout

\begin_layout Chapter
User Interface styles
\end_layout

\begin_layout Section
List of types
\end_layout

\begin_layout Standard
TotalCross has five look-and-feel types of user interfaces:
\end_layout

\begin_layout Itemize
WinCE – Defines a Windows CE user interface style.
 This is the default look-and-feel.
 People that use Microsoft Windows may feel better with it.
 
\end_layout

\begin_layout Itemize
PalmOS – Defines a Palm OS user interface style.
 The controls are flat with round borders.
 Unlike the other styles, the default background color is white instead
 of blue.
\end_layout

\begin_layout Itemize
Flat – Defines a FLAT user interface style that looks like the Pocket PC
 look-and-feel.
 It's basically the WinCE style with flat controls.
\end_layout

\begin_layout Itemize
Vista – Defines a Windows Vista user interface style.
 It's like the Flat style with a shaded background.
 It looks better on 16bpp+.
\end_layout

\begin_layout Itemize
Android – Defines an Android user interface style.
 Its like the Vista but with round borders.
 Its almost identical to the controls used by the Android platform.
\end_layout

\begin_layout Standard
The style can be switched to by using 
\family typewriter
MainWindow.setUIStyle(int type)
\family default
, and it is platform-idenpendent (can be used in any device of any platform).
 Here is an example of use:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public class Foo extends MainWindow
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	public Foo()
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		super("Hi bar", TAB_ONLY_BORDER);
\end_layout

\begin_layout Plain Layout

		totalcross.ui.MainWindow.setUIStyle(totalcross.sys.Settings.Android);
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The decision of which user interface to use must be made in the MainWindow's
 constructor.
 If nothing is changed, Windows CE with a blue background is used.
 Changing the user interface outside the MainWindow's constructor can crash
 your application.
 If you try to change it more than once, a RuntimeException will be thrown.
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
In the pictures below you can see snapshots of the UIGadgets sample running
 on JDK using different resolutions and user interface styles.
 Before each picture you'll find the command line options provided to the
 Launcher on each case:
\end_layout

\begin_layout Standard
\align center

\size small
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="2">
<features tabularvalignment="middle" tabularwidth="100col%">
<column alignment="center" valignment="top" width="50col%">
<column alignment="center" valignment="top" width="50col%">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Graphics
	filename companion_resources/images/companion_UIGadgets_Android.png
	width 40col%

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Graphics
	filename companion_resources/images/companion_UIGadgets_iPhone.png
	width 40col%

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\align left

\size small
/scr
\begin_inset space ~
\end_inset

android
\begin_inset space ~
\end_inset

/uiStyle
\begin_inset space ~
\end_inset

android
\begin_inset space ~
\end_inset

:
\begin_inset space ~
\end_inset

Android
\begin_inset space ~
\end_inset

(320x480x16)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
/scr
\begin_inset space ~
\end_inset

iPhone
\begin_inset space ~
\end_inset

:
\begin_inset space ~
\end_inset

iPhone
\begin_inset space ~
\end_inset

(320x480x24)
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\align center

\size small
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="2">
<features tabularvalignment="middle" tabularwidth="100col%">
<column alignment="center" valignment="top" width="50col%">
<column alignment="center" valignment="top" width="50col%">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Graphics
	filename companion_resources/images/companion_UIGadgets_WinCE.png
	width 40col%

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Graphics
	filename companion_resources/images/companion_UIGadgets_Win32.png
	width 40col%

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
/scr
\begin_inset space ~
\end_inset

WinCE
\begin_inset space ~
\end_inset

:
\begin_inset space ~
\end_inset

Windows
\begin_inset space ~
\end_inset

CE
\begin_inset space ~
\end_inset

(240x320x16)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
/scr
\begin_inset space ~
\end_inset

Win32
\begin_inset space ~
\end_inset

:
\begin_inset space ~
\end_inset

Windows
\begin_inset space ~
\end_inset

32
\begin_inset space ~
\end_inset

(240x320x24)
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Standard
\align center

\size small
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Graphics
	filename companion_resources/images/companion_UIGadgets_PalmTall.png
	scale 82

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
/scr
\begin_inset space ~
\end_inset

PalmTall
\begin_inset space ~
\end_inset

:
\begin_inset space ~
\end_inset

Palm
\begin_inset space ~
\end_inset

OS
\begin_inset space ~
\end_inset

tall
\begin_inset space ~
\end_inset

(320x480x16)
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\align center

\size small
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Graphics
	filename companion_resources/images/companion_UIGadgets_PalmWide.png
	scale 82

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
/scr
\begin_inset space ~
\end_inset

PalmWide
\begin_inset space ~
\end_inset

:
\begin_inset space ~
\end_inset

Palm
\begin_inset space ~
\end_inset

OS
\begin_inset space ~
\end_inset

wide
\begin_inset space ~
\end_inset

(480x320x16)
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Standard
\align center

\size small
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Graphics
	filename companion_resources/images/companion_UIGadgets_bbLo.png
	scale 82

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
/scr
\begin_inset space ~
\end_inset

bbLo
\begin_inset space ~
\end_inset

:
\begin_inset space ~
\end_inset

BlackBerry
\begin_inset space ~
\end_inset

low
\begin_inset space ~
\end_inset

(320x240x16)
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\align center

\size small
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Graphics
	filename companion_resources/images/companion_UIGadgets_bbBold.png
	scale 82

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
/scr
\begin_inset space ~
\end_inset

bbBold
\begin_inset space ~
\end_inset

:
\begin_inset space ~
\end_inset

BlackBerry
\begin_inset space ~
\end_inset

Bold
\begin_inset space ~
\end_inset

(480x360x16)
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\align center

\size small
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Graphics
	filename companion_resources/images/companion_UIGadgets_bbStorm.png
	scale 82

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
/scr
\begin_inset space ~
\end_inset

bbStorm
\begin_inset space ~
\end_inset

:
\begin_inset space ~
\end_inset

BlackBerry
\begin_inset space ~
\end_inset

Storm
\begin_inset space ~
\end_inset

(480x320x16)
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\size default

\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Standard
\align center

\size small
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="2">
<features tabularvalignment="middle" tabularwidth="100col%">
<column alignment="center" valignment="top" width="50col%">
<column alignment="center" valignment="top" width="50col%">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Graphics
	filename companion_resources/images/companion_UIGadgets_uiStyleWinCE.png
	width 40col%

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Graphics
	filename companion_resources/images/companion_UIGadgets_uiStylePalmOS.png
	width 40col%

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
/uiStyle WinCE : Windows CE
\begin_inset Newline newline
\end_inset

(default style on JDK)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
/uiStyle PalmOS : Palm OS user interface style
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\align center

\size small
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="2">
<features tabularvalignment="middle" tabularwidth="100col%">
<column alignment="center" valignment="top" width="50col%">
<column alignment="center" valignment="top" width="50col%">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Graphics
	filename companion_resources/images/companion_UIGadgets_uiStyleFlat.png
	width 40col%

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Graphics
	filename companion_resources/images/companion_UIGadgets_uiStyleVista.png
	width 40col%

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
/uiStyle Flat : Flat user interface style
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
/uiStyle Vista : Vista user interface style
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\align center

\size small
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Graphics
	filename companion_resources/images/companion_UIGadgets_bbStorm.png
	scale 60

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
/penlessDevice : Acts as a device without touch screen.
 (notice the highlighted control)
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section
Support for devices without pen
\end_layout

\begin_layout Standard
The iPhone and Android platforms introduced the use of finger instead of
 pen (however, some new Android works better with pens than with finger).
 A finger is much less precise than a pen, thus an algorithm is used to
 locate the closest control.
 These platforms also introduced the concept of drag and flick: drag means
 that you placed your finger in the screen and moved it while pressed, and
 flick means that you suddenly lifted the finger, to continue the scroll
 even while your finger is up.
 The scroll then slows down until a complete stop or if you press the finger
 again.
\end_layout

\begin_layout Standard
TotalCross 1.3 added support for this, activated when you set the user interface
 style to Android or when making 
\family typewriter
Settings.fingerTouch = true
\family default
.
 
\end_layout

\begin_layout Standard
The following controls supports flicking: ButtonMenu, Grid, ListBox, ListContain
er, MultiEdit, ScrollContainer (and its subclasses), TabbedContainer, Tree.
\end_layout

\begin_layout Standard
When fingerTouch is true, controls that can be flicked replace the ScrollBar
 by a ScrollPosition control, which only appears while the control is being
 scrolled or flicked.
\end_layout

\begin_layout Chapter
Font Support
\end_layout

\begin_layout Standard
To keep the user interface consistent across different platforms, TotalCross
 applications uses its own font types instead of using the device's font
 type.
 The basic font type chosen for TotalCross is the Tahoma font, included
 on the SDK as the TCFont.tcz file.
 It contains fonts ranging from size 7 to 44, regular and bold.
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
Unicode fonts are not included in the default font file!
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The base size of the application's font is defined as 
\family typewriter
Font.NORMAL_SIZE
\family default
, which is a constant initialized at runtime based on the screen resolution.
 This way you may select another size by using a relative value, like 
\family typewriter
Font.NORMAL_SIZE+2
\family default
, and the font will be correctly scaled among different resolutions.
\end_layout

\begin_layout Standard
To create your own font files you may use the FontGenerator (included in
 the tc.jar).
 It creates a compressed file with your own set of bitmap fonts, and supports
 anti-aliased fonts, which makes the font appear rounded and improves legibility.
\end_layout

\begin_layout Standard
Some usage examples (here we assume the tc.jar is in the classpath):
\end_layout

\begin_layout Itemize
Anti-aliased Arial font:
\end_layout

\begin_deeper
\begin_layout Standard

\family typewriter
java tc.tools.FontGenerator Arial /aa
\end_layout

\end_deeper
\begin_layout Itemize
Anti-aliased Arial font, but including only the sizes 12 and 14.
 Reducing the final font file from 158kb to 16kb:
\end_layout

\begin_deeper
\begin_layout Standard

\family typewriter
java tc.tools.FontGenerator Arial /sizes:12,14 /aa /rename:TCFont
\end_layout

\end_deeper
\begin_layout Itemize
Anti-aliased Arial font with Unicode characters up to 1279, but including
 only sizes 20, 24 and 28, and excluding bold fonts:
\end_layout

\begin_deeper
\begin_layout Standard

\family typewriter
java tc.tools.FontGenerator Arial /aa /sizes:20,24,28 /nobold
\begin_inset Newline newline
\end_inset

/rename:TCFont /u 32-255 256-383 402-402 1024-1279
\end_layout

\end_deeper
\begin_layout Standard
Starting in version 1.3, we changed the font engine to generate better fonts.
 To keep compatibility with old programs, we have two font sets: TCFont
 and TCFontOld.
 By default, it will use the old font set.
 To use the new font set, you must add to your program: 
\end_layout

\begin_layout Standard

\family typewriter
static {Settings.useNewFont = true;}
\end_layout

\begin_layout Standard
If you don't set this, a warning will be issued in the output window when
 running the application at desktop.
 Migrate to the new font as soon as possible.
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
The TotalCross installation packages contains both fonts, thus, increasing
 the size by 500k.
 If you create a single package with the /p parameter of the deployer, it
 will detect the font type and will add only the one you plan to use.
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
The MainWindow class
\end_layout

\begin_layout Standard
Every TotalCross program must have one and only one class that extends 
\family typewriter
totalcross.ui.MainWindow
\family default
.
 It is the interface between the VM and the TotalCross program: it receives
 all events and dispatches them.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

import totalcross.ui.*;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

public class Foo extends MainWindow
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	public Foo()
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		super("Hi handheld world", HORIZONTAL_GRADIENT);
\end_layout

\begin_layout Plain Layout

		gradientTitleStartColor = Color.getRGB(88, 130, 239);
\end_layout

\begin_layout Plain Layout

		gradientTitleEndColor = Color.getRGB(10, 36, 106);
\end_layout

\begin_layout Plain Layout

		titleColor = Color.WHITE;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	public void initUI()
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		// add controls here
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	public void onExit()
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		// close stuff, here
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The VM first calls the MainWindow default constructor (in this case, the
 
\family typewriter
Foo()
\family default
) and after that it enqueues a timer event, which will then call the 
\family typewriter
initUI
\family default
 method (inherited from the class Container).
 You 
\emph on
must
\emph default
 initialize all the user interface in the 
\family typewriter
initUI
\family default
 method.
 Initializing the user interface on the constructor might crash the application,
 and some operations can only be performed after the MainWindow's 
\family typewriter
initUI
\family default
 method is reached.
\end_layout

\begin_layout Standard
The 
\family typewriter
onExit
\family default
 method is called when the VM exits under normal circumstances , i.e., if
 the user closes the application or the programmer ends the application
 by using 
\family typewriter
exit
\family default
 or 
\family typewriter
exec
\family default
, or even when the application is halted by an unhandled exception.
 However, under abnormal circumstances where a fatal error occurs, reseting
 the pda, the 
\family typewriter
onExit
\family default
 method is not called.
\end_layout

\begin_layout Standard
To change the font used by all controls created, you must call the method
 
\family typewriter
setDefaultFont
\family default
 on the 
\emph on
first line
\emph default
 of the MainWindow's constructor.
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
If you're going to set the MainWindow's title and/or style, you should use
 
\family typewriter
super(title, style)
\family default
 instead of the methods 
\family typewriter
setTitle
\family default
 and 
\family typewriter
setBorderStyle
\family default
 to improve performance.
 However, you can't use 
\family typewriter
super
\family default
 and 
\family typewriter
setDefaultFont
\family default
 together because both must be the on first line of the constructor.
 That means you'll have to use 
\family typewriter
setTitle
\family default
 and 
\family typewriter
setBorderStyle
\family default
 instead of 
\family typewriter
super(title, style)
\family default
 to be able to use 
\family typewriter
setDefaultFont
\family default
.
\end_layout

\end_inset


\end_layout

\begin_layout Section
Useful mehtods
\end_layout

\begin_layout Itemize

\family typewriter
exit(int exitCode)
\family default
: exits the program, calling 
\family typewriter
onExit
\family default
 before.
 In Android, you can exit softly by using 
\family typewriter
SOFT
\family default
_
\family typewriter
EXIT
\family default
 as the exit code.
\end_layout

\begin_layout Itemize

\family typewriter
addTimer(Control target, int millis)
\family default
: adds a timer.
 The Timer event will be issued to the 
\family typewriter
target
\family default
 every 
\family typewriter
millis
\family default
 milliseconds.
\end_layout

\begin_layout Itemize

\family typewriter
removeTimer(Timer timer)
\family default
: removes the given 
\family typewriter
timer
\family default
 from the timers queue.
\end_layout

\begin_layout Itemize

\family typewriter
getCommandLine()
\family default
: if this process was executed by another process (e.g.: using the 
\family typewriter
totalcross.sys.Vm.exec
\family default
 method), this method gets the command line passed.
 
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
When you click on the application's icon, there’s no command line.
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize

\family typewriter
getMainWindow()
\family default
: returns the instance of the current MainWindow.
 You can use it to get access to methods of the MainWindow class from outside
 the class.
 Is it also possible to cast the returned class to the class that is extending
 MainWindow (this is a normal Java behavior).
 So, if UiGadgets is running, it is correct to do:
\end_layout

\begin_deeper
\begin_layout Standard

\family typewriter
UIGadgets instance = (UIGadgets) MainWindow.getMainWindow();
\end_layout

\end_deeper
\begin_layout Itemize

\family typewriter
getScreenShot()
\family default
: returns an image with the screenshot of the application.
\end_layout

\begin_layout Section
The Android lifecycle
\end_layout

\begin_layout Standard
The Android on TotalCross has a predefined life cycle, handled by methods
 defined in MainWindow:
\end_layout

\begin_layout Enumerate

\family typewriter
onStart
\family default
: called when the application starts
\end_layout

\begin_layout Enumerate

\family typewriter
onPause
\family default
: called when the user press the home key, or when a call is received, or
 when the screen turns off
\end_layout

\begin_layout Enumerate

\family typewriter
onResume
\family default
: called after the call ends or the screen is turned on again, or the program
 was exit softly
\end_layout

\begin_layout Enumerate

\family typewriter
onExit
\family default
: called when the system decides that is time to finish the application.
 If the home key was pressed, this method is called when another application
 is launched.
\end_layout

\begin_layout Standard
If the user press the home key and then forces the application to stop (by
 going to the Settings / Applications), then all Litebase tables may be
 corrupted (actually, no data is lost, but a 
\family typewriter
TableNotClosedException
\family default
 will be issued).
 So, its a good thing to call 
\family typewriter
LitebaseConnection.closeAll
\family default
 in your Litebase instances in the onPause method and recover them in the
 onResume method.
\end_layout

\begin_layout Chapter
Adding Controls
\end_layout

\begin_layout Standard
The class 
\family typewriter
totalcross.ui.Control
\family default
 is the base class of all user interface controls, like buttons and labels.
\end_layout

\begin_layout Standard
Controls must be added to a Container or one of its subclasses, like MainWindow.
 This container is referred as the parent of the control.
 To set the control bounds in the container, you can use the method 
\family typewriter
setRect(x,y,width,height)
\family default
.
\end_layout

\begin_layout Section
Relative positioning
\end_layout

\begin_layout Standard
TotalCross lets you place controls in two ways:
\end_layout

\begin_layout Standard
The hard and 
\emph on
wrong
\emph default
 way, by setting the control bounds with numbers.
 
\begin_inset Newline newline
\end_inset

E.g.: 
\family typewriter
control.setRect(10,10,80,12);
\end_layout

\begin_layout Standard
The smart way, by using constants for relative coordinates.
 The idea of the relative positioning is to let the programmer concentrate
 mainly on the position and let the sizes be computed automatically.
 The constants are:
\end_layout

\begin_layout Itemize
Coordinate X
\end_layout

\begin_deeper
\begin_layout Description
LEFT: place the control at the position 0 horizontal.
 If the parent is a Window, align the control at the left of the window’s
 client rect.
\end_layout

\begin_layout Description
RIGHT: align the control at the right.
 If the parent is a Window, align the control at the right of the window’s
 client rect (relative to the screen).
\end_layout

\begin_layout Description
RIGHT_OF: align the control at the right of the last control (relative to
 a control)
\end_layout

\begin_layout Description
CENTER: center horizontally the control in the container (relative to the
 screen).
\end_layout

\begin_layout Description
CENTER_OF: center horizontally based on the last control's width (relative
 to a control).
\end_layout

\begin_layout Description
BEFORE: place the control before the last control added.
\end_layout

\begin_layout Description
AFTER: place the control after the last control added.
\end_layout

\begin_layout Description
SAME: place the control at the same x coordinate of the last control added.
\end_layout

\begin_layout Description
KEEP: keep the last position used.
 To be used with WILL_RESIZE
\end_layout

\end_deeper
\begin_layout Itemize
Coordinate Y
\end_layout

\begin_deeper
\begin_layout Description
TOP: place the control at position 0 vertical.
 If the parent is a Window, align the control at the top of the window’s
 client rect.
\end_layout

\begin_layout Description
BOTTOM: place the control at the bottom of the container.
 If the parent is a Window, align the control at the bottom of the window’s
 client rect.
\end_layout

\begin_layout Description
CENTER: center vertically the control in the container.
\end_layout

\begin_layout Description
CENTER_OF: center vertically based on the last control's height.
\end_layout

\begin_layout Description
BEFORE: place the control before the last control added.
\end_layout

\begin_layout Description
AFTER: place the control after the last control added.
\end_layout

\begin_layout Description
SAME: place the control at the same y coordinate of the last control added.
\end_layout

\begin_layout Description
BOTTOM_OF: align the control at the bottom of the last control
\end_layout

\begin_layout Description
KEEP: keep the last position used.
 To be used with WILL_RESIZE
\end_layout

\end_deeper
\begin_layout Itemize
Width
\end_layout

\begin_deeper
\begin_layout Description
PREFERRED: lets the control determine its best width.
 This is normally computed using the control’s text width in the selected
 font.
\end_layout

\begin_layout Description
FILL: the control’s width will fill the space left until the end of the
 container.
 Cannot be used with RIGHT/CENTER.
\end_layout

\begin_layout Description
SAME: set the control's width with the same width of the last control added.
\end_layout

\begin_layout Description
FIT: set the control's width to fit between the specified x position and
 the last control added x position.
 For example, if you place a Label at LEFT, a Button at RIGHT and want to
 place an Edit between those two controls, use FIT as the control's width
 using the Label as relative control.
\end_layout

\begin_layout Description
SCREEN_SIZE: compute the width as a percentage of the screen's size (width).
 The percentage is passed as a number with + sign.
 E.G.: SCREEN_SIZE+20 will take the width as 20% of the screens size.
 Note that the size will change when the device is rotated.
\end_layout

\begin_layout Description
WILL_RESIZE: set that the width will be resized later, when all controls
 were added.
 You cannot use RIGHT or CENTER for placing controls when using WILL_RESIZE.
 After all items were added, call the 
\family typewriter
resizeWidth
\family default
 method.
\end_layout

\begin_layout Description
KEEP: keep the last position used.
 To be used with WILL_RESIZE
\end_layout

\end_deeper
\begin_layout Itemize
Height
\end_layout

\begin_deeper
\begin_layout Description
PREFERRED: lets the control determine its best height.
 This is normally computed using the control’s text height in the selected
 font.
\end_layout

\begin_layout Description
FILL: the control’s height will fill the space left until the end of the
 container.
 Cannot be used with BOTTOM/CENTER.
\end_layout

\begin_layout Description
SAME: set the control's height with the same height of the last control
 added.
\end_layout

\begin_layout Description
FIT: set the control's height to fit between the specified y position and
 the last control added y position.
 For example, if you place a Button at TOP, a Label at BOTTOM, and want
 to place a ListBox between both, use FIT as the control's height using
 the Button as relative control.
\end_layout

\begin_layout Description
SCREEN_SIZE: compute the height as a percentage of the screen's size (height).
\end_layout

\begin_layout Description
WILL_RESIZE: set that the height will be resized later, when all controls
 were added.
 You cannot use BOTTOM or CENTER for placing controls when using WILL_RESIZE.
 After all items were added, call the 
\family typewriter
resizeHeight
\family default
 method.
\end_layout

\begin_layout Description
KEEP: keep the last position used.
 To be used with WILL_RESIZE
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Itemize
Before calling setRect, the control must be added to the container and have
 its characteristics (like font, border type, etc) set.
 This is needed because the control position is computed based on its parent
 container and the control's size is computed based on its characteristics.
 And all this is computed at the setRect.
\end_layout

\begin_layout Itemize
The control's coordinates are always relative to its parent coordinates.
\end_layout

\begin_layout Itemize
If you use LEFT/TOP/RIGHT/BOTTOM with the first control added to a Window,
 it will use the coordinates of the Window’s client rect, which are the
 Container's area excluding the title and the borders, if any.
\end_layout

\begin_layout Itemize
You cannot use FIT in both width/height.
 It won't work as expected because you can't specify two controls to make
 it relative to.
 The width/height is always related to the last control added.
\end_layout

\begin_layout Itemize
See the sources for the controls ColorChooserBox, NumericBox and TimeBox
 to learn how to use WILL_RESIZE
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The use of relative positioning is 
\emph on
highly
\emph default
 recommended.
 It makes the program portable between different resolutions and fonts.
\end_layout

\begin_layout Section
Making UI adjustments
\end_layout

\begin_layout Standard
The constants described above have one important feature: a variable or
 a number can be used to increment/decrement the result value.
 Examples: CENTER+2, BOTTOM-5, PREFERRED+4, FILL+2, BEFORE-5.
 This value cannot be higher than 5, otherwise your interface will not be
 properly shown in other resolutions.
 Using something like LEFT+10 or BOTTOM-15 is as bad as using absolute values.
\end_layout

\begin_layout Standard
However, these values suffer a problem: a pixel's size may vary depending
 on the screen's density (also known as DPI).
 So, 4 may be good at a 240x320 screen, but too small in a 600x1024 tablet.
\end_layout

\begin_layout Standard
To bypass these limitations, we introduced a way to compute that adjustment
 based on the current's font size instead of a fixed pixel value.
 To enable it, you must set the following property at the application's
 static initializer:
\begin_inset Newline newline
\end_inset


\family typewriter
Settings.uiAdjustmentsBasedOnFontHeight = true;
\end_layout

\begin_layout Standard
After doing this, the adjustment you make will be a percentage of the font's
 height.
 So, AFTER+50 is AFTER+(50% of font's height), PREFERRED+20 is PREFERRED+(20%
 of font's height), and so on.
\end_layout

\begin_layout Standard
However, this feature is not supported by all controls.
 To disable this feature for a particular control the property 
\family typewriter
uiAdjustmentsBasedOnFontHeightIsSupported
\family default
 is set to false in the class constructor.
\end_layout

\begin_layout Standard
The controls can be traversed using the 5-way navigation present on most
 PDAs.
 and Smartphones.
 It is automatically activated on penless devices, but can be activated
 on pen devices by setting the property 
\family typewriter
Settings.keyboardFocusTraversable
\family default
 to 
\family typewriter
true
\family default
.
 Controls are traversed according to the order of elements in the field
 
\family typewriter
Container.tabOrder
\family default
.
 The controls are added to the vector in the order as they are added to
 the container.
 This may not be optimal; you may assign a new order by adding the controls
 to the vector:
\end_layout

\begin_layout Standard

\family typewriter
this.tabOrder = new Vector(new Object[]{ed1,btn1,btn2,ed2});
\end_layout

\begin_layout Section
Useful members
\end_layout

\begin_layout Itemize

\family typewriter
FontMetrics fm
\family default
: the FontMetrics object created from the control’s assigned Font.
 Always recreated when the font changes.
\end_layout

\begin_layout Itemize

\family typewriter
int appId
\family default
: a public variable that can be assigned by the application with any value.
 For example, the Keyboard class uses this to store the PushButtonGroup
 index and discover which one of the five had issued the event.
\end_layout

\begin_layout Itemize

\family typewriter
Object appObj
\family default
: same of appId, but its an Object instead of an int.
\end_layout

\begin_layout Itemize

\family typewriter
int clearValueInt
\family default
: value used to clear a control that uses an index as the active value.
 The default is: 0.
\end_layout

\begin_layout Itemize

\family typewriter
String clearValueStr
\family default
: value used to clear a control that uses a String as the active value.
 The default is an empty string: “”.
\end_layout

\begin_layout Itemize

\family typewriter
isHighlighting
\family default
: If true, the user is using the arrows to navigate across the controls.
 If false, the currently focused control is using the keys for its own purposes.
 If the device is penless and the control is lost, try setting this to true.
\end_layout

\begin_layout Itemize

\family typewriter
setRect(int x, int y, int width, int height)
\family default

\begin_inset Newline newline
\end_inset

sets the control bounds with the given parameters.
 If relative coordinates are used, they will be relative to the last added
 control.
\end_layout

\begin_layout Itemize

\family typewriter
setRect(Rect r)
\family default

\begin_inset Newline newline
\end_inset

same as 
\family typewriter
setRect(r.x, r.y, r.width, r.height)
\family default
.
\end_layout

\begin_layout Itemize

\family typewriter
setRect(int x, int y, int width, int height, Control relative)
\family default

\begin_inset Newline newline
\end_inset

same as first one, but coordinates will be relative to the given control
 instead of the last one added.
\end_layout

\begin_layout Itemize

\family typewriter
add(Control control, int x, int y)
\family default

\begin_inset Newline newline
\end_inset

same as:
\end_layout

\begin_deeper
\begin_layout Standard

\family typewriter
add(control);
\end_layout

\begin_layout Standard

\family typewriter
control.setRect(x, y, PREFERRED, PREFERRED);
\end_layout

\end_deeper
\begin_layout Itemize

\family typewriter
add(Control control, int x, int y, Control relative)
\family default

\begin_inset Newline newline
\end_inset

same as:
\end_layout

\begin_deeper
\begin_layout Standard

\family typewriter
add(control);
\end_layout

\begin_layout Standard

\family typewriter
control.setRect(x, y, PREFERRED, PREFERRED, relative);
\end_layout

\end_deeper
\begin_layout Itemize

\family typewriter
add(Control control, int x, int y, int width, int height)
\family default

\begin_inset Newline newline
\end_inset

same as:
\end_layout

\begin_deeper
\begin_layout Standard

\family typewriter
add(control);
\end_layout

\begin_layout Standard

\family typewriter
control.setRect(x, y, width, height);
\end_layout

\end_deeper
\begin_layout Itemize

\family typewriter
add(Control control, int x, int y, int width, int height, Control relative)
\family default

\begin_inset Newline newline
\end_inset

same as:
\end_layout

\begin_deeper
\begin_layout Standard

\family typewriter
add(control);
\end_layout

\begin_layout Standard

\family typewriter
control.setRect(x, y, width, height, relative);
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
The last four methods are useful when you’re adding controls that do not
 need to have any of its characteristics (like font or border) changed.
 Changing the control's characteristics 
\emph on
after
\emph default
 those methods will give you unpredictable results.
 This happens because the control does not reposition/resizes itself when
 you change its characteristics (just as an example, suppose that the default
 font has 11 in height, and you add the control; then you change the font
 to one with height 22; the control will not be resized and you'll see only
 half of the text).
\end_layout

\end_inset


\end_layout

\begin_layout Itemize

\family typewriter
addTimer(int millis)
\family default
: calls MainWindow addTimer method to add a timer whose target is this control.
\end_layout

\begin_layout Itemize

\family typewriter
removeTimer(Timer timer)
\family default
: calls MainWindow removeTimer to remove a timer associated with this control.
\end_layout

\begin_layout Itemize

\family typewriter
getX(), getY(), getWidth(), getHeight()
\family default
: returns the control’s bounds.
\end_layout

\begin_layout Itemize

\family typewriter
getParentWindow()
\family default
: returns the parent window of this control.
 This is needed because the control’s parent may be a Container, whose parent
 may be another container, and so on.
\end_layout

\begin_layout Itemize

\family typewriter
repaint()
\family default
: Marks the control for repaint.
 When you call repaint, the absolute area of the control regarding its parent
 Window is invalidated (marked for repaint); then, the next time an event
 (a keypress, a timer, a pen event) occurs, the screen is updated.
\end_layout

\begin_layout Itemize

\family typewriter
repaintNow()
\family default
: Redraws the control immediately.
 If this control is a Window, the whole window area is marked for repaint
 (useful if you're removing some controls from a container) .
\end_layout

\begin_layout Itemize

\family typewriter
setEnabled(boolean enabled)
\family default
: Enable/disable the control to receive events.
 The control’s appearance is also changed to reflect the state.
\end_layout

\begin_layout Itemize

\family typewriter
setFont(Font font)
\family default
: Sets the font for the control.
\end_layout

\begin_layout Itemize

\family typewriter
isDisplayed()
\family default
: return true if the parent of this Control is added somewhere.
 Some containers, like the TabPanel, have n child containers, but only one
 is added at a time.
 With this method, you can discover if your container is the one available.
\end_layout

\begin_layout Itemize

\family typewriter
requestFocus()
\family default
: set the focus to this control.
\end_layout

\begin_layout Itemize

\family typewriter
setFocusLess(boolean on)
\family default
: this method makes the current control a control that will never steal
 focus from other controls.
 It makes it very easy to create keypads with PushButtonGroup to enter character
s into Edit controls, for example.
 See the PhoneDialog sample to learn how to use it.
\end_layout

\begin_layout Itemize

\family typewriter
setBackColor(int back)
\family default
 and 
\family typewriter
getBackColor()
\family default
: get or set the background color for the control.
\end_layout

\begin_layout Itemize

\family typewriter
setForeColor(int fore)
\family default
 and 
\family typewriter
getForeColor()
\family default
: get or set the foreground color for the control.
\end_layout

\begin_layout Itemize

\family typewriter
setBackForeColors(int back, int fore)
\family default
: set background and foreground colors at once.
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
getForeColor() and getBackColor() returns the color depending if the control’s
 state is enabled or disabled.
\end_layout

\end_inset


\end_layout

\begin_layout Itemize

\family typewriter
clear()
\family default
: the clear method in this class is a placeholder for the other controls.
 It implements an easy way to clear all the controls in the screen.
 When you call the clear method of a Container or a Window, it recursively
 calls the clear method of all child controls.
 Each control will use clearValueInt or clearValueStr (both defined in this
 class) as the clear value, depending on the characteristics of the control.
 For example, a ListBox will use the clearValueInt to set it as the selected
 index, while an Edit will use the clearValueStr as the text inside.
 If you want to change the clear value, just assign a new value to one of
 these two fields.
\end_layout

\begin_layout Itemize

\family typewriter
setTextShadowColo(int color)
\family default
: sets that the control's text will have a shadow.
\end_layout

\begin_layout Itemize

\family typewriter
reposition()
\family default
: repositions the control after something was changed.
 This method is called by the VM to reposition all controls on screen when
 a rotation occurs.
\end_layout

\begin_layout Itemize

\family typewriter
setInsets(left,right,top,bottom)
\family default
: sets a gap between the control's text and its bounds.
\end_layout

\begin_layout Itemize

\family typewriter
onPaint(Graphics g)
\family default
: this is the method called when the control is going to be painted.
 You can use the given Graphics object to draw what you need on screen.
 The default's control font is already set, and the clipping is also set
 to the control's bounds.
\end_layout

\begin_layout Itemize

\family typewriter
onBoundsChanged
\family default
(): called after the user invoked the setRect method.
 Good to compute positions that are dependant on the bounds.
\end_layout

\begin_layout Itemize

\family typewriter
onColorsChanged(boolean colorsChanged)
\family default
: Called after a setEnabled, setForeColor and setBackColor methods were
 called and when a control has been added to a Container.
 If colorsChanged is true, it was called from setForeColor/setBackColor/Containe
r.add; otherwise, it was called from setEnabled
\end_layout

\begin_layout Itemize

\family typewriter
onWindowPaintFinished()
\family default
: every time the _doPaint finishes paintings all controls, this method is
 called.
 You can then do actions needed after the screen has finished the paint.
 Note that this method is only called on controls that extends Window and
 on the focused control.
\end_layout

\begin_layout Itemize

\family typewriter
onFontChanged()
\family default
: called after the setFont method is invoked.
\end_layout

\begin_layout Chapter
Events
\end_layout

\begin_layout Standard
Events represent all activity that goes on between the user and the application.
 When the user interacts with a program, the VM creates an event representing
 the action and communicates these actions to the programs using events.
\end_layout

\begin_layout Standard
This chapter is organized into the following sections to provide a quick
 start on event handling in TotalCross:
\end_layout

\begin_layout Description
Control
\begin_inset space ~
\end_inset

Events briefly explains the basic types of events handled by controls.
\end_layout

\begin_layout Description
Handling
\begin_inset space ~
\end_inset

Events explains the event-handling models available in TotalCross.
\end_layout

\begin_layout Description
The
\begin_inset space ~
\end_inset

Event
\begin_inset space ~
\end_inset

class describes this class in more detail.
\end_layout

\begin_layout Standard
If you're new to TotalCross and want to get things started quickly, skip
 the Delegation Event Model in section two – “Handling Events”.
\end_layout

\begin_layout Standard
If you're familiar with TotalCross and wants to know more about events,
 make sure you understand both event-handling models.
\end_layout

\begin_layout Section
Control Events
\end_layout

\begin_layout Standard
There are two basic types of events: pen events and key events.
 These events are handled by the Window, which creates a new event of the
 proper type (PenEvent or KeyEvent) and forwards it to the target control.
 These events are handled by the control, which may convert them to other
 events, defined on the class ControlEvent.
\end_layout

\begin_layout Standard
Below we can see how each event defined on ControlEvent is handled by each
 control:
\end_layout

\begin_layout Itemize
PRESSED: this event is posted by controls when they receive a PEN_DOWN (like
 Check, Radio, TabPanel), and a PEN_UP (Button, ListBox, PushButtonGroup,
 ScrollBar) or even a WINDOW_CLOSED (ComboBox).
\end_layout

\begin_layout Itemize
FOCUS_IN and FOCUS_OUT: posted by the window when a control different from
 the current one is clicked.
 The FOCUS_OUT is first posted to the old control, and the event FOCUS_IN
 is then posted to the new control.
\end_layout

\begin_layout Itemize
TIMER: this is a special event that is posted to the control that has a
 timer assigned to it; it is called when the timer countdown has reached
 zero.
 
\end_layout

\begin_layout Itemize
WINDOW_CLOSED: posted by the unpop method to notify all controls that a
 window has been closed.
 Some controls, like the ComboBox, has a PopList assigned to it; when the
 PopList issues a WINDOW_CLOSED event, the ComboBox receives it and converts
 to a PRESSED event.
\end_layout

\begin_layout Itemize
HIGHLIGHT_IN and HIGHLIGHT_OUT: these events are posted by the window when
 the user changes the focus to another control and the field Settings.keyboardFoc
usTraversable is set to true.
 The HIGHLIGHT_OUT event is first posted to the old control, and the event
 HIGHLIGHT_IN is then posted to the new control.3
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
The field Settings.keyboardFocusTraversable default value is true for penless
 devices and false for touchscreen devices.
 You may set it to true on touchscreen devices to allow navigation through
 arrow keys.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Unlike the other controls, the Grid control has its own set of event types
 defined on the GridEvent class:
\end_layout

\begin_layout Itemize
SELECTED_EVENT: generated when a new row is selected.
\end_layout

\begin_layout Itemize
CHECK_CHANGED_EVENT: if the grid has a check column, this event is generated
 when a grid row is checked or unchecked.
\end_layout

\begin_layout Itemize
TEXT_CHANGED_EVENT: generated when a cell of an editable column had its
 text changed.
\end_layout

\begin_layout Section
Event Handling
\end_layout

\begin_layout Standard
TotalCross implements two event-handling models.
\end_layout

\begin_layout Subsection
Inheritance Event Model
\end_layout

\begin_layout Standard
Similar to the Java 1.0 event model, this approach requires you to subclass
 UI components and override the event handling method – 
\family typewriter
onEvent(Event e)
\family default
 – in order to catch and process UI events.
 When a control posts an event (using the 
\family typewriter
postEvent
\family default
 method) it is propagated sequentially up the UI hierarchy until it is either
 consumed, or the root of the hierarchy is reached.
\end_layout

\begin_layout Standard
If we have a Button inside a TabPanel in a Window, and this button receives
 an event, the event is propagated up the hierarchy:
\end_layout

\begin_layout Standard
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset space \hspace*{}
\length 20col%
\end_inset

Window.onEvent
\end_layout

\begin_layout Plain Layout
\begin_inset space \hspace*{}
\length 29col%
\end_inset


\begin_inset Formula $\nwarrow$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset space \hspace*{}
\length 24col%
\end_inset

TabPanel.onEvent
\end_layout

\begin_layout Plain Layout
\begin_inset space \hspace*{}
\length 33col%
\end_inset


\begin_inset Formula $\nwarrow$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset space \hspace*{}
\length 28col%
\end_inset

Container.onEvent
\end_layout

\begin_layout Plain Layout
\begin_inset space \hspace*{}
\length 37col%
\end_inset


\begin_inset Formula $\nwarrow$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset space \hspace*{}
\length 34col%
\end_inset

Button.onEvent 
\begin_inset Formula $\Longleftarrow$
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
After handling the event, you can break the event propagation by setting
 the 
\family typewriter
Event.consumed
\family default
 field to true.
\end_layout

\begin_layout Standard
Here's a simple example:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public class MyProgram extends MainWindow
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	Button pushB;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	public void initUI()
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		add(pushB = new Button("Push me
\backslash
nPlease"), CENTER, TOP);
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	public void onEvent(Event event)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		switch (event.type)
\end_layout

\begin_layout Plain Layout

		{
\end_layout

\begin_layout Plain Layout

			case ControlEvent.PRESSED:
\end_layout

\begin_layout Plain Layout

				if (event.target == pushB)
\end_layout

\begin_layout Plain Layout

					//handle pushB being pressed
\end_layout

\begin_layout Plain Layout

			break;
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Itemize
Disabled controls can only post TIMER events.
 The method postEvent returns immediately if the control is not enabled
 and the type of the event received is not TIMER.
 The only exception to this occurs on fingertouch devices, to allow the
 flick stop or start when a PEN_DOWN occurs in a disabled control.
\end_layout

\begin_layout Itemize
The event propagation stops if the control is moved to another container.
 For example, when you pop up the Keyboard, the target Edit is removed from
 its parent and added to the Keyboard window; at this time, the event propagatio
n (of the KeyEvent) stops.
\end_layout

\begin_layout Itemize
The MainWindow does not receive an event posted by a control in a popup
 window.
 The only exception for this is the WINDOW_CLOSED, which is posted to the
 window that popped it.
\end_layout

\begin_layout Itemize
A control that is not added to a Container (or any parent of its Container
 is not added to a Window) will never receive events nor be repainted.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Small programs can handle the events by implementing the onEvent method
 in the MainWindow class, but it can become confusing if the program gets
 bigger.
 An alternative is to create classes that extend Container and swap them
 on the MainWindow as the user navigates through the program.
 Each class implementing the onEvent method will have to handle its own
 events.
\end_layout

\begin_layout Subsection
Delegation Event Model
\end_layout

\begin_layout Standard
Similar to the event model introduced by Java 1.1, this approach solves some
 limitations of the Inheritance Event Model, which are:
\end_layout

\begin_layout Itemize
To be able to handle events, a class must subclass Control and implement
 the onEvent method.
\end_layout

\begin_layout Itemize
Since all event types are filtered through the onEvent method, the method
 is executed whenever the control receives an event, regardless of its type.
 If a particular event type is ignored by the whole program, it will never
 be handled and consumed.
 Instead, it will keep going up on the hierarchy until it reaches the root,
 wasting resources in the process.
 The only way to avoid it – handling all event types, consuming events that
 are no handled anywhere on the program as soon as they are received – is
 discouraged and can lead to complex and error-prone code.
\end_layout

\begin_layout Itemize
Events are supposed to be handled only by the control that receives the
 event.
 Handling events received by a control in another class is a hard task.
 An example is the ToolTip control, which works by handling the pen events
 received by the control it refers to.
\end_layout

\begin_layout Standard
In this model, an event is propagated from a “Source” object to a “Listener”
 object by invoking a method on the listener.
 and passing in the instance of the event subclass, which defines the event
 type generated.
\end_layout

\begin_layout Standard
A Listener is an object that implements a specific EventListener interface.
 An EventListener interface defines one or more methods which are to be
 invoked by the event source in response to each specific event type handled
 by the interface.
\end_layout

\begin_layout Standard
An Event source is an object which originates events.
 The source defines the set of events it emits by providing a set of add<EventTy
pe>Listener(<EventType>Listener) methods which are used to register specific
 listeners for those events.
\end_layout

\begin_layout Standard
Here's the same example, using a EventListener instead of overriding onEvent:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public class MyProgram extends MainWindow
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	Button pushB;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	public void initUI()
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		add(pushB = new Button("Push me
\backslash
nPlease"), CENTER, TOP);
\end_layout

\begin_layout Plain Layout

		pushB.addPressListener(
\end_layout

\begin_layout Plain Layout

			new PressListener()
\end_layout

\begin_layout Plain Layout

			{
\end_layout

\begin_layout Plain Layout

				public void controlPressed(ControlEvent e)
\end_layout

\begin_layout Plain Layout

				{
\end_layout

\begin_layout Plain Layout

					//handle pushB being pressed
\end_layout

\begin_layout Plain Layout

				}
\end_layout

\begin_layout Plain Layout

			}
\end_layout

\begin_layout Plain Layout

		);
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
Creating listeners using the new <EventType>Listener, as indicated above,
 makes your program bigger and should be used with care.
 If you will add listeners of the same event type to many controls, implement
 the listener in the class like this:
\family typewriter

\begin_inset Newline newline
\end_inset

public class MyProgram extends MainWindow implements PressListener
\end_layout

\end_inset


\end_layout

\begin_layout Section
The Event class
\end_layout

\begin_layout Standard
Let's now look at the details of each Event class.
 As already described, TotalCross has four classes in the totalcross.ui package:
 ControlEvent, PenEvent, KeyEvent and their parent class, Event, which provides
 some useful members:
\end_layout

\begin_layout Itemize
type: this is the event number, used to detect which event was posted.
\end_layout

\begin_layout Itemize
target: this one informs who is receiving the event (E.g.: the VM posts a
 PenEvent.PEN_DOWN to a control) or who is posting it (E.g.: the Control posts
 an ControlEvent.PRESSED).
\end_layout

\begin_layout Itemize
timeStamp: contains the time stamp at which the event was created.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
Be careful with the timeStamp.
 There is no way to convert it to the current hh:mm:ss:millis.
 It is just useful for comparison purposes; or to compute the time elapsed
 since the last event occurred.
 You can use it to simulate a double-click, by checking the elapsed time
 between two clicks.
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
consumed: when set to true during the event propagation, breaks the propagation
 chain.
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
To keep memory usage low, some VM routines reuse PenEvents and KeyEvents
 objects; so, if you just save a reference to the object instead of the
 timestamp itself, you may get unexpected results.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The Event class also has a static method called getNextAvailableEventId.
 This method is used to avoid conflicts when your application or library
 creates a new Event type.
 It is discussed in more details in PART V of this book.
 
\end_layout

\begin_layout Standard
The PenEvent has three members: x,y and modifiers.
 The coordinates are stored in the x,y; the modifiers are not used in the
 PalmOS platform, only in the other platforms.
\end_layout

\begin_layout Standard
The KeyEvent has also two members: key and modifiers.
 The key can assume values from the ASCII table and special ones defined
 in the totalcross.sys.Specialkeys interface.
 The modifiers are used in all platforms.
\end_layout

\begin_layout Standard
Some of the Keys defined in totalcross.sys.SpecialKeys need a special code
 to be manipulated: they are not handled by the application unless the app
 requests it.
 For example, the totalcross.sys.SpecialKeys.UP and totalcross.sys.SpecialKeys.DOWN
 are automatically sent to the application's event queue, but the SpecialKeys.KEY
BOARD_* and SpecialKeys.HARD* not.
 To be able to intercept these keys, you must use the method Vm.interceptSpecialK
eys (mask).
 
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
The SpecialKeys interface does not have all possible keys mapped.
 If you have a particular device, you can learn the code of a key by creating
 a test application and calling Vm.showKeyCodes(boolean on).
 When this mode is on, each time a key is pressed, the vm shows an alert
 with the code.
 Then use this key code in the Vm.interceptSpecialKeys.
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
Basic Controls
\end_layout

\begin_layout Standard
In this chapter we will learn the details of all basic controls in the package
 totalcross.ui: Button, Edit, Label, Check, Radio, RadioGroupController,
 ComboBox, ListBox, MultiEdit, Grid and ToolTip.
\end_layout

\begin_layout Standard
Each control can have its font, foreground/background colors and state (enabled/
disabled) set.
 Their look depends on the look-and-feel set on the MainWindow constructor
 (WinCE is the default).
\end_layout

\begin_layout Standard
For each control we’ll see its characteristics, how to create them with
 the provided constructors, and how to handle their events.
\end_layout

\begin_layout Standard
You can see most of the user interface controls available in TotalCross
 looking at the UIGadgets and AndroidUI samples.
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
Remember you must set characteristics of controls before calling setRect/add
 to set their bounds.
\end_layout

\end_inset


\end_layout

\begin_layout Section
Button
\end_layout

\begin_layout Standard
Buttons are the most used types of controls.
 They are used to invoke an action or to confirm something, like [ok] or
 [cancel].
 Here are some characteristics of TotalCross buttons:
\end_layout

\begin_layout Itemize
It supports multi-lined text, mixed with images.
\end_layout

\begin_layout Itemize
It has five border styles:
\end_layout

\begin_deeper
\begin_layout Itemize
BORDER_NONE
\end_layout

\begin_layout Itemize
BORDER_SIMPLE
\end_layout

\begin_layout Itemize
BORDER_3D
\end_layout

\begin_layout Itemize
BORDER_3D_GRADIENT_VERTICAL_GRADIENT
\end_layout

\begin_layout Itemize
BORDER_3D_GRADIENT_HORIZONTAL_GRADIENT.
\end_layout

\end_deeper
\begin_layout Itemize
A button can be made sticky by setting the isSticky field.
\end_layout

\begin_layout Itemize
If you create an image button and add a text using the setText method, both
 of them will appear on the control.
\end_layout

\begin_layout Itemize
If the button has an Image, you can change the image that is displayed while
 the button is pressed by changing the pressedImage field.
\end_layout

\begin_layout Itemize
If you create an image for the button, make sure that its a PNG with alpha-chann
el (transparency).
\end_layout

\begin_layout Itemize
You can make a button fire more than one event while it is pressed changing
 the field autoRepeat.
\end_layout

\begin_layout Itemize
The method setImage and setText doesn't resize the button to fit the image.
\end_layout

\begin_layout Itemize
The clear method is ignored by the Button class.
\end_layout

\begin_layout Itemize
The class Button has the static field commonGap.
 It defines the internal gap between the Button content and its borders.
 Changing this value affects all buttons created after the new value was
 set – it does not affect buttons previously created.
 A good practice is to set the field for the desired value before you create
 the buttons (at the beginning of initUI for instance) and reset it back
 to zero after you finish (at the end of initUI).
\end_layout

\begin_layout Itemize
You can change the color used when the button is pressed (useful when the
 UI is in PalmOS style) using the setPressedColor method.
\end_layout

\begin_layout Itemize
You can simulate the button being pressed by calling the method press and
 passing true as parameter.
\end_layout

\begin_layout Standard
Sample code:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public void initUI()
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	Button btn1 = new Button("Clients", img, TOP, 1);
\end_layout

\begin_layout Plain Layout

	btn1.setBackColor(Color.WHITE);
\end_layout

\begin_layout Plain Layout

	add(btn1, LEFT+5, TOP+5);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	Button btn2 = new Button("Clients", img, BOTTOM, 1);
\end_layout

\begin_layout Plain Layout

	btn2.setBackColor(Color.WHITE);
\end_layout

\begin_layout Plain Layout

	add(btn2, AFTER+5, SAME);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	Button btn3 = new Button("Button disabled");
\end_layout

\begin_layout Plain Layout

	btn3.setEnabled(false);
\end_layout

\begin_layout Plain Layout

	add(btn3, LEFT+5, AFTER+5);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	Button btn4 = new Button("Button none border");
\end_layout

\begin_layout Plain Layout

	btn4.setBorder(Button.BORDER_NONE);
\end_layout

\begin_layout Plain Layout

	btn4.setForeColor(Color.RED);
\end_layout

\begin_layout Plain Layout

	btn4.setBackColor(Color.WHITE);
\end_layout

\begin_layout Plain Layout

	add(btn4, SAME, AFTER+5);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	Button btn5 = new Button("Button 3D Grad Border");
\end_layout

\begin_layout Plain Layout

	btn5.setBorder(Button.BORDER_3D_GRADIENT);
\end_layout

\begin_layout Plain Layout

	btn5.setBackColor(Color.WHITE);
\end_layout

\begin_layout Plain Layout

	add(btn5, SAME, AFTER+5);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	Button btn6 = new Button("Button 3D Grad Border");
\end_layout

\begin_layout Plain Layout

	btn6.setBorder(Button.BORDER_3D_GRADIENT);
\end_layout

\begin_layout Plain Layout

	btn6.setForeColor(Color.WHITE);
\end_layout

\begin_layout Plain Layout

	add(btn6, SAME, AFTER+5);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Every time a Button is pressed, it posts a ControlEvent.PRESSED event to
 the parent container.
 Below is an example of how to handle this event.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public void onEvent(Event event)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	switch (event.type)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		case ControlEvent.PRESSED:
\end_layout

\begin_layout Plain Layout

			if (event.target == btn1)
\end_layout

\begin_layout Plain Layout

				new MessageBox("HI", "Natasha").popup();
\end_layout

\begin_layout Plain Layout

		break;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
To just display images in the screen, use the ImageControl class instead
 of the Button.
\end_layout

\end_inset


\end_layout

\begin_layout Section
Edit
\end_layout

\begin_layout Standard
Edit is a control used to get text input when the user type using the keyboard
 or the grafitti area.
 It allows you to select text and cut/copy/paste it (refer to chapter 2
 for known limitations of this feature on iPhone).
 Here are some other features:
\end_layout

\begin_layout Itemize
There are two constructors: the default (with no arguments) that creates
 an Edit with no constraints, and one constructor that receives a mask string.
 The mask is used, primarily, to compute the preferred width.
 If mask is "", the width will be set to FILL.
 To be able to use the mask to format the input, you must call the setMode
 method passing true in the second argument.
\end_layout

\begin_layout Itemize
You can limit the maximum length of characters that can be entered, by using
 the setMaxLength method.
 If the user tries to enter text above the limit, a beep is sounded and
 the text is ignored.
 If you set a text greater than the max length, it will be truncated.
\end_layout

\begin_layout Itemize
You can also set the valid characters that can be entered by using the setValidC
hars method.
 There are some predefined character sets that can be localized if necessary:
\end_layout

\begin_deeper
\begin_layout Itemize
numbersSet = "0123456789"
\end_layout

\begin_layout Itemize
currencyCharsSet = "0123456789.+-"
\end_layout

\begin_layout Itemize
dateSet = numbersSet + Settings.dateSeparator
\end_layout

\end_deeper
\begin_layout Itemize
Those character sets are used in the setMode method that receives one of
 the following constants:
\end_layout

\begin_deeper
\begin_layout Itemize
NORMAL: in this mode any character can be entered.
 For Palm OS only, when pressing the abc/123 keys the totalcross.ui.KeyboardBox
 is popped up; on all other platforms, the default input method is used.
\end_layout

\begin_layout Itemize
DATE: this mode uses the dateSet and the totalcross.ui.CalendarBox is the
 one popped up.
\end_layout

\begin_layout Itemize
CURRENCY: the currencyCharsSet is used and the totalcross.ui.CalculatorBox
 is the one popped up.
 You can change the Calculator to a NumericBox by for a specific Edit by
 making setKeyboard(Edit.KBD_TIME); or for all Edits of the application,
 by doing Edit.useNumericBoxInsteadOfCalculator = true.
\end_layout

\begin_layout Itemize
PASSWORD: any character can be entered and the totalcross.ui.Keyboard is the
 one popped up.
 Only the last character typed is displayed in this mode, all the others
 are replaced by an asterisk (*).
\end_layout

\begin_layout Itemize
PASSWORD_ALL: same of PASSWORD except that all characters are replaced by
 an asterisk (*), including the last one.
\end_layout

\end_deeper
\begin_layout Itemize
There's another setMode method that besides the constants listed above,
 it also receives a boolean to make the edit use a mask on the input text
 instead of popping a window.
 It should be used with the constants DATE and CURRENCY.
\end_layout

\begin_layout Itemize
To retrieve the text shown as is, use getText.
 If mask is used, you can return the text without the mask using getTextWithoutM
ask.
 To set the text to another one, call setText.
\end_layout

\begin_layout Itemize
To return the length of a text without having to call getText, you can call
 getLength.
 To apply trimming in the String and return its length, call getTrimmedLength.
\end_layout

\begin_layout Itemize
The method setDecimalPlaces can be used with setMode(CURRENCY, true) to
 set the number of decimal places the mask will use.
 The default value is 2.
\end_layout

\begin_layout Itemize
The edit can be set as read-only using the method setEditable and setting
 it to false.
 You can also set the field hasCursorWhenNotEditable to false to make the
 blinking cursor not appear when this edit is not editable.
\end_layout

\begin_layout Itemize
There's a public member named overwrite which, if set to true, turns off
 insert mode (ie, characters will be replaced if written over).
\end_layout

\begin_layout Itemize
The member alignment, which can be set to LEFT, RIGHT or CENTER, lets you
 control the alignment of the text inside the edit after the control loses
 the focus.
 The text is always left-aligned when it has the focus.
 The only exception is when mode is set to CURRENCY, when the numbers will
 be typed using right-align.
\end_layout

\begin_layout Itemize
You can invoke the default popup keyboard for the edit using the popupKCC
 method (KCC = Keyboard, Calculator and Calendar).
\end_layout

\begin_layout Itemize
You may specify which keyboard will be popped up, overriding the default
 behavior, using the setKeyboard method, passing the constants KBD_NONE,
 KBD_DEFAULT, KBD_KEYBOARD, KBD_CALCULATOR, KBD_CALENDAR.
\end_layout

\begin_layout Itemize
You may force all characters entered to be automatically converted to upper
 or to lower case by setting the field capitalise with the constants ALL_UPPER
 or ALL_LOWER, the constant ALL_NORMAL disables this feature.
\end_layout

\begin_layout Itemize
The field autoSelect makes the edit automatically select the text when it
 receives the focus.
 This is always true for penless devices.
\end_layout

\begin_layout Itemize
The method setCursorPos(start, end) can be used to set the selected text
 of the edit (if start != end).
 It can be used to set the cursor position, if start equals end.
 Start must be less or equal to end, and both must be >= 0.
 It can also be used to clear the selectedText, calling setCursorPos(-1,0).
 Note: if you're setting the cursor position before the edit is drawn for
 the first time, the edit will not be scrolled if the end position goes
 beyond the limits.
 Important! No bound checking is made.
 Be sure to not call this method with invalid positions!
\end_layout

\begin_layout Itemize
The method getCursorPos returns an int array with the start (array index
 0) and end (array index 1) positions of the cursor.
 It can be used to find the selected text, which will be the substring(start,
 end).
\end_layout

\begin_layout Itemize
When a selection is made or when the user clicks and holds an Edit at the
 same point, a popup menu is shown so user can cut/copy/paste.
 You can disable this feature by calling Edit.clipboardDelay = -1.
\end_layout

\begin_layout Itemize
In the Android user interface style, you can change the color of the Edit
 that have focus using the focusColor field.
\end_layout

\begin_layout Itemize
You can remap a key to be used in the Edit (For example, remap F1 to 1,
 F2 to 2, etc) by calling the mapKeys method.
\end_layout

\begin_layout Itemize
The clear method uses clearValueStr to set the text of the edit.
\end_layout

\begin_layout Standard
Sample code:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public void initUI()
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	Edit ed1 = new Edit();
\end_layout

\begin_layout Plain Layout

	add(ed1, LEFT, TOP+5, FILL, PREFERRED);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	Edit ed2 = new Edit("9999999999999");
\end_layout

\begin_layout Plain Layout

	ed2.setDecimalPlaces(4);
\end_layout

\begin_layout Plain Layout

	ed2.setMode(Edit.CURRENCY,true);
\end_layout

\begin_layout Plain Layout

	add(ed2, RIGHT, AFTER+5);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	Edit ed3 = new Edit("99/99/9999");
\end_layout

\begin_layout Plain Layout

	ed3.setMode(Edit.DATE);
\end_layout

\begin_layout Plain Layout

	add(ed3, LEFT, SAME);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	Edit ed4 = new Edit("AAAAA");
\end_layout

\begin_layout Plain Layout

	ed4.setMode(Edit.PASSWORD);
\end_layout

\begin_layout Plain Layout

	add(ed4, LEFT, AFTER+5);
\end_layout

\begin_layout Plain Layout

	ed4.setText("pass");
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	Edit ed5 = new Edit(""); // use FILL as preferred width
\end_layout

\begin_layout Plain Layout

	ed5.setMaxLength(4);
\end_layout

\begin_layout Plain Layout

	ed5.setValidChars("123ABC");
\end_layout

\begin_layout Plain Layout

	add(ed5, LEFT, AFTER+5);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	Edit ed6 = new Edit("Can't Edit");
\end_layout

\begin_layout Plain Layout

	ed6.setEditable(false);
\end_layout

\begin_layout Plain Layout

	add(ed6, LEFT, AFTER+5);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The Edit control posts a ControlEvent.PRESSED event when the text changes.
 You may also want to intercept the event ControlEvent.FOCUS_OUT to validate
 the edit’s text.
\end_layout

\begin_layout Section
Label
\end_layout

\begin_layout Standard
This control is used to display static text, or a marquee.
 The Label in TotalCross can also display multiple lines of text, separated
 by the character '
\backslash
n'.
 Here are some other features:
\end_layout

\begin_layout Itemize
Label has three constructors: 
\end_layout

\begin_deeper
\begin_layout Itemize
Label() – Creates an empty label, using FILL as the preferred width.
\end_layout

\begin_layout Itemize
Label(String text) – Creates a label displaying the given text (that may
 be changed at runtime) using left alignment.
 
\end_layout

\begin_layout Itemize
Label(String text, int align) – Like the above, but you can also set the
 horizontal alignment using one of the constants LEFT, CENTER, RIGHT.
 or FILL (justified)
\end_layout

\end_deeper
\begin_layout Itemize
The three align constants are inherited from the totalcross.ui.Control class,
 where they are used in the setRect method.
 Furthermore, you can use new Label(“my text”,Label.CENTER) or new Label(“my
 text”, CENTER); it will work in the same way.
\end_layout

\begin_layout Itemize
The vertical alignment can be controlled using the vAlign field.
\end_layout

\begin_layout Itemize
The text is used to compute the preferred size.
 If you pass an empty string as text, the preferred width will be FILL.
 
\end_layout

\begin_layout Itemize
You can set/change the label's text alignment accessing the public member
 align.
\end_layout

\begin_layout Itemize
You can call the set3d method to make the label have a 3d look, by drawing
 it with the foreground color and with a color a little brighter than the
 background color.
\end_layout

\begin_layout Itemize
Labels can look inverted, by swapping the background and the foreground
 colors.
 To do this, use the setInvert method.
 By calling it twice you can make the text blink.
\end_layout

\begin_layout Itemize
The text can be highlighted using the setHighlighted method.
 The highlight color can be set using setHighlightedColor.
\end_layout

\begin_layout Itemize
Labels can’t be inverted and 3d at the same time.
 Calling set3d cancels setInverted and vice-versa.
\end_layout

\begin_layout Itemize
If the label is a multi-line one, you can use the method scroll(boolean
 down) to make it scroll up and down, and also the canScroll(boolean down)
 method to peek if it can be scrolled in the desired direction.
 To see a good usage example of this feature, see the totalcross.ui.dialog.MessageB
ox class.
 By default, the scroll is done a page at a time; to scroll a line at a
 time, change the pageScroll field to false.
\end_layout

\begin_layout Itemize
By default, the clear method does not affect the label's text.
 If you really want to clear it, you must explicitly set clearValueStr.
\end_layout

\begin_layout Itemize
The setText method, used to change the label’s text, does not change the
 control’s bounds.
 You must be sure that the label has enough size to hold the text otherwise
 it will be clipped.
\end_layout

\begin_layout Itemize
By default, this class does not do automatic parses the text, because this
 is a slow operation.
 You may change this behaviour by using the autoSplit field, or calling
 the split method directly.
\end_layout

\begin_layout Itemize
The method runMarquee(int delay, int loopCount, int step) shows the label
 as a horizontal marquee.
 The text must have a single line (if it has more than one line, only the
 first line is shown).
 To stop the marquee, just call setText.
 When a window covers the marquee, it is halted, and resumed when the window
 is closed.
\end_layout

\begin_layout Itemize
If you have problems with Labels when a rotation occurs, check the preferredWidt
hText field.
\end_layout

\begin_layout Itemize
You can add a border to the Label by changing the borderColor field.
\end_layout

\begin_layout Itemize
The background can be changed from solid to a shade by using the backgroundType
 field.
\end_layout

\begin_layout Itemize
The Label does not post any events.
\end_layout

\begin_layout Standard
Sample code:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public void initUI()
\end_layout

\begin_layout Plain Layout

{ 
\end_layout

\begin_layout Plain Layout

	add(new Label("This is a simple label"), LEFT, TOP);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	Label lab1 = new Label("This is a centered label", CENTER);
\end_layout

\begin_layout Plain Layout

	add(lab1);
\end_layout

\begin_layout Plain Layout

	lab1.setRect(LEFT, AFTER, FILL, PREFERRED);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	Label lab2 = new Label("This is another centered label", CENTER);
\end_layout

\begin_layout Plain Layout

	add(lab2);
\end_layout

\begin_layout Plain Layout

	lab2.setRect(LEFT, AFTER, FILL, PREFERRED);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	Label lab3 = new Label("Wow! A wonderful 3D label!");
\end_layout

\begin_layout Plain Layout

	lab3.set3d(true);
\end_layout

\begin_layout Plain Layout

	add(lab3, LEFT, AFTER);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	Label lab4 = new Label("A beautiful inverted label");
\end_layout

\begin_layout Plain Layout

	lab4.setInvert(true);
\end_layout

\begin_layout Plain Layout

	add(lab4, LEFT, AFTER);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	Label lab5 = new Label("This is a very long
\backslash
ntext and i dont
\backslash
nwant to waste my
\backslash
ntime parsing it to
\backslash
nbe fit it!");
\end_layout

\begin_layout Plain Layout

	add(lab5);
\end_layout

\begin_layout Plain Layout

	lab5.setRect(CENTER, AFTER, PREFERRED, PREFERRED);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Check
\end_layout

\begin_layout Standard
Check is a control that has a rectangle with a check inside and a text at
 right, and is used for items that have an on/off state.
\end_layout

\begin_layout Itemize
It has only one constructor:
\end_layout

\begin_deeper
\begin_layout Itemize
Check(String text) – Creates a check control displaying the given text.
\end_layout

\end_deeper
\begin_layout Itemize
The check's text is right justified in the control's width by default.
 You may change this behavior by setting the field leftJustify to true,
 this will make the text to be left justified in the control's width.
\end_layout

\begin_layout Itemize
To change the check's color, which defaults to the foreground color, use
 the checkColor field.
\end_layout

\begin_layout Itemize
The method isChecked returns the current checked state of the control.
\end_layout

\begin_layout Itemize
You may use setChecked(boolean checked) to change its state to checked or
 unchecked the control.
\end_layout

\begin_layout Itemize
The method setText can be used to change the displayed text.
\end_layout

\begin_layout Itemize
The method clear uses the field clearValueInt to set the check state.
 It sets the control as checked only if clearValueInt is 1, otherwise it
 sets the control as unchecked.
\end_layout

\begin_layout Standard
Sample code:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public void initUI()
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	Check chk1 = new Check("Checked enabled");
\end_layout

\begin_layout Plain Layout

	add(chk1, LEFT, TOP+5);
\end_layout

\begin_layout Plain Layout

	chk1.setChecked(true);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	Check chk2 = new Check("Unchecked enabled");
\end_layout

\begin_layout Plain Layout

	add(chk2, SAME, AFTER+5);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	Check chk3 = new Check("Check disabled");
\end_layout

\begin_layout Plain Layout

	add(chk3, SAME, AFTER+5);
\end_layout

\begin_layout Plain Layout

	chk3.setChecked(true);
\end_layout

\begin_layout Plain Layout

	chk3.setEnabled(false);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Like the Button control, the only event that the Check control posts is
 the ControlEvent.PRESSED.
 Below we see an example of how to handle a click on the check:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public void onEvent(Event event)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	switch (event.type)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		case ControlEvent.PRESSED:
\end_layout

\begin_layout Plain Layout

			if (event.target == chk1)
\end_layout

\begin_layout Plain Layout

			{
\end_layout

\begin_layout Plain Layout

				String state = chk1.isChecked() ? "checked" : "unchecked";
\end_layout

\begin_layout Plain Layout

				new MessageBox("TotalCross", "Checkbox " + state).popup();
\end_layout

\begin_layout Plain Layout

			}
\end_layout

\begin_layout Plain Layout

		break;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Radio and RadioGroupController
\end_layout

\begin_layout Standard
Radio is a control that allows the user to choose one of a predefined set
 of options.
 They are usually grouped together, and when the user selects one of them,
 any previously selected radio in the same group becomes deselected.
\end_layout

\begin_layout Itemize
In TotalCross, radio controls are grouped together using the RadioGroupControlle
r.
\end_layout

\begin_layout Itemize
It has two constructors:
\end_layout

\begin_deeper
\begin_layout Itemize
Radio(String text) – Creates a radio control displaying the given text.
\end_layout

\begin_layout Itemize
Radio(String text, RadioGroupController radioGroup) – Creates a radio control
 displaying the given text and attached to the given radio group.
\end_layout

\end_deeper
\begin_layout Itemize
The RadioGroupController is not a control, therefore you cannot add it to
 a container and it does not post events.
 It just provides useful methods to handle groups of radio controls, like:
\end_layout

\begin_deeper
\begin_layout Itemize
getSelectedIndex – returns the index of the selected radio
\end_layout

\begin_layout Itemize
setSelectedIndex – to select a radio by its index.
\end_layout

\begin_layout Itemize
getSelectedItem – returns the Radio selected
\end_layout

\begin_layout Itemize
setSelectedItem – selects a given RadioGroupController
\end_layout

\end_deeper
\begin_layout Itemize
These indices are based in the order that the radios are added to the container.
\end_layout

\begin_layout Itemize
You may use the getRadioGroupController method to make it easier to parse
 the events.
\end_layout

\begin_layout Itemize
The check's text is right justified in the control's width by default.
 You may change this behavior by setting the field leftJustify to true,
 this will make the text to be left justified in the control's width.
\end_layout

\begin_layout Itemize
To change the check's color, which defaults to the foreground color, use
 the checkColor field.
\end_layout

\begin_layout Itemize
The clear method selects the given Radio if its clearValueInt is 1.
\end_layout

\begin_layout Standard
Sample code:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public void initUI()
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	RadioGroupController rgFruits = new RadioGroupController();
\end_layout

\begin_layout Plain Layout

	add(rOrange = new Radio("Orange", rgFruits), LEFT, TOP + 5);
\end_layout

\begin_layout Plain Layout

	add(rApple = new Radio("Apple", rgFruits), LEFT, AFTER);
\end_layout

\begin_layout Plain Layout

	add(rGrape = new Radio("Grape", rgFruits), LEFT, AFTER);
\end_layout

\begin_layout Plain Layout

	add(rLemon = new Radio("Lemon", rgFruits), LEFT, AFTER);
\end_layout

\begin_layout Plain Layout

	rOrange.setChecked(true);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	String[] numbers = { "One", "Two", "Three" };
\end_layout

\begin_layout Plain Layout

	RadioGroupController rgNumbers = new RadioGroupController();
\end_layout

\begin_layout Plain Layout

	for (int i = 0; i < numbers.length; i++)
\end_layout

\begin_layout Plain Layout

		add(new Radio(numbers[i], rgNumbers), i == 0 ? CENTER : SAME, i == 0 ?
 (TOP + 5) : AFTER);
\end_layout

\begin_layout Plain Layout

	add(rEna = new Radio("Enable"), RIGHT, BOTTOM);
\end_layout

\begin_layout Plain Layout

	add(rDis = new Radio("Disable"), BEFORE - 2, BOTTOM);
\end_layout

\begin_layout Plain Layout

	rDis.setEnabled(false);
\end_layout

\begin_layout Plain Layout

	rDis.setChecked(true);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The Radio control posts a ControlEvent.PRESSED event when the user clicks
 on it.
 Below is an example of its use:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public void onEvent(Event event)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	switch (event.type)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		case ControlEvent.PRESSED:
\end_layout

\begin_layout Plain Layout

		{
\end_layout

\begin_layout Plain Layout

			if (event.target instanceof totalcross.ui.Radio)
\end_layout

\begin_layout Plain Layout

			{
\end_layout

\begin_layout Plain Layout

				Radio r = (Radio)event.target;
\end_layout

\begin_layout Plain Layout

				RadioGroup rg = r.getRadioGroup();
\end_layout

\begin_layout Plain Layout

				if (rg == rgFruits)
\end_layout

\begin_layout Plain Layout

				{
\end_layout

\begin_layout Plain Layout

					repaintNow(); // the MessageBox below will popup before the screen
 is updated to unselect the Radio
\end_layout

\begin_layout Plain Layout

					new MessageBox("TotalCross",r.getText()+" juice")).popup();
\end_layout

\begin_layout Plain Layout

				}
\end_layout

\begin_layout Plain Layout

				else if (rg == rgNumbers)
\end_layout

\begin_layout Plain Layout

				{
\end_layout

\begin_layout Plain Layout

					repaintNow(); 
\end_layout

\begin_layout Plain Layout

					new MessageBox("TotalCross","Number selected: "+r.getText()).popup();
\end_layout

\begin_layout Plain Layout

				}
\end_layout

\begin_layout Plain Layout

				else
\end_layout

\begin_layout Plain Layout

				{
\end_layout

\begin_layout Plain Layout

					// no RadioGroup; we have to handle by ourselves
\end_layout

\begin_layout Plain Layout

					if (r == rEna)
\end_layout

\begin_layout Plain Layout

					{
\end_layout

\begin_layout Plain Layout

						rEna.setChecked(true);
\end_layout

\begin_layout Plain Layout

						rDis.setChecked(false);
\end_layout

\begin_layout Plain Layout

						rDis.setEnabled(true);
\end_layout

\begin_layout Plain Layout

					}
\end_layout

\begin_layout Plain Layout

					else if (r == rDis)
\end_layout

\begin_layout Plain Layout

					{
\end_layout

\begin_layout Plain Layout

					rEna.setChecked(false);
\end_layout

\begin_layout Plain Layout

					rDis.setChecked(true);
\end_layout

\begin_layout Plain Layout

					rDis.setEnabled(false);
\end_layout

\begin_layout Plain Layout

					}
\end_layout

\begin_layout Plain Layout

				}
\end_layout

\begin_layout Plain Layout

			}
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

		break;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Section
ComboBox
\end_layout

\begin_layout Standard
ComboBox is a very useful control to display a list of items where only
 one can be selected.
 It consists of a text with a button and a ComboBoxDropDown control that
 is popped up when the button is pressed.
 The popped up list is closed when one of its items is selected or the control
 loses the focus.
\end_layout

\begin_layout Itemize
It has four constructors, but we'll only detail the three more interesting
 ones:
\end_layout

\begin_deeper
\begin_layout Itemize
ComboBox() – Creates an empty ComboBox.
\end_layout

\begin_layout Itemize
ComboBox(ListBox userListBox)– Creates a ComboBox with a ComboBoxDropDown
 containing the given ListBox.
\end_layout

\begin_layout Itemize
ComboBox(Object[] items) – Creates a ComboBox with the given items.
\end_layout

\end_deeper
\begin_layout Itemize
Using the PalmOS ui style, the ComboBoxDropDown covers the ComboBox control,
 otherwise it is placed above or below the ComboBox, without covering it.
\end_layout

\begin_layout Itemize
The ComboBoxDropDown height depends on the control's position: it will open
 in the direction that has the most space left (above or below).
 If you set the public member fullHeight to true, then it will have the
 same height as the screen, maximizing the number of items displayed.
 In the same way, the fullWidth will set the width to the screen's one.
\end_layout

\begin_layout Itemize
The clear method selects the index using the clearValueInt value.
\end_layout

\begin_layout Itemize
The color used in the setBackground method will be used in the arrow button
 only.
 The background color of the ComboBox text and ComboBoxDropDown will be
 a lighter version of the given color.
\end_layout

\begin_layout Itemize
You can change the ComboBox's scrollbar default width.
 To do so, you must use the static field Button.commonGap.
 Increasing its value will also increase the width of the arrow button and
 the scrollbar.
 Remember to reset the Button.commonGap value to 0 after the ComboBox creation,
 otherwise it will keep affecting all ComboBox and Buttons created after.
\end_layout

\begin_layout Itemize
You may append new items to your ComboBox using the method add, which has
 three useful implementations:
\end_layout

\begin_deeper
\begin_layout Itemize
add(Object item) – Adds an Object to the ComboBox.
 
\end_layout

\begin_layout Itemize
add(Object[] items) – Adds an array of Objects to the ComboBox.
\end_layout

\begin_layout Itemize
add(Object[] items, int startAt, int size) – Adds an array of Objects to
 the ComboBox.
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
Avoid making several calls to add(Object item), always prefer add(Object[]
 items).
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
You may insert new items at a desired position using insert(Object item,
 int index).
\end_layout

\begin_layout Itemize
The method setItemAt(int i, Object s) replaces the Object at the given index
 by the given Object.
\end_layout

\begin_layout Itemize
Use size() to retrieve the number of items available on the ComboBox.
\end_layout

\begin_layout Itemize
The method getItemAt(int i) returns the Object at the selected index, the
 reverse operation can be done with indexOf(Object name), which retrieves
 the index of a specific Object.
\end_layout

\begin_layout Itemize
Use getSelectedIndex() to get the index of the selected item, or getSelectedItem
() to retrieve the selected Object directly.
\end_layout

\begin_layout Itemize
You may select an item by its index with setSelectedIndex(int i) or by its
 content with setSelectedItem(Object name).
\end_layout

\begin_layout Itemize
The selectLast() method selects the last item added to the ComboBox, doing
 a scroll if needed.
\end_layout

\begin_layout Itemize
To remove items from a ComboBox, you may use one of the following three
 methods:
\end_layout

\begin_deeper
\begin_layout Itemize
remove(int itemIndex) – Removes an Object from the ComboBox by its index.
\end_layout

\begin_layout Itemize
remove(Object item) – Removes the given Object from the ComboBox.
\end_layout

\begin_layout Itemize
removeAll() – Empties the ComboBox.
\end_layout

\end_deeper
\begin_layout Itemize
The ComboBox items can be sorted using the method qsort().
\end_layout

\begin_layout Itemize
It is possible to make a ListBox scroll horizontally (see ListBox).
 To be able to scroll the ListBox associated with this ComboBox, just call
 the method enableHorizontalScroll().
\end_layout

\begin_layout Standard
Sample code:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public void initUI()
\end_layout

\begin_layout Plain Layout

{ 
\end_layout

\begin_layout Plain Layout

	String []items1 = {"","Orange","Apple","Grape","Lemon"};
\end_layout

\begin_layout Plain Layout

	String []items2 = {"One","Two","Three", ...};
\end_layout

\begin_layout Plain Layout

	String []items3 = {"Disabled","Enabled"};
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	ComboBox cb1 = new ComboBox(items1);
\end_layout

\begin_layout Plain Layout

	add(cb1,LEFT,TOP+5);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	ComboBox cb2 = new ComboBox();
\end_layout

\begin_layout Plain Layout

	cb2.add(items2);
\end_layout

\begin_layout Plain Layout

	cb2.add("Twenty one");
\end_layout

\begin_layout Plain Layout

	add(cb2,RIGHT,AFTER+5);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	ComboBox cb3 = new ComboBox(items3);
\end_layout

\begin_layout Plain Layout

	add(cb3);
\end_layout

\begin_layout Plain Layout

	cb3.setRect(LEFT,BOTTOM,PREFERRED+4,PREFERRED);
\end_layout

\begin_layout Plain Layout

	cb3.setSelectedIndex(0);
\end_layout

\begin_layout Plain Layout

	cb3.setEnabled(false);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
As the preceding controls, this one also posts a ControlEvent.PRESSED when
 the user selects an item.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public void onEvent(Event event)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	switch (event.type)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		case ControlEvent.PRESSED:
\end_layout

\begin_layout Plain Layout

			if (event.target == cb1)
\end_layout

\begin_layout Plain Layout

				new MessageBox("TotalCross", "Item selected: " +  cb1.getSelectedItem()).popup
();
\end_layout

\begin_layout Plain Layout

		break;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Section
ListBox
\end_layout

\begin_layout Standard
ListBox is a control that allows the user to select one item from a list
 contained within multiple line text box.
 It looks like an open ComboBox (in fact, the ComboBox uses the ListBox
 control).
 Consider using the ListBox instead of the ComboBox if the screen has enough
 space available to show all items.
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
Please notice that TotalCross' ListBox does not allow the selection of multiple
 items like one would expect.
 If you need this feature, use the MultiListBox control (refer to the advanced
 controls section).
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
ListBox has two constructors:
\end_layout

\begin_deeper
\begin_layout Itemize
ListBox() – Creates an empty ListBox.
\end_layout

\begin_layout Itemize
ListBox(Object[] items) – Creates a ListBox with the given items.
 
\end_layout

\end_deeper
\begin_layout Itemize
You can append new items to your ListBox using one of the following methods:
\end_layout

\begin_deeper
\begin_layout Itemize
add(Object item) – Adds an Object to the Listbox.
\end_layout

\begin_layout Itemize
add(Object[] moreItems) – Adds an array of Objects to the Listbox.
\end_layout

\begin_layout Itemize
add(Object[] moreItems, int startAt, int size) – Adds an array of Objects
 to the Listbox.
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
Avoid making several calls to add(Object item), always prefer add(Object[]
 items).
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
You may insert an Object at a desired position with insert(Object item,
 int index).
\end_layout

\begin_layout Itemize
The method setItemAt(int i, Object s) replaces the Object at the given index
 by the given Object.
\end_layout

\begin_layout Itemize
Use size() to retrieve the number of items available on the ListBox.
\end_layout

\begin_layout Itemize
The method getItemAt(int i) returns the Object at the selected index, the
 reverse operation can be done with indexOf(Object name), which retrieves
 the index of a specific Object.
\end_layout

\begin_layout Itemize
Use getSelectedIndex() to get the index of the selected item, or getSelectedItem
() to retrieve the selected Object directly.
\end_layout

\begin_layout Itemize
You may select an item by its index with setSelectedIndex(int i) or by its
 content with setSelectedItem(Object name).
\end_layout

\begin_layout Itemize
The selectLast() method selects the last item added to the ListBox, doing
 a scroll if needed.
\end_layout

\begin_layout Itemize
To remove items from a ListBox, you may use one of the following three methods:
\end_layout

\begin_deeper
\begin_layout Itemize
remove(int itemIndex) – Removes an Object from the Listbox by its index.
\end_layout

\begin_layout Itemize
remove(Object item) – Removes the given Object from the Listbox.
\end_layout

\begin_layout Itemize
removeAll() – Empties the ListBox.
\end_layout

\end_deeper
\begin_layout Itemize
The ListBox items can be sorted using the method qsort().
\end_layout

\begin_layout Itemize
To add a horizontal scroll to the ListBox, use the method enableHorizontalScroll
().
 Note that enabling this will make the addition of elements slower, because
 the ListBox will compute each item's width to find the maximum offset.
\end_layout

\begin_layout Itemize
To increase the default height of the horizontal scroll buttons, change
 the extraHorizScrollButtonHeight static member.
\end_layout

\begin_layout Itemize
The setSimpleBorder(boolean simpleBorder) method is used to change the border
 style from 3d to simple.
\end_layout

\begin_layout Itemize
If the ListBox owns the focus and you type a letter, the first item with
 the typed letter is selected.
 Typing again selects the next item, and so on.
\end_layout

\begin_layout Itemize
The up/down keys can be used to scroll the ListBox.
\end_layout

\begin_layout Itemize
The selection color can be changed with setCursorColor(int color).
\end_layout

\begin_layout Itemize
By default, the selection is drawn using the current item's width.
 This behavior can be changed by setting useFullWidthOnSelection to true.
\end_layout

\begin_layout Itemize
You can extend ListBox to implement a customized type, like a color-chooser
 ListBox (see ColorList).
 If doing so, the following methods must be overridden:
\end_layout

\begin_deeper
\begin_layout Itemize
protected void drawItem(Graphics g, int index, int dx, int dy)
\end_layout

\begin_layout Itemize
protected int getItemWidth(int index)
\end_layout

\begin_layout Itemize
protected void drawCursor(Graphics g, int sel, boolean on)
\end_layout

\end_deeper
\begin_layout Itemize
The clear method sets the clearValueInt as the selected index.
\end_layout

\begin_layout Standard
Sample code:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public void initUI()
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	String[] items1 = { "", "Orange", "Apple", "Grape", "Lemon" };
\end_layout

\begin_layout Plain Layout

	String[] items2 = { "One", "Two", "Three" };
\end_layout

\begin_layout Plain Layout

	String[] items3 = { "Disabled", "Enabled" };
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	ListBox lb1 = new ListBox(items1);
\end_layout

\begin_layout Plain Layout

	add(lb1, LEFT, TOP + 5);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	ListBox lb2 = new ListBox();
\end_layout

\begin_layout Plain Layout

	lb2.add(items2);
\end_layout

\begin_layout Plain Layout

	lb2.add("Twenty one");
\end_layout

\begin_layout Plain Layout

	add(lb2);
\end_layout

\begin_layout Plain Layout

	lb2.setRect(RIGHT, AFTER + 5, PREFERRED, FILL - 5);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	ListBox lb3 = new ListBox(items3);
\end_layout

\begin_layout Plain Layout

	add(lb3, RIGHT, TOP + 5);
\end_layout

\begin_layout Plain Layout

	lb3.setEnabled(false);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
Be careful when setting the items with an Object array.
 The array is assigned as is, no copy is made.
 So, if you use the same array in another control and an item inside the
 array is changed, this change will reflect in both controls.
 However, if you add a new item, a new array is created to store the added
 item and the program works correctly.
 The best practice is to have one array for each ListBox control.
 To copy the contents of an Object array to a new one, you can use totalcross.sys.
Vm.arrayCopy.
 If you're dealing specifically with String arrays, you may instead use
 totalcross.sys.Convert.cloneStringArray.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The ListBox also posts the ControlEvent.PRESSED when an item is clicked.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public void onEvent(Event event)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	switch (event.type)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		case ControlEvent.PRESSED:
\end_layout

\begin_layout Plain Layout

			if (event.target == lb1)
\end_layout

\begin_layout Plain Layout

				new MessageBox("TotalCross", "Item selected: " + lb1.getSelectedItem()).popup(
);
\end_layout

\begin_layout Plain Layout

		break;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Section
MultiEdit
\end_layout

\begin_layout Standard
MultiEdit is basically an Edit with support for multiple lines, so their
 usage is pretty similar and, unless noted otherwise, the same methods listed
 for Edit are available for MultiEdit.
 A static vertical scrollbar is added, but it is disabled/enabled as needed.
\end_layout

\begin_layout Itemize
MultiEdit has two constructors:
\end_layout

\begin_deeper
\begin_layout Itemize
MultiEdit(int rowCount, int spaceBetweenLines) – Creates a MultiEdit with
 a vertical scrollbar, the given number of rows and the default width FILL.
\end_layout

\begin_layout Itemize
MultiEdit(String mask, int rowCount, int spaceBetweenLines) – Creates a
 MultiEdit with a vertical scrollbar, the given number of rows and uses
 the given mask to compute the PREFERRED width.
 If the mask is “”, the width is set to FILL.
\end_layout

\end_deeper
\begin_layout Itemize
The method getNumberOfTextLines() returns the number of lines in the text.
\end_layout

\begin_layout Itemize
With setScrollbarsAlwaysVisible(boolean asNeeded) you can change the MultiEdit's
 scrollbar behavior.
\end_layout

\begin_layout Itemize
By default, a dotted line is shown under each text row.
 You can change this behavior with the field boolean drawDots.
\end_layout

\begin_layout Itemize
Use the field gap to change the gap between the rows.
 The default value is 1.
\end_layout

\begin_layout Itemize
The following methods allow you to manipulate the MultiEdit scrollbar:
\end_layout

\begin_deeper
\begin_layout Itemize
scrollToBottom() – Moves the scroll to the bottom.
\end_layout

\begin_layout Itemize
scrollToLine(int line) – Scrolls to the gives text line.
\end_layout

\begin_layout Itemize
scrollToTop() – Moves the scroll to the top.
\end_layout

\end_deeper
\begin_layout Standard
Sample code:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public void initUI()
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	String s = "James Robert Baker (1946-1997) was an American author of sharply
 satirical, predominantly gay-themed transgressional fiction.
 A native Californian, his work is set almost entirely in Southern California.
 After graduating from UCLA, he began his career as a screenwriter, but
 became disillusioned and started writing novels instead.
 Though he garnered fame for his books Fuel-Injected Dreams and Boy Wonder,
 after the controversy surrounding publication of his novel, Tim And Pete,
 he faced increasing difficulty having his work published.
 According to his life partner, this was a contributing factor in his suicide.
 Baker's work has achieved cult status in the years since his death, and
 two additional novels have been posthumously published.
 First-edition copies of his earlier works have become collector's items.
 One of his novels was filmed (though it was not a financial success) and
 two others have been optioned for the movies, though they have not been
 produced.";
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	MultiEdit mEdit;
\end_layout

\begin_layout Plain Layout

	mEdit = new MultiEdit("",6,1);
\end_layout

\begin_layout Plain Layout

	mEdit.drawDots = (false);
\end_layout

\begin_layout Plain Layout

	mEdit.justify = true;
\end_layout

\begin_layout Plain Layout

	mEdit.setEditable(false);
\end_layout

\begin_layout Plain Layout

	mEdit.hasCursorWhenNotEditable = false;
\end_layout

\begin_layout Plain Layout

	add(mEdit,LEFT,AFTER+2);
\end_layout

\begin_layout Plain Layout

	mEdit.setText(s); //eventually
\end_layout

\begin_layout Plain Layout

	mEdit.requestFocus();
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Grid
\end_layout

\begin_layout Standard
The Grid control is used to display tabulated data, which is represented
 as a String matrix (each row is a String array).
 Optionally, you may add an extra column of checks boxes on the left side
 of the Grid.
\end_layout

\begin_layout Standard
Although the TotalCross' Grid control usage is pretty simple and straightforward
, it is the most customizable control and it uses its own set of events
 defined in GridEvents (unlike the other controls that use only ControlEvents).
 That means you'll be able to start using grids within a couple minutes,
 but it will take some time to learn to use all its features.
\end_layout

\begin_layout Itemize
Horizontal scrolling in case the columns widths are greater than the screen
 width
\end_layout

\begin_layout Itemize
Vertical scrollbar to scroll up and down the information on the grid
\end_layout

\begin_layout Itemize
An easy to use interface for adding/removing information to the grid
\end_layout

\begin_layout Itemize
Optional check column, this is a column that is clickable marking an specific
 line as checked/unchecked, this is usefull if you want the user to be able
 to select multiple lines displayed on the grid
\end_layout

\begin_layout Itemize
Columns can be resized so that the user can see all the information displayed
 in a given column
\end_layout

\begin_layout Itemize
Style configuration, you can set the color of captions boxes all the way
 thru the stripes colors and vertical line types.
\end_layout

\begin_layout Itemize
The GridEvent class contains the events generated by the grid.
\end_layout

\begin_layout Itemize
A column may be marked as editable.
 In this case, an Edit will be placed in the currently focused cell.
 A column can also have choices (ComboBox).
\end_layout

\begin_layout Itemize
The columns can be sorted by clicking in the title.
\end_layout

\begin_layout Itemize
If the text is bigger than the size of the column, you can click and hold
 in the cell to display a tooltip with the full text.
\end_layout

\begin_layout Itemize
You can customize cell back and fore colors, enabled state and choices by
 using the CellController class
\end_layout

\begin_layout Itemize
Grid has two constructors:
\end_layout

\begin_deeper
\begin_layout Itemize
Grid(String[] captions, boolean checkEnabled) – Creates a grid with the
 given captions and, optionally, a multi-selection check column.
\end_layout

\begin_layout Itemize
Grid(String[] captions, int[] widths, int[] aligns, boolean checkEnabled)
 – Creates a grid with the given captions, column width, column text alignment
 and, optionally, a multi-selection check column.
\end_layout

\end_deeper
\begin_layout Itemize
add(String[] item): adds a new item to the grid.
\end_layout

\begin_layout Itemize
add(String[] item, int row): adds a new item to the grid at the given position.
\end_layout

\begin_layout Itemize
clear(): remove all items from the grid.
\end_layout

\begin_layout Itemize
del(int row): removes the given index from the grid.
\end_layout

\begin_layout Itemize
getCellText(int row, int col): returns the text of the given cell.
\end_layout

\begin_layout Itemize
setCellText(int row, int col, Strint text): sets the text of the given cell.
\end_layout

\begin_layout Itemize
getItem(int index): returns the line from the given index.
\end_layout

\begin_layout Itemize
getItemsVector(): returns a vector containing all information inside the
 grid.
 As with getItem, the returned data does not contain information about the
 selected item's.
\end_layout

\begin_layout Itemize
getCheckedRows(): returns an IntVector containing the indexes of the lines
 that have been marked with a check 
\end_layout

\begin_layout Itemize
int getSelectedIndex(): get the number of the currently selected line 
\end_layout

\begin_layout Itemize
String[] getSelectedItem(): gets the String array for the currently selected
 line
\end_layout

\begin_layout Itemize
boolean horizontalScroll(boolean toLeft): scrolls the grid to left or right.
 Returns true if the grid was scrolled, false if its impossible to scroll
 in that direction.
\end_layout

\begin_layout Itemize
isChecked:(int lineIndex): returns if the given line is checked.
\end_layout

\begin_layout Itemize
setChecked(int row, boolean check): checks or unchecks a given row.
\end_layout

\begin_layout Itemize
replace(String[] item, int row): replaces the given row by the text.
\end_layout

\begin_layout Itemize
setSelectedRow(int line): selects the given row number.
 If -1, unselects the grid.
 
\end_layout

\begin_layout Itemize
setItems(java.lang.String[][] items): sets the grid items to be displayed,
 notice that it needs to conform to the numbers of columns that the grid
 currently have.
\end_layout

\begin_layout Itemize
size(): returns the number of lines in this grid
\end_layout

\begin_layout Itemize
setColumnEditable(int col, boolean editable): enabled/disable the edition
 for all cells of a grid's column.
\end_layout

\begin_layout Itemize
setColumnChoices(int col, String[] choices): enable a ComboBox with choices
 for all cells of a grid's column.
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
Note that the setColumnEditable and setColumnChoices are mutually exclusive:
 calling one cancels the effects of the other.
 The setDataSource and setItems methods are also mutually exclusive.
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
setDataSource(Grid DataSource ds, int nrItems): passing the class that implement
s the Grid.DataSource interface and the total number of items, allows the
 grid to request data on demand.
 This greatly reduces the memory usage, because only the number of visible
 items may be loaded at each time, but makes the grid navigation slower.
 Note that in this mode the grid scroll will not be realtime: the data will
 be requested only when the user releases the scroll bar.
 The DataSource has a single method: String[][]getItems(int startingRow,
 int count), that must return the given number of items or less.
\end_layout

\begin_layout Itemize
setCellController(Grid.CellController cc): passing the class that extends
 Grid.CellController will allow you to have a fine control of each cell of
 the grid.
 Note that using a CellController will make the drawings slower.
 The class has the following methods:
\end_layout

\begin_deeper
\begin_layout Itemize
int getBackColor(int row, int col): must return the background color for
 the given cell, or null if you want to use the default one.
\end_layout

\begin_layout Itemize
int getForeColor(int row, int col): must return the foreground color for
 the given cell, or null if you want to use the default one.
\end_layout

\begin_layout Itemize
boolean isEnabled(int row, int col): must return if the given cell is enabled,
 ie, can have input and can be selected.
 Regarding the input, it will only work if the setColumnChoices or setEditable
 was called to the given column.
 Regarding the selection, it may also disable column's check state change.
\end_layout

\begin_layout Itemize
String[] getChoices(int row, int col): returns a customized set of choices
 for the given cell.
 Must return null if you want to use the default set.
 Only works if setColumnChoices was called to the given column.
\end_layout

\end_deeper
\begin_layout Itemize
Here are some useful attributes:
\end_layout

\begin_deeper
\begin_layout Itemize
boldCheck: draws a bold check instead of the tiny one.
 Useful for high resolution devices.
\end_layout

\begin_layout Itemize
canClickSelectAll: set to false to disable the click on the check column
 of the captions to select and unselect all checks.
\end_layout

\begin_layout Itemize
disableSort: disables the sort when clicking in the column's caption.
\end_layout

\begin_layout Itemize
drawCheckBox: boolean that defines if the box around the check will or not
 be drawn.
\end_layout

\begin_layout Itemize
enableColumnResize: set to false to disable the column resize by dragging
 the column separator line.
\end_layout

\begin_layout Itemize
extraHorizScrollButtonHeight: a value that can increase the horizontal buttons
 height.
\end_layout

\begin_layout Itemize
oldCellText: the text that was in the cell before the user had editted it..
\end_layout

\begin_layout Itemize
checkColor: the color used to draw the check.
\end_layout

\begin_layout Itemize
captionsBackColor: the color used to fill the captions area.
\end_layout

\begin_layout Itemize
firstStripeColor: color of the first stripe.
 
\end_layout

\begin_layout Itemize
secondStripeColor: color of the second stripe.
 drawStripes must also be set to true.
\end_layout

\begin_layout Itemize
verticalLineStyle: defines the vertical line style of the grid.
 Possible values are VERT_DOT (default), VERT_LINE and VERT_NONE.
\end_layout

\begin_layout Itemize
String[] captions: these are the column captions.
 Can be directly assigned, but always make sure it has the same number of
 columns of the Grid.
\end_layout

\end_deeper
\begin_layout Itemize
A GridEvent is dispatched in the following situations:
\end_layout

\begin_deeper
\begin_layout Itemize
When the user selects a row: type = SELECTED_EVENT, row and col are set
 with the cell that was clicked.
\end_layout

\begin_layout Itemize
When the user checks a row: type = CHECK_CHANGED_EVENT, row is set with
 the row that was checked, col is 0 and checked contains the current state.
\end_layout

\begin_layout Itemize
When the user press the check/uncheck all box: type = CHECK_CHANGED_EVENT,
 col is 0 and row is set to Grid.ALL_CHECKED and Grid.ALL_UNCHECKED.
\end_layout

\begin_layout Itemize
When the user changes the text of a editable column or selected a new choice:
 type = TEXT_CHANGED_EVENT, row and col are set with the cell that changed.
 The new text can be found with getCellText, and Grid.oldCellText contains
 the old text.
\end_layout

\end_deeper
\begin_layout Standard
Sample code:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public void initUI()
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	String []gridCaptions = {"Caption 1", "Caption 2", "Caption 3", "Caption
 4", "Caption 5", "Caption 6", "Caption 7" };
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	int ww = fm.getTextWidth("xxxxxxxxx"); 
\end_layout

\begin_layout Plain Layout

	int gridWidths[] = {ww, ww, ww, ww, ww, ww, ww};
\end_layout

\begin_layout Plain Layout

	int gridAligns[] = { LEFT,LEFT,LEFT,LEFT,LEFT,LEFT,LEFT}; 
\end_layout

\begin_layout Plain Layout

	grid = new Grid( gridCaptions, gridWidths, gridAligns, false );
\end_layout

\begin_layout Plain Layout

	grid.firstStripeColor = Color.GREEN;
\end_layout

\begin_layout Plain Layout

	grid.secondStripeColor = Color.YELLOW;
\end_layout

\begin_layout Plain Layout

	grid.verticalLineStyle = Grid.VERT_NONE;
\end_layout

\begin_layout Plain Layout

	add(grid);
\end_layout

\begin_layout Plain Layout

	grid.setRect(LEFT, AFTER+2, FILL, FIT, btnRemove);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	String items[][] = new String[4][7]; 
\end_layout

\begin_layout Plain Layout

	for(int i = 0; i < 4; i++)
\end_layout

\begin_layout Plain Layout

		for(int j = 0; j < 7; j++)
\end_layout

\begin_layout Plain Layout

			items[i][j] = "BRAZIL " + j;
\end_layout

\begin_layout Plain Layout

	grid.setItems(items); 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Section
ToolTip 
\end_layout

\begin_layout Standard
It allows the display of a tooltip when user keeps the pen in the control.
 The default popup delay is 1000ms and the amount of time it will be displayed
 is 2000ms (a pen up also hides the control).
 The tooltip must always be added after the control is added and had its
 bounds set; otherwise, you must call the added method to initialize the
 tip's bounds.
\end_layout

\begin_layout Standard
You can set the border color by changing the borderColor field (no border
 by default) and also the internal gap (see field insideGap).
\end_layout

\begin_layout Standard
The static members distX and distY lets you set the default distance from
 the control for all tooltips.
 They must be set before the tooltip is created.
 
\end_layout

\begin_layout Standard
The constructor receives the control which the tooptip refers to and the
 message that will be displayed.
 You can use the new line character '
\backslash
n' like a label control.
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
ToolTip implements PenListener interface.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Sample code:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

private void addToolTip(Control c, String text)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	ToolTip t = new ToolTip(c,text);
\end_layout

\begin_layout Plain Layout

	t.millisDelay = 500;
\end_layout

\begin_layout Plain Layout

	t.millisDisplay = 5000;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	if (Settings.isColor)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		t.borderColor = Color.BLACK;
\end_layout

\begin_layout Plain Layout

		t.setBackColor(Color.getRGB(250,250,0));
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

public void initUI()
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	add(btnChooseColor = new Button("Choose new background color"), LEFT, TOP+2);
\end_layout

\begin_layout Plain Layout

	addToolTip(btnChooseColor, "Click this button to open a
\backslash
nChoiceDialog that contains a
\backslash
nColorList control from where
\backslash
nyou can choose a back new color");
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
Advanced Controls
\end_layout

\begin_layout Standard
Placeholder for a future section.
\end_layout

\begin_layout Chapter
The Window class
\end_layout

\begin_layout Standard
As you already know, a TotalCross program consists of one and only one MainWindo
w.
 This MainWindow can pop up a window, and this new window can pop up another
 one, and so on.
 Windows in TotalCross are always modal, therefore, only the last popped
 up window can receive events and you cannot switch from the topmost Window
 to the previous without closing the topmost one.
\end_layout

\begin_layout Standard
Although the Window class extends Control, you may not add a Window to a
 Container.
 Doing this results in a RuntimeException.
 To show a Window, you must use the method popup or the method popupNonBlocking.
\end_layout

\begin_layout Standard
Some other features of the Window class:
\end_layout

\begin_layout Itemize
Windows can have a title that can be set by the method setTitle or passed
 to the constructor.
\end_layout

\begin_layout Itemize
The window border can be selected from one of the multiple styles shown
 below, by using the setBorderStyle method or passing the desired style
 to the Window constructor.
\end_layout

\begin_layout Itemize
There are two constructors: the default one, that creates a Window with
 no title and no border, and one constructor with both title and border
 parameters.
\end_layout

\begin_layout Itemize
Windows can be moved around the screen by dragging the window’s title.
 If the window has no title, it can’t be moved.
 You can make a titled window unmovable by calling the makeUnmovable method.
\end_layout

\begin_layout Itemize
The title font can be changed using the setTitleFont method.
 By default, the font is the one used by the MainWindow, with bold style.
\end_layout

\begin_layout Itemize
Only one control can hold the focus at a time.
 To change focus to another control, use the setFocus method (this can also
 be done through the requestFocus method in the totalcross.ui.Control class).
 The getFocus method returns the control that currently owns the focus.
\end_layout

\begin_layout Itemize
The rectangle area excluding the border and the title is defined as the
 client rectangle.
 You can get it with the getClientRect method.
\end_layout

\begin_layout Itemize
A window can be popped up by calling the popupNonBlicking method and can
 be unpopped by calling the unpop method.
 The popup process saves the area behind the Window that is being popped
 up and the unpop process restores that area.
 The unpop method posts a ControlEvent.WINDOW_CLOSED event to the caller
 window.
 The popupNonBlocking method can be called like this.popupNonBlocking().
\end_layout

\begin_layout Itemize
A window can also be popped up by calling the popup method, and be unpopped
 by the same unpop method described above.
 The big difference is that in popupNonBlocking, the program execution continues
 to the next line, while in popup, the program execution is halted and only
 continues when the popped up Window is dismissed.
 Menu, MessageBox, ComboBox and ComboBoxDropDown are popped up using popupNonBlo
cking, because execution does not need to be halted.
 InputDialog, Calendar, Calculator, usually are popped up using popup because
 the user may want to get the result of the dialog in an easy way.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
You can't use popup to popup alternating windows that call each other recursivel
y.
 For example, suppose that from Win1 you call win2.popup(), then at Win2
 you call unpop and then win1.popup).
 Then, from Win1 you do unpop again and win2.popup(), and so on.
 This will lead to a hard reset on the device due to a native stack overflow.
 To fix this, just replace the popup by popupNonBlocking.
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
The topmost window (the one who receive events) can be obtained with the
 static method getTopMost.
 To check if this window is the topmost, use the isTopMost method.
\end_layout

\begin_layout Itemize
Try setGrabPenEvents for set to a control to redirect all pen events directly
 to it.
 This method speeds up pen event processing.
 Used in Whiteboard class.
 
\end_layout

\begin_layout Itemize
You may check if this window is visible using the isVisible method.
 This method is inherited from totalcross.ui.Control, but it simply checks
 if the current window is the topmost one.
\end_layout

\begin_layout Itemize
Using the setStatePosition method can show PalmOS Grafitti state characters.
 To hide it, call setStatePosition(HIDE_STATE,HIDE_STATE).
 This method is also used in Windows CE and Pocket PC to show/hide the virtual
 keyboard (when applicable).
 Just use as parameter VK_HIDE, VK_TOP and VK_BOTTOM to hide, display the
 virtual keyboard at top of the screen or at the bottom of the screen.
 Note that this will have no effect in devices that don't have a virtual
 keyboard.
\end_layout

\begin_layout Itemize
Each window can have a menu attached by using the method setMenuBar.
 The menuBar can be made visible programatically by calling the popupMenuBar
 method.
\end_layout

\begin_layout Itemize
Suppose you wish to allow the user to abort a task being executed by pressing.
 You can use the method pumpEvents to process all events in the queue.
\end_layout

\begin_layout Itemize
The methods getPreferredWidth and getPreferredHeight have a special meaning
 for the Window class.
 They return the minimum width/height needed for the correct display of
 this Window.
 The getPreferredWidth returns the width of the title (if any) plus the
 width of the border (if any).
 The getPreferredHeight returns the height of the title (if any) plus the
 height of the border (if any).
\end_layout

\begin_deeper
\begin_layout Standard
There are some useful protected methods that may be implemented by controls
 that extend totalcross.ui.Window.
 Those methods are placeholders and there is no need to call the super method.
\end_layout

\end_deeper
\begin_layout Itemize
onClickedOutside(int x, int y): This method is used in popup windows.
 If the user clicks outside the window’s bounds, this method is called giving
 the absolute coordinates of the clicked point.
 There are two options:
\end_layout

\begin_deeper
\begin_layout Itemize
If you had handled the action, return true in this method.
\end_layout

\begin_layout Itemize
Otherwise, false must be returned and if the beepIfOut member is true, a
 beep is played (in other words, beepIfOut can be set to false to disable
 this beep).
\end_layout

\end_deeper
\begin_layout Itemize
onPopup(): Called just after the behind contents are saved and before the
 popup process begin.
 When this method is called, the topmost window is still the parent of the
 Window being popped up.
\end_layout

\begin_layout Itemize
postPopup(): Called after the popup process ended.
 When this method is called, the popped up window is fully functional.
 It is a good place to put a control.requestFocus() to make the window popup
 with the focus in a default control.
\end_layout

\begin_layout Itemize
onUnpop(): Called just before the unpop process begin.
\end_layout

\begin_layout Itemize
postUnpop(): Called after the unpop process ended.
 When this method is called, the unpopped window has gone away and the parent
 Window is currently the topmost.
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
A very common mistake is to popup a Window without setting its bounds.
 If no bounds are set, the window will not receive events.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Some other important members of the Window class are explained here:
\end_layout

\begin_layout Itemize
boolean needsPaint: true if there are any controls marked for repaint.
\end_layout

\begin_layout Itemize
boolean flickEnabled: if true, the background area is erased during the
 repaint process.
 This causes flickering if the window is not double buffered.
\end_layout

\begin_layout Itemize
Window topmost: stores the topmost Window.
\end_layout

\begin_layout Itemize
boolean canDrag: if true and if this is a popup window, the user is allowed
 to drag the title and make the window move around.
\end_layout

\begin_layout Itemize
boolean highResPrepared: This extremely important member is used when your
 program runs in devices with a screen resolution greater than the default
 160x160 of Palm OS.
 Some devices have 320x320, 240x320, etc.
 For each device, the font is usually proportional to the resolution.
 Since TotalCross programs are placed in a relative way, and since the relativen
ess depends on the Window's size, your popped up Window would look squashed
 because the Windows bounds are usually set with an absolute coordinate.
 To avoid this, the Window manager checks if your Window is prepared for
 high resolution devices (i.e., you tested it against other resolutions and
 set the right value for the Window depending on each case).
 If your Window is not prepared, then the setRect method will multiply the
 size of the Window by a factor that depends on how much the screen resolution
 has changed from the basic 160x160 (E.g.: in a 240x320 device, a 80x40 Window
 will be changed to 120x80).
 Also, the window will be centered on screen.
 So, if you have tested your Window in other resolutions, set this flag
 to true.
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
Never mess with the public member zStack.
 It is used to store the windows that are currently popped up.
 It is made public because the totalcross.Launcher class uses it.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Next is explained how controls inside a Window are repainted: 
\end_layout

\begin_layout Enumerate
The programmer calls the repaint method of some controls, or a control is
 clicked and marks itself for repaint.
\end_layout

\begin_layout Enumerate
The damageRect method in class Window creates a rectangle (stored in the
 paintX, paintY, paintWidth and paintHeight members) with the union of the
 bounds of all controls marked for repaint.
 
\end_layout

\begin_layout Enumerate
The next time a VM event is posted, the _doPaint method of the topmost window
 is called.
 This method paints the window’s title/border (if any) and calls the onPaint
 method of all containers and controls that lies inside the rectangle area
 marked for repaint.
 This explains why nothing in the window is updated when you receive events
 directly from a native library (the Scanner class, for example).
 Because the VM is not receiving the event, it never validates the window.
 In these cases, you must update the window yourself, calling repaintNow
 or the validate methods.
\end_layout

\begin_layout Standard
Many classes in the totalcross.ui package extend totalcross.ui.Window.
 Examples of such classes are totalcross.ui.CalculatorBox and totalcross.ui.Calendar
Box.
 Other good examples are totalcross.ui.dialog.MessageBox and totalcross.ui.ComboBoxDr
opDown.
 
\end_layout

\begin_layout Standard
It's important to be aware that it is not a good practice to create classes
 that extend Window if they will occupy the whole screen, because they use
 a lot of memory to store the underlying area.
 Opening the menu may lead to time-consuming redraws of all opened windows
 due to out-of-memory problems.
 In these cases, it is better to use Containers.
\end_layout

\begin_layout Section
UIColors
\end_layout

\begin_layout Standard
This class contains the default colors used in most user interface windows,
 like the CalendarBox, KeyboardBox, CalculatorBox, InputBox, MessageBox,
 and also the default foreground and background colors of all controls created.
 
\end_layout

\begin_layout Standard
There are no methods on this class, only public static members, which can
 be freely changed to meet your user interface color scheme.
\end_layout

\begin_layout Chapter
Interface Dialogs
\end_layout

\begin_layout Standard
The TotalCross SDK provides some handy interface dialogs, which are windows
 that handles common user interaction scenarios, like displaying an informative
 message or requesting a specific user input.
\end_layout

\begin_layout Standard
Interface dialogs are pop-up windows that extend the Window class, and just
 like the Window, they are not automatically displayed under creation.
 To show or hide a dialog you must use Window methods: popup, popupNonBlocking
 and unpop.
\end_layout

\begin_layout Section
MessageBox
\end_layout

\begin_layout Standard
Simple dialog used to display a text with some user-defined buttons.
 Useful for displaying informative messages or to make the user take a decision
 before proceeding (e.g.
 “Yes/No”, “Ok/Cancel”, “Save/Discard/Cancel”).
\end_layout

\begin_layout Itemize
MessageBox has three constructors:
\end_layout

\begin_deeper
\begin_layout Itemize
MessageBox(String title, String msg) – Creates a MessageBox with the given
 title and message.
 The message is displayed using a label, and can be displayed in multiple
 lines if previously parsed with the '
\backslash
n' character.
 It also displays a single <Ok> button to dismiss the window.
\end_layout

\begin_layout Itemize
MessageBox(String title, String text, String[] buttonCaptions) – Same as
 the above, but also receives a string array specifying the button captions.
 A PushButtonGroup is used to display the buttons, and the method getPressedButt
onIndex() returns the index of the pressed button (where the first one has
 index 0).
\end_layout

\begin_layout Itemize
MessageBox(String title, String text, String[] buttonCaptions, int gap,
 int insideGap) – Same as the above, but also receives the gap (space between
 buttons) and insideGap (space between the button's text and it's bounds)
 to be used by the PushButtonGroup.
\end_layout

\end_deeper
\begin_layout Standard
The MessageBox is displayed on the center of the device screen, and its
 bounds are calculated based on the given title, text and buttons.
 If the text height is above the screen limits, two arrows are added to
 the MessageBox to allow the text scrolling.
\end_layout

\begin_layout Itemize
MessageBox has only three instance methods:
\end_layout

\begin_deeper
\begin_layout Itemize
getPressedButtonIndex() – Returns the index of the pressed button.
 This index is zero based (the first element has index 0).
\end_layout

\begin_deeper
\begin_layout Standard
This method returns -1 if invoked before the window is closed (or if it
 is closed without any button being pressed).
 To make sure you're retrieving the correct value, consider using popup
 instead of popupNonBlocking, or invoke this method only after the window
 is closed (the MessageBox is a Window, so it also posts the event ControlEvent.W
INDOW_CLOSED when closed).
\end_layout

\end_deeper
\begin_layout Itemize
setTextAlignment(int align) – Sets the alignment of the label that displays
 the text.
 The argument must be one of the following constants LEFT, CENTER, RIGHT.
 The default alignment is CENTER.
\end_layout

\begin_layout Itemize
setUnpopDelay(int unpopDelay) – Automatically unpops the MessageBox after
 the given time in milliseconds.
 You must use this method just before displaying the window (either by popup
 or popupNonBlocking).
\end_layout

\begin_deeper
\begin_layout Standard
This method actually adds a timer to the MessageBox, invoking the unpop
 method when the TimerEvent is triggered.
 Be sure to learn how the timer works to better understand this method.
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
The method setUnpopDelay does not affect the regular behavior of the MessageBox
 – the popupNonBlocking method will not block the program execution and
 will still return immediately, the popup method will still block the program
 execution, and the MessageBox may still be dismissed by the user (e.g.
 pressing one of its buttons) before the timer finishes.
\end_layout

\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
An interesting feature of the MessageBox is that you may create it with
 no buttons, just passing the null value for the constructor's argument
 buttonCaptions.
 However, a MessageBox created with no buttons does not provide a default
 way of being dismissed by the user.
 You must dismiss it programatically, by invoking unpop, using setUnpopDelay
 or handling events (e.g.
 You may handle PenEvents to make it unpop after the user touches the screen).
\end_layout

\begin_layout Standard
The MessageBox class has a handy method to debug your application:
\end_layout

\begin_layout Itemize
showException(Throwable t, boolean dumpToConsole) – Immediately displays
 a MessageBox showing the given throwable name, message and its stack trace.
 This information is dumped to the debug console if the dumpToConsole is
 true.
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
If you use an IDE with customizable templates for automatic code generation
 (like Eclipse), try changing the template for try/catch blocks to call
 MessageBox.showException instead of Throwable.printStackTrace.
\end_layout

\end_inset


\end_layout

\begin_layout Section
InputBox
\end_layout

\begin_layout Standard
Simple dialog used to get a text input from the user.
 It contains a label do display some text, and edit to receive the user
 input, and some user-defined buttons.
 Basically it's like a MessageBox with an edit.
\end_layout

\begin_layout Itemize
It has two constructors:
\end_layout

\begin_deeper
\begin_layout Itemize
InputBox(String title, String text, String defaultValue) – Creates an InputBox
 with the given title, text, a default value for the edit and two buttons:
 <Ok> and <Cancel>.
\end_layout

\begin_layout Itemize
InputBox(String title, String text, String defaultValue, String[] buttonCaptions
) – Same as the above, plus a string array specifying the buttons captions.
 A PushButtonGroup is used to display the buttons, and the getPressedButtonIndex
() method returns the pressed button index.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
Unlike the MessageBox, the argument buttonCaptions cannot have a null value.
\end_layout

\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
The InputBox is displayed on the center of the device screen, and its bounds
 are calculated based on the given title, text, edit and buttons.
 If the text height is above the screen limits, two arrows are added to
 the InputBox to allow the text scrolling.
 And its edit receives the focus when the InputBox is popped up.
\end_layout

\begin_layout Itemize
The InputBox provides the following instance methods:
\end_layout

\begin_deeper
\begin_layout Itemize
getPressedButtonIndex() – Returns the index of the pressed button.
 This index is zero based (the first element has index 0).
\end_layout

\begin_deeper
\begin_layout Standard
This method returns -1 if invoked before the window is closed (or if it
 is closed without any button being pressed).
 To make sure you're retrieving the correct value, consider using popup
 instead of popupNonBlocking, or invoke this method only after the window
 is closed (the InputBox is a Window, so it also posts the event ControlEvent.WIN
DOW_CLOSED when closed).
\end_layout

\end_deeper
\begin_layout Itemize
getEdit() – Returns a reference to this InputBox's edit, so you can change
 its properties.
\end_layout

\begin_layout Itemize
getValue() – Returns a string with the edit's text.
\end_layout

\begin_layout Itemize
setValue(String value) – Sets the edit with the given value.
\end_layout

\end_deeper
\begin_layout Section
KeyboardBox
\end_layout

\begin_layout Standard
Dialog that displays a virtual keyboard that can be used to handle text
 input either by the device's keyboard or by pen events on the virtual keyboard
 on devices with touchscreen.
\end_layout

\begin_layout Standard
Unlike other dialogs, the KeyboardBox constructor does not receive any arguments
, and it does not provide any methods for its manipulation.
 So how does it work?
\end_layout

\begin_layout Standard
When the KeyboardBox is popped up, it gets the control of the topmost window
 that currently holds the focus.
 The control is shown at the top of the KeyboardBox, and any text input
 received is passed to the control as a key event.
 If the virtual keyboard is used, the KeyboardBox handles the pen event,
 converting it to a key event before passing to the target control.
\end_layout

\begin_layout Standard
The Edit and MultiEdit controls may use the KeyboardBox for text input.
\end_layout

\begin_layout Section
CalculatorBox
\end_layout

\begin_layout Standard
A dialog with a simpler calculator.
 It allows you to enter two numbers, select an operation and calculate the
 result.
 You may also paste the result or the first operand.
\end_layout

\begin_layout Standard
The CalculatorBox has only the default constructor and the following methods:
\end_layout

\begin_layout Itemize
clear(boolean requestFocusOnOper1) - Clears everything in this calculator.
\end_layout

\begin_layout Itemize
getAnswer() - Returns a string with the answer the user selected to be pasted
 (the result or the first operand).
\end_layout

\begin_layout Section
CalendarBox
\end_layout

\begin_layout Standard
Displays a calendar where a date can be chosen.
 It pops up with the current day as default and the user can scroll through
 months or year.
 When a day is selected the calendar is closed and you may retrieve a Date
 object representing the chosen date.
\end_layout

\begin_layout Standard
The CalendarBox has only the default constructor and the following methods:
\end_layout

\begin_layout Itemize
getSelectedDate() – Returns a Date object representing the selected date,
 or null if the calendar is canceled.
\end_layout

\begin_layout Itemize
setSelectedDate(Date d) – Changes this CalendarBox current date by the given
 one.
 If the given date is null, the current date is set to today.
\end_layout

\begin_layout Standard
To correctly retrieve the selected date, you can handle the ControlEvent.PRESSED
 event posted by the calendar, and call getSelectedDate.
\end_layout

\begin_layout Standard
Sample code:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

CalendarBox calendar = new CalendarBox();
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

public void initUI()
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	calendar.popup();
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

public void onEvent(Event event)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	if (event.type == ControlEvent.PRESSED && event.target == calendar)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		Date date = calendar.getSelectedDate();
\end_layout

\begin_layout Plain Layout

		String text = date == null ? "No date selected" : date.toString();
\end_layout

\begin_layout Plain Layout

		new MessageBox("Selected Date", text).popup();
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
Splitting your application's logic using Container
\end_layout

\begin_layout Standard
Placeholder for this section.
\end_layout

\begin_layout Chapter
Image
\end_layout

\begin_layout Standard
Image is a rectangular image, which you can draw into or copy to a surface
 (using a Graphics object).
 They are always 24bpp, and TotalCross supports only the PNG and JPEG formats
 when running on the TCVM.
\end_layout

\begin_layout Standard
However, you may still use GIF and BMP files on your application, because
 these formats are also supported when running on Java, and the TotalCross
 deployer automatically converts those files to 24bpp PNG files, which are
 then packaged with your application (along with any other required resources).
\end_layout

\begin_layout Standard
Image objects cannot be directly added to the user interface because they
 are not controls (i.e.
 the Image class does not extend the Control class).
 To display an image on the user interface, you may either use the Graphics
 object to draw the Image on the screen, or use a control that better suits
 your needs, like ImageControl or Button (both described at the user interface
 section of this document).
\end_layout

\begin_layout Itemize
Image constructors:
\end_layout

\begin_deeper
\begin_layout Itemize
Image(int width, int height) – Creates an image object with the given width
 and height.
 The new image has the same color depth and color map of the default drawing
 surface.
\end_layout

\begin_layout Itemize
Image(byte[] fullDescription) – Creates an image object from the given byte
 array, which must specify the whole image, including its headers.
\end_layout

\begin_layout Itemize
Image(String path) – Attempts to read the contents of the file specified
 by the given path, creating an image object from the bytes read.
\end_layout

\begin_layout Itemize
Image(Stream s) – Attempts to read the contents of the given stream, and
 create an image object from the bytes read.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
The usage of this last constructor with connection oriented streams (like
 Socket) is not advised.
\end_layout

\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
If you want to check if a specific file is supported by the platform at
 runtime, you may use the static method Image.isSupported(String filename).
\end_layout

\begin_layout Itemize
To retrieve the image dimensions, you may use the methods getWidth() and
 getHeight().
\end_layout

\begin_layout Itemize
The method getGraphics() returns the Graphics object used by this image,
 which provides several methods that may be used for drawing in this image.
\end_layout

\begin_layout Itemize
You may change all pixels of the same color by another color with the method
 changeColors(int from, int to).
\end_layout

\begin_layout Standard
The deployer also convert animated GIFs into multi-frame PNGs – which are
 regular PNG files that contains all frames from the original GIF, along
 with the number of frames – to be packaged with the application's tclass
 file.
\end_layout

\begin_layout Standard
In this case, you may use the method getFrameCount() to check if the loaded
 image contains more than one frame.
\end_layout

\begin_layout Standard
However, you may want to load an actual PNG or JPEG file created in multi-frame
 format to display an animation.
 In this case, the number of frames contained in the file will be unknown
 and getFrameCount() will return 1.
\end_layout

\begin_layout Standard
To set the actual number of frames on the image, you must use the method
 setFrameCount(int n), which sets the total number of frames of the image
 by the given one, but only if the total image width (including all frames)
 is divisible by the given value.
\end_layout

\begin_layout Standard
The image's frame count cannot be changed if their value is already higher
 than 1.
 In this case, the setFrameCount method simply returns without doing anything.
\end_layout

\begin_layout Itemize
The following methods should be used only on multi-frame images.
\end_layout

\begin_deeper
\begin_layout Itemize
getCurrentFrame() - Returns the index of the current visible frame.
\end_layout

\begin_layout Itemize
setCurrentFrame(int nr) – Sets the given frame index as the current frame,
 moving its contents to the set of visible pixels.
 If the given index is negative, the last frame is set as the current frame;
 If it's higher than the number of frames, the first one is set instead.
\end_layout

\begin_layout Itemize
nextFrame() - Sets the next frame as the current one.
\end_layout

\begin_layout Itemize
prevFrame() - Sets the previous frame as the current one.
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
Both nextFrame and prevFrame treat the multi-frame image as a circular list,
 looping back to the first frame if moving forward from the last frame,
 or to the last frame if moving backwards from the first frame.
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
The Image class also provides the methods that creates a new Image object
 to be changed and returned, instead of changing the original instance:
\end_layout

\begin_deeper
\begin_layout Itemize
getScaledInstance(int newWidth, int newHeight) – Returns a scaled instance
 of this image.
 The arguments are the new dimensions for this image in pixels.
\end_layout

\begin_layout Itemize
scaledBy(double scaleX, double scaleY) – Returns a scaled instance of this
 image.
 The new dimensions are calculated based on this image's dimensions and
 the given proportions.
\end_layout

\begin_layout Itemize
getSmoothScaledInstance(int newWidth, int newHeight, int backColor) – Returns
 a scaled instance of this image.
 Transparent pixels are replaced by backColor, which produces a smooth border.
\end_layout

\begin_layout Itemize
smoothScaledBy(double scaleX, double scaleY, int backColor) – Returns a
 scaled instance of this image.
 The new dimensions are calculated based on this image's dimensions and
 the given proportions.
 Transparent pixels are replaced by backColor, which produces a smooth border.
\end_layout

\begin_layout Itemize
getRotatedScaledInstance(int scale, int angle, int fillColor) – Returns
 a rotated and/or scaled version of this image.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
Do not use this method for scaling only, because the scaling methods are
 faster.
 If you need a smooth scale and rotate, scale it first with smoothScaledBy
 or getSmoothScaledInstance and rotate it without scaling (or vice-versa).
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
getTouchedUpInstance(byte brightness, byte contrast) – Returns a touched-up
 instance of this image with the specified brightness and contrast.
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
The methods getSmoothScaledInstance and smoothScaleBy uses the area averaging
 algorithm, instead of the replication algorithm used by scaleBy and getScaledIn
stance.
 Although slower, the area averaging algorithm provides better results.
 You may now create only 320x320 images for your application, and smoothly
 resizes it to the target resolution, instead of providing one image per
 resolution.
\end_layout

\begin_layout Plain Layout
Images with anti-aliased borders produce better results because of the extra
 argument for the background color.
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
And finally, to save your image object, you may use one of the methods below:
\end_layout

\begin_deeper
\begin_layout Itemize
createPng(Stream s) – Attempts to write this image as a 24bpp PNG file on
 the given stream.
\end_layout

\begin_layout Itemize
saveTo(PDBFile cat, String name) – Writes this image as a 24bpp PNG file
 on the currently selected record of the given PDBFile, using the given
 name.
\end_layout

\end_deeper
\begin_layout Standard
Here's an example of how to create buttons for several resolutions based
 on a 320x320 images: (adapted from UIGadgets sample)
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public void initUI()
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	setTitle("ImageButton resolution scale");
\end_layout

\begin_layout Plain Layout

	String[] imageNames = {"clear.gif", "go.gif"};
\end_layout

\begin_layout Plain Layout

	int imgRes = 320;
\end_layout

\begin_layout Plain Layout

	int targetRes[] = {160, 176, 240, 320};
\end_layout

\begin_layout Plain Layout

	int backColor = getBackColor();
\end_layout

\begin_layout Plain Layout

	int coordX = LEFT;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	try
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		for (int i = imageNames.length - 1; i >= 0; i--)
\end_layout

\begin_layout Plain Layout

		{
\end_layout

\begin_layout Plain Layout

			Image img = new Image(imageNames[i]);
\end_layout

\begin_layout Plain Layout

			int imgWidth = img.getWidth();
\end_layout

\begin_layout Plain Layout

			int coordY = TOP;
\end_layout

\begin_layout Plain Layout

			for (int j = targetRes.length - 1; j >= 0; j--)
\end_layout

\begin_layout Plain Layout

			{
\end_layout

\begin_layout Plain Layout

				double factor = (double) targetRes[j] / (double) imgRes;
\end_layout

\begin_layout Plain Layout

				Image img2 = img.smoothScaledBy(factor, factor, backColor);
\end_layout

\begin_layout Plain Layout

				Button btn = new Button(img2);
\end_layout

\begin_layout Plain Layout

				btn.setBorder(Button.BORDER_NONE);
\end_layout

\begin_layout Plain Layout

				add(btn, coordX, coordY);
\end_layout

\begin_layout Plain Layout

				coordY += img2.getHeight() + 5;
\end_layout

\begin_layout Plain Layout

			}
\end_layout

\begin_layout Plain Layout

			coordX += imgWidth + 5;
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	catch (Exception e)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		MessageBox.showException(e, true);
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Another example with an animated GIF: (adapted from GifAnimatedTest sample)
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public void initUI()
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	try
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		img = new Image("alligator.gif");
\end_layout

\begin_layout Plain Layout

		imgCtrl = new ImageControl(img);
\end_layout

\begin_layout Plain Layout

		add(imgCtrl, CENTER, CENTER);
\end_layout

\begin_layout Plain Layout

		addTimer(200);
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	catch (Exception e)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

	MessageBox.showException(e, true);
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

public void onEvent(Event event)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	if (event.type == TimerEvent.TRIGGERED)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		img.nextFrame();
\end_layout

\begin_layout Plain Layout

		imgCtrl.repaintNow();
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Part
UTILITY CLASSES
\end_layout

\begin_layout Chapterstar
Overview
\end_layout

\begin_layout Standard
This section covers utility classes to deal with date and time, random number
 generation, data structures, logging and conversions.
\end_layout

\begin_layout Chapter
totalcross.util
\end_layout

\begin_layout Section
Date
\end_layout

\begin_layout Standard
The Date class is a general date data type implementation of the Gregorian
 Calendar, and supports dates from January 1st, 1000 to December 31st, 2999.
\end_layout

\begin_layout Standard
It also provides constants and methods for date manipulation and comparison.
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="13" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Months
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Date.JANUARY
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Date.FEBRUARY
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Date.MARCH
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Date.APRIL
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Date.MAY
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Date.JUNE
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Date.JULY
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Date.AUGUST
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Date.SEPTEMBER
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Date.OCTOBER
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Date.NOVEMBER
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Date.DECEMBER
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset space \hspace{}
\length 20line%
\end_inset


\begin_inset Tabular
<lyxtabular version="3" rows="8" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Days of week
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Date.SUNDAY
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Date.MONDAY
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Date.TUESDAY
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Date.WEDNESDAY
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Date.THURSDAY
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Date.FRIDAY
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Date.SATURDAY
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Itemize
Date has six constructors:
\end_layout

\begin_deeper
\begin_layout FieldList
\labelwidthstring 0

\family typewriter
Date()
\family default
 Creates a Date object set with today's date.
\end_layout

\begin_layout FieldList
\labelwidthstring 0

\family typewriter
Date(int
\begin_inset space ~
\end_inset

sentDate)
\family default
 Creates a Date object using the given value, which must be in the format
 YYYYMMDD.
\end_layout

\begin_layout FieldList
\labelwidthstring 0

\family typewriter
Date(int
\begin_inset space ~
\end_inset

sentDay,
\begin_inset space ~
\end_inset

int
\begin_inset space ~
\end_inset

sentMonth,
\begin_inset space ~
\end_inset

int
\begin_inset space ~
\end_inset

sentYear)
\family default
 Creates a Date object using the given values.
\end_layout

\begin_layout FieldList
\labelwidthstring 0

\family typewriter
Date(String
\begin_inset space ~
\end_inset

strDate) 
\family default
Creates a Date object with the given strDate, which must be a valid date
 in the current device date format (See Settings.dateFormat).
 The date separator can be any non-number character, the constructor auto-detect
s what character is being used as separator.
\end_layout

\begin_layout FieldList
\labelwidthstring 0

\family typewriter
Date(String
\begin_inset space ~
\end_inset

strDate,
\begin_inset space ~
\end_inset

byte
\begin_inset space ~
\end_inset

dateFormat) 
\family default
Creates a Date object with the given strDate, which must be a valid date
 in the given dateFormat.
 The argument dateFormat must be one of the Settings.DATE_XXX constants.
\end_layout

\begin_layout FieldList
\labelwidthstring 0

\family typewriter
Date(Time
\begin_inset space ~
\end_inset

t) 
\family default
Creates a date object using the given Time object (See Time).
\end_layout

\begin_layout Standard
Except for the default constructor, all Date constructors may throw the
 checked exception InvalidDateException.
\end_layout

\end_deeper
\begin_layout Itemize
Date objects can be manipulated in a simple way with the following methods:
\end_layout

\begin_deeper
\begin_layout FieldList
\labelwidthstring 0
advance(int
\begin_inset space ~
\end_inset

numberDays) Advances (or regresses if numberDays is negative) the date by
 the given value.
\end_layout

\begin_layout FieldList
\labelwidthstring 0
advanceMonth() Advances the date to the beginning of the next month.
\end_layout

\begin_layout FieldList
\labelwidthstring 0
advanceMonth(boolean
\begin_inset space ~
\end_inset

direction) Changes the date to the beginning of the next or previous month.
\end_layout

\begin_layout FieldList
\labelwidthstring 0
advanceWeek() Advances the date to the beginning of the next week.
 
\end_layout

\begin_layout FieldList
\labelwidthstring 0
advanceWeek(boolean
\begin_inset space ~
\end_inset

direction) Changes the date to the beginning of the next or previous week.
\end_layout

\begin_layout FieldList
\labelwidthstring 0
setToday() Sets this date object to the current day.
\end_layout

\end_deeper
\begin_layout Itemize
Date objects can be easily compared using the following methods:
\end_layout

\begin_deeper
\begin_layout FieldList
\labelwidthstring 0
isAfter(Date
\begin_inset space ~
\end_inset

sentDate) Returns true if sentDate is after this date object.
\end_layout

\begin_layout FieldList
\labelwidthstring 0
isBefore(Date
\begin_inset space ~
\end_inset

sentDate) Returns true if sentDate is before this date object.
\end_layout

\begin_layout FieldList
\labelwidthstring 0
equals(Object
\begin_inset space ~
\end_inset

sentDate) Returns true if sentDate represents the same date as this date
 object.
\end_layout

\begin_layout FieldList
\labelwidthstring 0
compareTo(Object
\begin_inset space ~
\end_inset

other) Implementation of the Comparable interface.
 Return is > 0 if this object is greater than the other one, < 0 if its
 smaller, and 0 if they are equal.
\end_layout

\begin_layout Standard
You can get the difference in days between two dates using the method subtract(D
ate other).
 (other – this).
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
Never use subtract to compare dates.
 Using subtract to compare dates can be 15 times slower than using one of
 the above methods, like compareTo.
 Use subtract only when you need to know the exact difference between two
 dates.
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
The following methods can be used to retrieve information about the set
 date:
\end_layout

\begin_deeper
\begin_layout Itemize
getDay() - Returns the day.
\end_layout

\begin_layout Itemize
getMonth() - Returns the month.
\end_layout

\begin_layout Itemize
getYear() - Returns the year.
\end_layout

\begin_layout Itemize
getDayOfWeek() - Returns the day of week, where 0 is Sunday and 6 is Saturday.
\end_layout

\begin_layout Itemize
getWeek() - Calculates and returns the ordinal value of the week (1-52).
\end_layout

\begin_layout Itemize
getDateInt() - Returns an integer representing the date in the format YYYYMMDD.
\end_layout

\begin_layout Itemize
getDaysInMonth() - Returns the number of days the set month has.
\end_layout

\begin_layout Itemize
getDaysInMonth(int month) – Returns the number of days in the given month
 of the set year.
\end_layout

\begin_layout Itemize
getGregorianDay() - Returns the number of days since the January 1st of
 the epoch year 1000.
\end_layout

\end_deeper
\begin_layout Itemize
You can also retrieve the date as a String:
\end_layout

\begin_deeper
\begin_layout Itemize
formatDayMonth() - Returns a zero padded String representation of the day
 and month, using the current device settings (see Settings.dateFormat).
\end_layout

\begin_layout Itemize
getDate() - Returns a String representation of the date using the current
 device settings (see Settings.dateFormat).
\end_layout

\begin_layout Itemize
toString() - Returns a String representation of the date using the current
 device settings (see Settings.dateFormat).
\end_layout

\begin_layout Itemize
toString(byte format) - Returns a String representation of the date using
 the given format, which must be one of the Settings.DATE_XXX constants.
\end_layout

\end_deeper
\begin_layout Itemize
The Date class provides a few static utility methods:
\end_layout

\begin_deeper
\begin_layout Itemize
getMonthName(int m) – Returns the String representation of the given month.
\end_layout

\begin_layout Itemize
getDaysInMonth(int month, int year) – Returns the number of days the given
 month and year.
\end_layout

\begin_layout Itemize
formatDate(int day, int month, int year) – Returns the String representation
 of the given date (zero padded) using the current device settings (See
 Settings.dateFormat).
\end_layout

\begin_layout Itemize
formatDate(int day, int month, int year, byte dateFormat) – Returns the
 String representation of the given date (zero padded) using the specified
 dateFormat, which must be one of the Settings.DATE_XXX constants.
\end_layout

\end_deeper
\begin_layout Standard
Sample code:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Date PaulBorn = null;
\end_layout

\begin_layout Plain Layout

Date DavidBorn = null;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

try
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	PaulBorn = new Date(23, 12, 1960);
\end_layout

\begin_layout Plain Layout

	DavidBorn = new Date(20, 7, 1978);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

catch (InvalidDateException e)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	MessageBox.showException(e, true);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

new MessageBox("Paul was born in " + Date.getMonthName(PaulBorn.getMonth())).popup(
);
\end_layout

\begin_layout Plain Layout

if (PaulBorn.isAfter(DavidBorn))
\end_layout

\begin_layout Plain Layout

	new MessageBox("David is older than Paul").popup();
\end_layout

\begin_layout Plain Layout

else
\end_layout

\begin_layout Plain Layout

	new MessageBox("Paul is older than David").popup();
\end_layout

\begin_layout Plain Layout

PaulBorn.setToday(); /* Now, Paul has just been born */
\end_layout

\end_inset


\end_layout

\begin_layout Section
Vector
\end_layout

\begin_layout Standard
The Vector class implements a growable array of objects.
 Like an array, it contains components that can be accessed using an integer
 index.
 However, the size of a Vector can dynamically grow as needed.
\end_layout

\begin_layout Standard
In Java you cannot directly access the Vector's internal array, you must
 use its methods to insert, remove, retrieve or replace elements in a Vector.
 This way the programmer cannot accidentally (or intentionally) corrupt
 the object's internal state.
\end_layout

\begin_layout Standard
Unfortunately this makes Vector iteration a very costly operation, because
 each iteration requires at least one method call.
\end_layout

\begin_layout Standard
To avoid this performance issue, TotalCross' Vector implementation allows
 public access to its internal array.
 However, to guarantee the Vector's integrity
\emph on
 you must only access it to retrieve (get) or replace (set) elements, and
 never to insert, remove, or resize the buffer
\emph default
.
\end_layout

\begin_layout Standard
You may also use a Vector as a Stack, this feature is better explained below.
\end_layout

\begin_layout Itemize
Vector has three constructors:
\end_layout

\begin_deeper
\begin_layout Itemize
Vector() - Default constructor, creates a Vector with the default size 8.
 This constructor should be avoided.
\end_layout

\begin_layout Itemize
Vector(int size) – Creates a Vector with the given size, which cannot be
 negative (minimum size is 0).
\end_layout

\begin_layout Itemize
Vector(Object[] startingWith) – Creates a Vector, assigning the given array
 as the internal buffer and its size as the Vector size.
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
Please notice this constructor uses the given array as internal buffer,
 not a copy.
 So you should not use this array after initializing the Vector with it.
 If you want to initialize the Vector with a copy of the array, use Vm.arrayCopy,
 or for String arrays, Convert.cloneStringArray.
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
To add an element to a vector, you may use:
\end_layout

\begin_deeper
\begin_layout Itemize
addElement(Object obj) – Adds a reference to the given object to the end
 of this vector.
\end_layout

\begin_layout Itemize
insertElementAt(Object obj, int index) – Inserts a reference to the given
 object at the specified index of this vector, shifting elements with index
 greater or equal to the specified index to have an index one greater than
 it had previously.
\end_layout

\end_deeper
\begin_layout Itemize
And to remove:
\end_layout

\begin_deeper
\begin_layout Itemize
removeElement(Object obj) – Removes the reference of the given object from
 this vector, shifting elements with index greater than the specified index
 to have an index one smaller than it had previously.
\end_layout

\begin_layout Itemize
removeElementAt(int index) – Removes the reference to the object at the
 given index of this vector, shifting elements with index greater than the
 specified index to have an index one smaller than it had previously.
\end_layout

\begin_layout Itemize
removeAllElements() - Removes all elements from this vector, reseting its
 length to 0.
\end_layout

\end_deeper
\begin_layout Itemize
To find the index of a vector's element:
\end_layout

\begin_deeper
\begin_layout Itemize
indexOf(Object obj, int startIndex) – Returns the index of the given object,
 or -1 if the object is not found.
 The array is searched using a O(n) linear search, starting at the given
 startIndex, until the object is found or the end of the array is reached.
\end_layout

\begin_layout Itemize
indexOf(Object obj) – Like the above, but always start the search at the
 first position (index 0).
 In fact its implementation consists of a single method call: indexOf(obj,
 0).
\end_layout

\end_deeper
\begin_layout Itemize
Vector also provides the following handy methods:
\end_layout

\begin_deeper
\begin_layout Itemize
isEmpty() - Returns true if this vector is empty.
\end_layout

\begin_layout Itemize
size() - Returns the number of elements in this vector.
\end_layout

\begin_layout Itemize
setSize(int newSize) – Sets the size of this vector.
 If the new size is greater than the current size, new null items are added
 to the end of the vector.
 If the new size is less than the current size, all components at index
 newSize and greater are discarded.
\end_layout

\begin_layout Itemize
qsort() - Sorts the elements of this vector.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
If the elements are Strings, the sort will be faster because a cast to String
 will be done.
 Otherwise, it will use the method toString() to get a String representation
 of the object to use on the sort.
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
toObjectArray() - Returns an array of objects containing all elements of
 this vector, or null if the vector is empty.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
If the first element of this vector is a String, it will assume all elements
 are of the same type and create a String array instead of an Object array.
 In this case, you may safely cast the return from Object[] to String[].
 This is only valid for Strings.
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
dump() - Dumps the contents of this vector, returning a String representation
 of it.
 
\end_layout

\end_deeper
\begin_layout Itemize
To use a vector as a stack, you may use the following methods:
\end_layout

\begin_deeper
\begin_layout Itemize
push(Object obj) – Pushes an item onto the top of this stack.
 It actually just calls the method addElement passing the given object.
\end_layout

\begin_layout Itemize
pop() - Removes the object at the top of this stack, returning that object.
 
\end_layout

\begin_layout Itemize
peek() - Returns the object the object at the top of this stack without
 removing it.
\end_layout

\end_deeper
\begin_layout Standard
Although the Vector can grow to accommodate more elements, this is a costly
 operation that should be avoided.
 Keep in mind the following when using Vectors:
\end_layout

\begin_layout Itemize
If you can estimate the number of elements, you can create the Vector with
 enough room for them:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

// we expect at least 1000 elements
\end_layout

\begin_layout Plain Layout

Vector v = new Vector(1100) // a little extra space just in case
\end_layout

\begin_layout Plain Layout

Foo f;
\end_layout

\begin_layout Plain Layout

while ((f != getNextFoo()) != null)
\end_layout

\begin_layout Plain Layout

	v.addElement(f);
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
If you know the exact number of elements, you can create an array and initialize
 the Vector with this array:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

// we can get the exact number of elements we'll receive
\end_layout

\begin_layout Plain Layout

int fooCount = getFooCount();
\end_layout

\begin_layout Plain Layout

Foo[] f = new Foo[fooCount];
\end_layout

\begin_layout Plain Layout

for (int i = 0 ; i < fooCount ; i++)
\end_layout

\begin_layout Plain Layout

	f[i] = getNextFoo();
\end_layout

\begin_layout Plain Layout

Vector v = new Vector(f);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
Use this approach only when you know the initial number of elements is not
 too low and you do not expect to make several insertions later.
 Otherwise the Vector may need to grow several times, decreasing the performance.
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
The Vector growth rate is 20% + 1 on device (100% + 1 on Java), so you should
 avoid using the default constructor (the default size is 8) or initializing
 the Vector with less than 20 positions.
\end_layout

\begin_layout Itemize
The Vector does not shrinks automatically.
 If you make several inserts followed by even more removals, you may end
 up with a huge Vector consuming more memory than it actually needs.
 (IE.
 After the inserts the Vector ends up with 1200 positions but after the
 removals only 500 positions are actually being used).
\end_layout

\begin_layout Section
IntVector
\end_layout

\begin_layout Standard
The IntVector is a growable array of integers.
 It's a Vector implementation specific for integers, which provides better
 performance and takes less memory than using Vector to hold only integers.
\end_layout

\begin_layout Standard
For efficiency, IntVector was implemented exactly like Vector: It also allows
 public access to its internal array, but 
\emph on
you must only access it to retrieve (get) or replace (set) elements, and
 never to insert, remove, or resize the buffer
\emph default
.
\end_layout

\begin_layout Standard
Like the Vector, the IntVector may also be used as a Stack (an IntStack
 in this case).
 It can also be used as a bit array.
 These features are better described below.
 
\end_layout

\begin_layout Itemize
IntVector has three constructors:
\end_layout

\begin_deeper
\begin_layout Itemize
IntVector() - Default constructor, creates an IntVector with the default
 size 20.
\end_layout

\begin_layout Itemize
IntVector(int size) – Creates an IntVector with the given size, which cannot
 be negative (minimum size is 0).
\end_layout

\begin_layout Itemize
IntVector(int[] items) – Creates an IntVector, assigning the given array
 as the internal buffer and its size as the an IntVector size.
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
Please notice this constructor uses the given array as internal buffer,
 not a copy.
 So you should not use this array after initializing the IntVector with
 it.
 If you want to initialize the IntVector with a copy of the array, use Vm.arrayCo
py.
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
To add an element to an intVector, you may use:
\end_layout

\begin_deeper
\begin_layout Itemize
addElement(int item) – Adds the given integer to the end of this intVector.
\end_layout

\begin_layout Itemize
insertElementAt(int item, int index) – Inserts the given integer at the
 specified index of this intVector, shifting elements with index greater
 or equal to the specified index to have an index one greater than it had
 previously.
\end_layout

\end_deeper
\begin_layout Itemize
And to remove:
\end_layout

\begin_deeper
\begin_layout Itemize
removeElement(int item) – Removes the given integer from this intVector,
 shifting elements with index greater than the specified index to have an
 index one smaller than it had previously.
\end_layout

\begin_layout Itemize
removeElementAt(int index) – Removes the integer at the given index of this
 intVector, shifting elements with index greater than the specified index
 to have an index one smaller than it had previously.
\end_layout

\begin_layout Itemize
removeAllElements() - Removes all elements from this intVector, reseting
 its length to 0.
\end_layout

\end_deeper
\begin_layout Itemize
To find the index of an element of this intVector:
\end_layout

\begin_deeper
\begin_layout Itemize
indexOf(int item, int startIndex) – Returns the index of the given integer,
 or -1 if the integer is not found.
 The array is searched using a O(n) linear search, starting at the given
 startIndex, until the integer is found or the end of the array is reached.
\end_layout

\begin_layout Itemize
indexOf(int item) – Like the above, but always start the search at the first
 position (index 0).
 In fact its implementation consists of a single method call: indexOf(item,
 0).
\end_layout

\end_deeper
\begin_layout Itemize
IntVector also provides the following handy methods:
\end_layout

\begin_deeper
\begin_layout Itemize
isEmpty() - Returns true if this intVector is empty.
\end_layout

\begin_layout Itemize
size() - Returns the number of elements in this intVector.
\end_layout

\begin_layout Itemize
qsort() - Sorts the elements of this intVector.
\end_layout

\begin_layout Itemize
toIntArray() - Returns an array of integers containing all elements of this
 intVector.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
Unlike Vector.toObjectArray, the method toIntArray does not returns null
 if the IntVector is empty.
 It always returns an int array, which may contain elements or not.
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
setSize(int newSize) – Sets the size of this vector.
 If the new size is greater than the current size, new items are added to
 the end of the vector.
 If the new size is less than the current size, all components at index
 newSize and greater are discarded.
\end_layout

\end_deeper
\begin_layout Itemize
To use an IntVector as a stack, you may use the following methods:
\end_layout

\begin_deeper
\begin_layout Itemize
push(int item) – Pushes an item onto the top of this stack.
 It actually just calls the method addElement passing the given integer.
\end_layout

\begin_layout Itemize
pop() - Removes the item at the top of this stack, returning that integer.
 
\end_layout

\begin_layout Itemize
pop(int howMany) - Removes the desired number of items from the top of this
 stack.
 Unlike the previous method, nothing is returned.
\end_layout

\begin_layout Itemize
peek() - Returns the item at the top of this stack without removing it.
\end_layout

\end_deeper
\begin_layout Standard
When we want to deal with bit values, we usually use a boolean array.
 However, each position of a boolean array takes 1 byte of memory instead
 of 1 bit.
 This can be a problem when you need to deal with large arrays of bits.
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
A single boolean variable is stored in memory as an integer, which costs
 4 bytes.
 But in a boolean array, each position takes 1 byte instead of 4 bytes.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
As an alternative, you may use the IntVector as a a real bit array using
 the provided methods and save a lot of memory.
 But there is a drawback: the internal array does not grow by itself when
 you try to access an index bigger than the array's size.
 So you must make sure the IntVector is large enough to hold the number
 of bits you want to manipulate, otherwise you may get an ArrayIndexOutOfBoundsE
xception.
\end_layout

\begin_layout Itemize
The IntVector provides the following methods to be used as a bit array:
\end_layout

\begin_deeper
\begin_layout Itemize
ensureBit(int sizeInBits) – Makes sure the intVector is large enough to
 hold the given number of bits.
 You should always call this method before using it as a bit array.
\end_layout

\begin_layout Itemize
setBit(int index, boolean on) – Sets the bit at the given index if on is
 true.
\end_layout

\begin_layout Itemize
isBitSet(int index) – Returns true if the bit at the given index is set.
\end_layout

\end_deeper
\begin_layout Standard
Sample code of the IntVector as a bit array:
\end_layout

\begin_layout Itemize
We need to hold 40000 bits, let's do it with a boolean array:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

boolean[] bitArray = new boolean[40000]; // That's 40000 bytes
\end_layout

\begin_layout Plain Layout

bitArray[5] = true; // easy to set a bit, just use the index.
\end_layout

\begin_layout Plain Layout

boolean aux = bitArray[5]; // easy to get a bit.
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Now using a IntVector:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

IntVector bitVector = new IntVector();
\end_layout

\begin_layout Plain Layout

// First we make sure the array is large enough.
\end_layout

\begin_layout Plain Layout

bitVector.ensureBits(40000); 
\end_layout

\begin_layout Plain Layout

// This time our array uses only 8000 bytes.
\end_layout

\begin_layout Plain Layout

bitVector.setBit(5, true); // just as easy to set
\end_layout

\begin_layout Plain Layout

boolean aux = bitVector.isBitSet(5); // just as easy to get.
\end_layout

\end_inset


\end_layout

\begin_layout Section
Hashtable
\end_layout

\begin_layout Standard
This class implements a hash table, which is a data structure that associates
 keys with values.
 It's primary operation is a lookup: given a key, find the corresponding
 value.
 It works by transforming the key into a hash using the method hashCode()
 (inherited from Object), which is then used as an index for the hash table.
\end_layout

\begin_layout Standard
Hash tables should be used when the number of search operations greatly
 supersedes the number of insertions.
\end_layout

\begin_layout Standard
Any non-null object can be used as a key or as a value, optionally, you
 can provide your own hash code instead of providing a key from which the
 hash code will be calculated..
\end_layout

\begin_layout Itemize
Hashtable has two important constructors:
\end_layout

\begin_deeper
\begin_layout Itemize
Hashtable(int initialCapacity) – Creates an empty hash table with the specified
 initial capacity.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
The argument initialCapacity's value should be the final number of entries
 in the hash table to avoid rehashing.
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Hashtable(String res) – Creates a new hash table parsing the elements from
 the given String.
 The String must be in the form: key = value, split in lines (
\backslash
n).
\end_layout

\end_deeper
\begin_layout Itemize
The insert a new entry on the hash table:
\end_layout

\begin_deeper
\begin_layout Itemize
put(Object key, Object value) – Maps the given value to the hash code of
 the given key.
\end_layout

\begin_layout Itemize
put(int hash, Object value) – Maps the given value to the given hash.
\end_layout

\begin_layout Standard
If the given hash (or key's hash code) already exists in the hash table,
 the old value will be replaced by the given value and the put method will
 return the old value.
 Otherwise, a null value will be returned.
\end_layout

\end_deeper
\begin_layout Itemize
To test if a key is already mapped in the hash table, use the method exists(Obje
ct key).
\end_layout

\begin_layout Itemize
To retrieve a value from a hash table:
\end_layout

\begin_deeper
\begin_layout Itemize
get(Object key) - Returns the value to which the specified key is mapped
 in this hash table.
\end_layout

\begin_layout Itemize
get(int hash) - Returns the value to which the specified hash is mapped
 in this hash table.
\end_layout

\end_deeper
\begin_layout Itemize
To retrieve all values and/or keys from a hash table:
\end_layout

\begin_deeper
\begin_layout Itemize
getKeys() - Returns a Vector with all the keys in this hash table.
\end_layout

\begin_layout Itemize
getValues() - Returns a Vector with all the values in this hash table.
\end_layout

\begin_layout Itemize
getKeyValuePairs(String separator) – Returns a Vector with all the key/value
 pairs in the form key + separator + value.
\end_layout

\end_deeper
\begin_layout Itemize
The method size() returns the number of keys in this hash table.
\end_layout

\begin_layout Itemize
To remove a key and its corresponding value from this hash table, use remove(Obj
ect key).
\end_layout

\begin_layout Itemize
To clear this hash table, removing all its entries, use clear().
\end_layout

\begin_layout Standard
This example creates a hash table of numbers.
 It uses the name of the numbers as keys:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Hashtable numbers = new Hashtable(13);
\end_layout

\begin_layout Plain Layout

numbers.put("one", Convert.toString(1));
\end_layout

\begin_layout Plain Layout

numbers.put("two", Convert.toString(2));
\end_layout

\begin_layout Plain Layout

numbers.put("three",Convert.toString(3));
\end_layout

\end_inset


\end_layout

\begin_layout Standard
To retrieve a number, use the following code:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

String n = (String) numbers.get("two");
\end_layout

\begin_layout Plain Layout

if (n != null)
\end_layout

\begin_layout Plain Layout

	new MessageBox("two = " + Convert.toInt(n)).popup(); 
\end_layout

\end_inset


\end_layout

\begin_layout Section
IntHashtable
\end_layout

\begin_layout Standard
This class implements a hash table where both the keys and values inserted
 must be integers.
\end_layout

\begin_layout Itemize
IntHashtable has a important constructor:
\end_layout

\begin_deeper
\begin_layout Itemize
IntHashtable(int initialCapacity) – Creates an empty hash table with the
 specified initial capacity, which should be the final number of entries
 in the hash table to avoid rehashing.
\end_layout

\end_deeper
\begin_layout Itemize
The insert a new entry on the hash table:
\end_layout

\begin_deeper
\begin_layout Itemize
put(int key, int value) – Maps the given value to the given key.
\end_layout

\begin_layout Standard
If the given hash (or key's hash code) already exists in the hash table,
 the old value will be replaced by the given value and the put method will
 return the old value.
 Otherwise, the given value will be returned.
\end_layout

\end_deeper
\begin_layout Itemize
To test if a key is already mapped in the hash table, use the method exists(int
 key).
\end_layout

\begin_layout Itemize
To retrieve a value from a hash table:
\end_layout

\begin_deeper
\begin_layout Itemize
get(int key) - Returns the value to which the specified key is mapped in
 this hash table.
\end_layout

\begin_layout Itemize
get(int key, int def) - Returns the value to which the specified key is
 mapped in this hash table, or the given default value (def) if the key
 is not found.
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
Make sure you choose value for def that is never inserted as a value in
 the hash table, otherwise the return value of this method may be treated
 as a false negative (IE.
 The key maps to a value equals to the given def, thus, if you test if the
 return is not equals to def to check if the key was found, the result will
 be a false negative.)
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
To retrieve all keys and values from a hash table:
\end_layout

\begin_deeper
\begin_layout Itemize
getKeys() - Returns a IntVector with all the keys in this hash table.
\end_layout

\begin_layout Itemize
getValues() - Returns a IntVector with all the values in this hash table.
\end_layout

\end_deeper
\begin_layout Itemize
You may use the method getKey(int pos) to retrieve the key at the given
 position (pos).
 An ArrayIndexOutOfBoundsException is thrown if the given position is out
 of range.
\end_layout

\begin_layout Itemize
The method size() returns the number of keys in this hash table.
\end_layout

\begin_layout Itemize
To remove a key and its corresponding value from this hash table, use remove(int
 key).
\end_layout

\begin_layout Itemize
To clear this hash table, removing all its entries, use clear().
\end_layout

\begin_layout Standard
This example creates a small hash table of numbers:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

IntHashtable numbers = new IntHashtable(10);
\end_layout

\begin_layout Plain Layout

numbers.put(1, 1000);
\end_layout

\begin_layout Plain Layout

numbers.put(2, 2000);
\end_layout

\begin_layout Plain Layout

numbers.put(3, 3000);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
To retrieve a number, use the following code:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

try
\end_layout

\begin_layout Plain Layout

{ 
\end_layout

\begin_layout Plain Layout

	int i = numbers.get(2);
\end_layout

\begin_layout Plain Layout

	new MessageBox("two = " + i).popup();
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

catch(ElementNotFoundException e)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	MessageBox.showException(e, true);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Properties
\end_layout

\begin_layout Standard
Properties can be used to store properties pairs (key, value) using a hash
 table.
 Currently, the key must be a String and the value must be an instance of
 Properties.Value.
\end_layout

\begin_layout Standard
The properties can be saved and loaded to/from a DataStream.
\end_layout

\begin_layout Itemize
Properties has the following constructors:
\end_layout

\begin_deeper
\begin_layout Itemize
Properties() - Default constructor, creates an empty Properties object.
\end_layout

\begin_layout Itemize
Properties(String[] keys, Properties.Value[] values) – Creates a Properties
 object, storing the given keys/values pairs.
\end_layout

\end_deeper
\begin_layout Itemize
The following methods are provided to handle a Properties objects and its
 entries:
\end_layout

\begin_deeper
\begin_layout Itemize
put(String key, Properties.Value v) – Maps the given value to the given key
 in this properties.
\end_layout

\begin_layout Itemize
get(String key) – Returns the value which the given key is mapped to in
 this properties.
\end_layout

\begin_layout Itemize
remove(String key) - Remove the value mapped to the given key from the property.
\end_layout

\begin_layout Itemize
size() - Returns the number of properties stored.
\end_layout

\begin_layout Itemize
getKeys() - Returns a Vector with the current keys.
\end_layout

\begin_layout Itemize
clear() - Clears this properties.
\end_layout

\end_deeper
\begin_layout Itemize
To load or save data directly from/to a DataStream:
\end_layout

\begin_layout Itemize
load(DataStream ds) - Load all properties from the given DataStream.
 
\end_layout

\begin_layout Itemize
save(DataStream ds) - Save all properties in the given DataStream.
 
\end_layout

\begin_layout Standard
To store a value in Properties, you must extend the abstract class Properties.Val
ue and implement the method toString().
\end_layout

\begin_layout Itemize
The following classes are already implemented on the SDK:
\end_layout

\begin_deeper
\begin_layout Itemize
Properties.Boolean - Implements a value of type boolean.
\end_layout

\begin_layout Itemize
Properties.Double - Implements a value of type double.
\end_layout

\begin_layout Itemize
Properties.Int - Implements a value of type int.
\end_layout

\begin_layout Itemize
Properties.Long - Implements a value of type long.
\end_layout

\begin_layout Itemize
Properties.Str - Implements a value of type String.
\end_layout

\end_deeper
\begin_layout Section
Random
\end_layout

\begin_layout Standard
This is a simple Linear Congruential Generator which produces random numbers
 in the range 
\begin_inset Formula $\left[0,2^{31}\right)$
\end_inset

, derived from ran0 in Numerical Recipes.
 Note that ran0 isn't that great – there are much better generators out
 there -- but it is fast and has low memory consumption, and it will do
 the job.
\end_layout

\begin_layout Itemize
Random has the following constructors:
\end_layout

\begin_deeper
\begin_layout Itemize
Random() - Default constructor, creates a Random instance using a seed based
 on the timestamp.
\end_layout

\begin_layout Itemize
Random(int seed) – Creates a Random object using the given seed.
 The only reasonable seeds are between 0 and 231 inclusive.
 If a negative value is received, its absolute value will be used.
\end_layout

\end_deeper
\begin_layout Itemize
The class has only 4 simple methods:
\end_layout

\begin_deeper
\begin_layout Itemize
nextInt(int n) - Returns a random integer in the range [0,n).
\end_layout

\begin_layout Itemize
nextDouble() - Returns a random double in the half-open range [0,1).
 
\end_layout

\begin_layout Itemize
between(int s, int e) - Returns a random integer in the given region.
\end_layout

\begin_layout Itemize
between(char s, char e) - Returns a random character in the given region.
 
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
You should only use one instance of Random, otherwise you might not get
 good values.
 Creating a new instance using always the same seed will always result on
 the same sequence of numbers.
\end_layout

\end_inset


\end_layout

\begin_layout Section
Logger
\end_layout

\begin_layout Standard
A Logger object is used to log messages for a specific system or application
 component.
 Loggers are usually named using a hierarchical dot-separated namespace.
 Logger names can be arbitrary strings, but they should usually be based
 on the package name or class name of the logged component, such as totalcross.ne
t or totalcross.io.
 In addition it is possible to retrieve one global "anonymous" Logger that
 can be used in the whole system.
 A logger can be created or retrieved (if it already exists) by getLogger.
 To dispose a logger after using it, just call dispose and it will be permanentl
y discarded.
 To log a message, you may call the log method or any of the other convenience
 methods (info, severe, entering, etc).
 
\end_layout

\begin_layout Itemize
First you must be familiar with the different message levels:
\end_layout

\begin_deeper
\begin_layout Itemize
CONFIG - Message level for static configuration messages.
\end_layout

\begin_layout Itemize
INFO - Message level for informational messages.
\end_layout

\begin_layout Itemize
FINE - Message level providing tracing information.
\end_layout

\begin_layout Itemize
FINER - Indicates a fairly detailed tracing message.
\end_layout

\begin_layout Itemize
FINEST - Indicates a highly detailed tracing message.
\end_layout

\begin_layout Itemize
WARNING - Message level indicating a potential problem.
\end_layout

\begin_layout Itemize
SEVERE - Message level indicating a serious failure.
\end_layout

\end_deeper
\begin_layout Itemize
You may get or set the Logger default settings with these static methods:
\end_layout

\begin_deeper
\begin_layout Itemize
getDefaultSeparator() - Returns the string used as initial message separator,
 which is used by new loggers.
\end_layout

\begin_layout Itemize
setDefaultSeparator(String separator) - Sets the initial message separator
 to be used by new loggers.
\end_layout

\begin_layout Itemize
getDefaultLevel() - Returns the initial logger level, which is used by new
 loggers.
\end_layout

\begin_layout Itemize
setDefaultLevel(int level) - Sets the initial logger level to be used by
 new loggers.
\end_layout

\end_deeper
\begin_layout Itemize
The Logger level may be one of the above message levels, or any composition
 of them ORed together.
 You may also use one of the following constants:
\end_layout

\begin_deeper
\begin_layout Itemize
ALL - Indicates that all messages should be logged.
\end_layout

\begin_layout Itemize
OFF - Special level that can be used to turn off logging.
\end_layout

\end_deeper
\begin_layout Itemize
To get a Logger, you may use one of the following static methods:
\end_layout

\begin_deeper
\begin_layout Itemize
getLogger(String name) - Returns the logger with the given name.
 If the logger does not exist, it will be created and stored for future
 use.
\end_layout

\begin_layout Itemize
getLogger(String name, int level) - Returns the logger with the given name,
 setting the specified level.
 If the logger does not exist, it will be created and stored for future
 use.
\end_layout

\begin_layout Itemize
getLogger(String name, int level, Stream outputStream) - Returns the logger
 with the given name, setting the level specified and optionally adding
 the given stream to the list of output handlers.
 If the logger does not exist, it will be created and stored for future
 use.
\end_layout

\begin_layout Itemize
getGlobalLogger() - Returns the global anonymous logger.
\end_layout

\end_deeper
\begin_layout Itemize
After getting a Logger instance, you may get or set its settings:
\end_layout

\begin_deeper
\begin_layout Itemize
getName() - Returns the name of this logger.
\end_layout

\begin_layout Itemize
getSeparator() - Returns the string used by this logger to separate log
 messages.
\end_layout

\begin_layout Itemize
setSeparator(String separator) - Sets the separator to be used by this logger.
\end_layout

\begin_layout Itemize
getLevel() - Returns the current level of this logger.
\end_layout

\begin_layout Itemize
setLevel(int level) - Sets the current level of this logger.
\end_layout

\end_deeper
\begin_layout Itemize
You must add a output handler to a logger, which is a stream object that
 will receive the log messages.
 A logger may have multiple output handlers.
\end_layout

\begin_deeper
\begin_layout Itemize
addOutputHandler(Stream output)- Adds an output stream to this logger's
 output handler set.
 Does nothing if the given Stream was previously added to this logger.
\end_layout

\begin_layout Itemize
getOutputHandlers() - Get the output handlers associated with this logger.
\end_layout

\begin_layout Itemize
removeOutputHandler(Stream output) - Removes an output handler from this
 logger's output handler set.
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
You may use the static field DEBUG_CONSOLE, which is a stream to the TotalCross'
 debug file.
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
The following methods can be used to help you trace the execution flow of
 your code and log exceptions:
\end_layout

\begin_deeper
\begin_layout Itemize
entering(String sourceClass, String sourceMethod, String params) - Logs
 a FINER message reporting a method entry.
\end_layout

\begin_layout Itemize
exiting(String sourceClass, String sourceMethod) - Logs a FINER message
 reporting a method return.
\end_layout

\begin_layout Itemize
throwing(String sourceClass, String sourceMethod, Throwable thrown) – Logs
 a SEVERE message reporting an exception being thrown.
\end_layout

\begin_layout Itemize
To log your own message, you may use:
\end_layout

\begin_layout Itemize
log(int level, String message, boolean prependInfo) – Logs the given message,
 using the given level.
 The last argument is a flag indicating whether this log message must be
 prepended with the current date and time, level string, logger name, etc.
\end_layout

\end_deeper
\begin_layout Itemize
Or one of the convenience methods, which are actually just calls to the
 method log using the given message, the appropriate level and the prependInfo
 flag always on:
\end_layout

\begin_deeper
\begin_layout Itemize
config(String message) - Logs a CONFIG message.
\end_layout

\begin_layout Itemize
info(String message) - Logs an INFO message.
\end_layout

\begin_layout Itemize
fine(String message) - Logs a FINE message.
\end_layout

\begin_layout Itemize
finer(String message) - Logs a FINER message.
\end_layout

\begin_layout Itemize
finest(String message) - Logs a FINEST message.
\end_layout

\begin_layout Itemize
warning(String message) - Logs a WARNING message.
\end_layout

\begin_layout Itemize
severe(String message) - Logs a SEVERE message.
\end_layout

\end_deeper
\begin_layout Itemize
Finally, you should dispose the logger and close all streams associated
 to the logger, unless its streams are still in use by the program.
\end_layout

\begin_deeper
\begin_layout Itemize
dispose(boolean closeOutputHandlers) - Permanently discards this logger,
 removing it from the loggers registry.
 If closeOutputHandlers is true, all streams associated to this logger are
 closed.
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
You shouldn't (and in fact you can't) dispose the global logger.
 Calling dispose for the global logger does not discards it, only adds an
 useless method call to your code.
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
totalcross.sys
\end_layout

\begin_layout Section
Time
\end_layout

\begin_layout Standard
The Time class stores a specific a date and time.
 The year must have 4 digits and the hour is numbered in 24-hour notation,
 which is the international standard notation of time, and may also be referred
 as military time or astronomical time.
\end_layout

\begin_layout Standard
For performance reasons, the Time fields have public access.
 So you can directly access the field day to get or set its value, instead
 of calling a method.
 However, that makes the Time objects unsafe because the fields' values
 are not checked when they are set, and may not be within the field valid
 range.
\end_layout

\begin_layout Standard
Since the fields can be set without any kind of validation, it would be
 pointless to add validation to the other methods, therefore, 
\emph on
the Time fields' values are never validated by any method or constructor
\emph default
.
 So you must know and always respect the fields' range, and never set a
 field with a variable without first checking if the value is withing range
 (for instance, let the user type the hour in an Edit and simply convert
 it to int and set the hour field, without checking if its value is between
 0 and 23).
\end_layout

\begin_layout Itemize
The Time fields with their respective range:
\end_layout

\begin_deeper
\begin_layout Itemize
year – The year in 4 digits.
\end_layout

\begin_layout Itemize
month – The month in the range of 1 to 12.
\end_layout

\begin_layout Itemize
day – The day in the range of 1 to the last day of the specified month.
\end_layout

\begin_layout Itemize
hour – The hour in the range of 0 to 23.
\end_layout

\begin_layout Itemize
minute – The minute in the range of 0 to 59.
\end_layout

\begin_layout Itemize
second – The second in the range of 0 to 59.
\end_layout

\begin_layout Itemize
millis – Milliseconds in the range of 0 to 999.
\end_layout

\end_deeper
\begin_layout Itemize
Time has four constructors:
\end_layout

\begin_deeper
\begin_layout Itemize
Time() - Default constructor, creates a time object set with the device's
 current date and time.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
WindowsCE does not keep track of milliseconds, therefore, the field millis
 of the new object will always have the default value 0 on WindowsCE devices.
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Time(int year, int month, int day, int hour, int minute, int second, int
 millis) – Creates a time object with the given values.
\end_layout

\begin_layout Itemize
Time(long t) – Creates a time object from the given value, which must be
 in the format YYYYMMDDHHMMSS.
\end_layout

\begin_layout Itemize
Time(String iso8601) – Creates a time object using the given string, which
 must be in the ISO8601 format: YYYYMMDDTHH:MM:SS.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
Please notice the last two constructors do not include milliseconds, so
 the field millis will keep its default value 0.
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
Remember: no kind of validation is done on the Time fields values, not even
 on the constructors.
 However, the default constructor will never initialize an object with invalid
 values, and the last constructor may throw an InvalidNumberException if
 it fails to parse the given string.
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
equals(Object o) – Compares two Time objects for equality.
 The result is true if and only if the argument is not null and its a Time
 object that represents the same point in time, to the millisecond, as this
 object.
\end_layout

\begin_layout Itemize
getTimeLong() - Converts this time object to a long value in the format
 YYYYMMDDHHMMSS.
 Milliseconds is not included.
\end_layout

\begin_layout Itemize
toIso8601() - Converts this time object to a string in the ISO8601 format:
 YYYYMMDDTHH:MM:SS.
 Milliseconds is not included.
\end_layout

\begin_layout Itemize
toString() - Converts this time object to a string using the date format
 specified in Settings.dateFormat.
\end_layout

\begin_layout Section
CharacterConvert
\end_layout

\begin_layout Standard
This class is used to correctly handle international character conversions.
 The default character scheme converter is the 8859-1 (ISO Latin 1).
 If you want to use a different one, you must extend this class, implementing
 the bytes2chars and chars2bytes methods, and then assign the public member
 of Convert.charConverter to use your class instead of this default one.
 You can also use the method Convert.setDefaultConverter to change it, passing,
 as parameter, the prefix of your CharacterConverter class (better look
 at the implementation to know what to pass on).
\end_layout

\begin_layout Standard
To find out which sun.io.CharacterEncoder you're using on JDK to implement
 an equivalent version for TotalCross, use:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

System.out.println("" + sun.io.ByteToCharConverter.getDefault());
\end_layout

\end_inset


\end_layout

\begin_layout Section
UTF8CharacterConvert
\end_layout

\begin_layout Standard
This class extends the CharacterConvert class, and implements the UTF8 byte
 to UCS-2 character conversion.
 To use this class, you can call:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Convert.setDefaultConverter("UTF8");
\end_layout

\end_inset


\end_layout

\begin_layout Section
Convert
\end_layout

\begin_layout Standard
Convert basically provides methods that allows object and basic type conversion.
 Furthermore, it also provides handy methods for common operations that
 should be used for a better performance.
\end_layout

\begin_layout Standard
This class if final and cannot be instantiated – its methods and fields
 are static.
\end_layout

\begin_layout Standard
To give you a better view of this class, its documentation was split into
 sub-sections:
\end_layout

\begin_layout Subsection
Changing the default Character Converter
\end_layout

\begin_layout Standard
The field charConverter keeps a reference to a Character Converter that
 will be used by default.
 You may change it by setting another Character Converter of your choice.
\end_layout

\begin_layout Standard
You may also use the method setDefaultConverter(String name), which searches
 for a Character Converter by its name, and makes it the default by changing
 the charConverter field.
\end_layout

\begin_layout Subsection
Conversion between String and basic types
\end_layout

\begin_layout Itemize
toDouble(String s) – Converts the given String to double.
\end_layout

\begin_layout Itemize
toInt(String s) – Converts the given String to int.
\end_layout

\begin_layout Itemize
toLong(String s) – Converts the given String to long.
\end_layout

\begin_layout Itemize
toLong(String s, int radix) – Converts the given String to long in the given
 radix, which must be between 2 and 16.
\end_layout

\begin_layout Itemize
toString(boolean b) – Converts the given boolean to a String.
\end_layout

\begin_layout Itemize
toString(char c) – Converts the given char to a String.
\end_layout

\begin_layout Itemize
toString(double d) – Converts the given double to a String, formatted in
 scientific notation.
\end_layout

\begin_layout Itemize
toString(double val, int decimalCount) – Converts the given double to a
 String, formatted with the given number of decimal places.
\end_layout

\begin_layout Itemize
toString(int i) – Converts the given int to a String.
\end_layout

\begin_layout Itemize
toString(long l) – Converts the given long to a String using base 10.
\end_layout

\begin_layout Itemize
toString(long i, int radix) – Converts the given long to a String in the
 given radix, which must be between 2 and 16.
\end_layout

\begin_layout Itemize
toString(String doubleValue, int n) – Formats the given String as a double,
 rounding with n decimal places.
\end_layout

\begin_layout Itemize
unsigned2hex(int b, int places) – Converts the given unsigned integer to
 hexadecimal using the given number of places (up to 8).
\end_layout

\begin_layout Subsection
Character, String and StringBuffer utilities
\end_layout

\begin_layout Itemize
appendPath(String path1, String path2) – Concatenates two strings, ensuring
 there's a single slash between them.
 Removes extra slashes or backslashes if necessary.
\end_layout

\begin_layout Itemize
digitOf(char ch, int radix) – Returns the value of digit stored as char
 in the specified radix, which must be between 2 and 16.
 This method only handles the standard ASCII table.
\end_layout

\begin_layout Itemize
dup(char c, int count) – Returns a String filled with the given char and
 size equals to count.
\end_layout

\begin_layout Itemize
forDigit(int digit, int radix) – Returns the given digit in the specified
 radix, which must be between 2 and 16.
\end_layout

\begin_layout Itemize
getBreakPos(FontMetrics fm, StringBuffer sb, int start, int width, boolean
 doWordWrap) – Finds the best position to break the line with the given
 width, respecting word-wrap option and line ends ('
\backslash
n').
\end_layout

\begin_layout Itemize
hashCode(StringBuffer sb) – Returns the hash code of the String stored by
 this StringBuffer.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
The class StringBuffer does not have a method that returns its hash code,
 so you would have to first create a String from the StringBuffer to get
 its hash code, like this:
\end_layout

\begin_layout Plain Layout

\family typewriter
int hashCode = sb.toString.hashCode();
\end_layout

\begin_layout Plain Layout
On device, Convert.hashCode calculates the StringBuffer's hash code directly,
 without using an intermediary String object.
 Resulting in better performance and memory usage.
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
insertAt(StringBuffer sb, int pos, char c) – Inserts the given char at the
 specified position in the StringBuffer.
\end_layout

\begin_layout Itemize
insertLineBreak(int maxWidth, FontMetrics fm, String text) – Returns a new
 String which is a copy of the given text with line breaks, placed based
 on the maxWidth and fm arguments.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
Very useful method to help you keep your application's interface cross-platform.
 It can be used to insert line breaks on Strings passed to MessageBox or
 ListBox.
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
numberOf(String s, char c) – Returns the number of occurrences of the specified
 char in the given String.
\end_layout

\begin_layout Itemize
replace(String source, String from, String to) – Searches the String source
 for occurrences of the String from, replacing them by the String to.
\end_layout

\begin_layout Itemize
tokenizeString(String input, char delim) – Tokenizes the given String using
 the given char as separator.
 The return is a String array with size equal to the number of tokens.
\end_layout

\begin_layout Itemize
tokenizeString(String input, String delim) – Same as the above, but uses
 a String instead of a char as separator.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
Never use this method with 1 character length Strings, like:
\end_layout

\begin_layout Plain Layout

\family typewriter
String[] tokens = Convert.tokenizeString(input, 
\begin_inset Quotes eld
\end_inset

#
\begin_inset Quotes erd
\end_inset

);
\end_layout

\begin_layout Plain Layout
Use the previous method instead for better performance:
\end_layout

\begin_layout Plain Layout

\family typewriter
String[] tokens = Convert.tokenizeString(input, '#');
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
toLowerCase(char c) – Converts the given char to lower case.
\end_layout

\begin_layout Itemize
toUpperCase(char c) – Converts the given char to upper case.
\end_layout

\begin_layout Itemize
zeroPad(String s, int size) – Pads the String, adding zeros at left.
\end_layout

\begin_layout Itemize
zeroUnpad(String s) – Removes left zeros of the String.
\end_layout

\begin_layout Subsection
Arrays
\end_layout

\begin_layout Itemize
cloneStringArray(String[] strs) – Returns a copy of the given String array.
\end_layout

\begin_layout Itemize
toStringArray(Object[] objs) – Converts the given Object array into a String
 array, by calling toString for each Object.
\end_layout

\begin_layout Itemize
detectSortType(Object item) – Returns the sort type for the given item sample
 (which is usually the first item of an array).
\end_layout

\begin_layout Standard
Convert provides the Quick Sort algorithm for array sorting.
\end_layout

\begin_layout Itemize
Constants
\end_layout

\begin_deeper
\begin_layout Itemize
SORT_AUTODETECT – Chooses between one of the sort types below based on the
 first element of the array.
\end_layout

\begin_layout Itemize
SORT_OBJECT – The objects are compared by their String representation.
\end_layout

\begin_layout Itemize
SORT_STRING – The array contains String objects, and the sort is case sensitive.
\end_layout

\begin_layout Itemize
SORT_INT – The array contains String objects that represents integer values.
\end_layout

\begin_layout Itemize
SORT_DOUBLE – The array contains String objects that represents double values.
\end_layout

\begin_layout Itemize
SORT_DATE – The array contains String objects that represents a Date object
 with day, month and year.
\end_layout

\begin_layout Itemize
SORT_COMPARABLE – The array contain Comparable objects (objects that implements
 the Comparable interface).
\end_layout

\begin_layout Itemize
SORT_STRING_NOCASE - The array contains String objects, and the sort is
 case insensitive, which is slower than case sensitive sorting.
\end_layout

\end_deeper
\begin_layout Itemize
Methods
\end_layout

\begin_deeper
\begin_layout Itemize
qsort(Object[] items, int first, int last) – Applies the Quick Sort algorithm
 to the elements of the given array, sorting in ascending order and sort
 type equals to SORT_AUTODETECT.
\end_layout

\begin_layout Itemize
qsort(Object[] items, int first, int last, int sortType) - Same as the above
 method, but you can specify the sort type.
\end_layout

\begin_layout Itemize
qsort(Object[] items, int first, int last, int sortType, boolean ascending)
 - Same as the above, but you can also choose between sorting in ascending
 or descending order.
\end_layout

\end_deeper
\begin_layout Subsection
Other Conversions
\end_layout

\begin_layout Itemize

\family typewriter
chars2int(String fourChars) – Converts a creator id or type to int.
\end_layout

\begin_layout Itemize

\family typewriter
int2chars(int i) – Converts an int to a creator id or type.
\end_layout

\begin_layout Itemize

\family typewriter
doubleToIntBits(double f) – Converts the given double to its bit representation
 in IEEE 754 format, using 4 bytes instead of 8 (a conversion to float is
 applied).
\end_layout

\begin_layout Itemize

\family typewriter
intBitsToDouble(int i) – Converts the given IEEE 754 bit representation
 of a float to a double.
 
\end_layout

\begin_layout Itemize

\family typewriter
doubleToLongBits(double value) – Returns a representation of the specified
 floating-point value according to the IEEE 754 floating-point "double format"
 bit layout.
 
\end_layout

\begin_layout Itemize

\family typewriter
longBitsToDouble(long bits) – Converts the given bit representation to a
 double.
\end_layout

\begin_layout Itemize

\family typewriter
rol(long i, int n, int bits) – Does a rol of n bits in the given long.
 n must be < bits.
 Unlike the shift left operator (<<), bits that would have been lost are
 reinserted in order at the right.
\end_layout

\begin_layout Itemize

\family typewriter
ror(long i, int n, int bits) – Does a ror of n bits in the given long.
 n must be < bits.
 Unlike the shift right operator (>>), bits that would have been lost are
 reinserted in order at the left.
\end_layout

\begin_layout Part
INPUT & OUTPUT
\end_layout

\begin_layout Chapterstar
Overview
\end_layout

\begin_layout Standard
The purpose of this part is to teach you how to use the classes in the totalcros
s.io package.
 The classes that will be covered in this tutorial are outlined below:
\end_layout

\begin_layout Enumerate
totalcross.io.device.PortConnector: used to send and receive bytes via Serial
 cradle, USB, IrComm and Bluetooth.
\end_layout

\begin_layout Enumerate
totalcross.net.Socket: used to send and receive bytes via a TCP/IP connection.
\end_layout

\begin_layout Enumerate
totalcross.io.File: used to create files and manage directories.
\end_layout

\begin_layout Enumerate
totalcross.io.PDBFile: used to store data on the handheld
\end_layout

\begin_layout Enumerate
totalcross.io.ByteArrayStream: a resizable buffer that can be used to feed
 data to a stream or to store data coming from a stream.
 It can be used to emulate a virtual stream.
\end_layout

\begin_layout Enumerate
totalcross.io.DataStream (and DataStreamLE): used to read/write primitive
 types and Strings in Big Endian (default) or Little Endian format.
\end_layout

\begin_layout Enumerate
totalcross.io.ResizeRecord: used when creating a PDBFile record of unknown
 size.
 When output to the record is complete, the ResizeRecord shrinks the record
 to the optimal size.
\end_layout

\begin_layout Enumerate
totalcross.io.Stream: is the main Class of all classes inside the totalcross.io
 package.
 It can be viewed as a generic stream where data can flow in and out of
 the device.
 All classes inside package totalcross.io extend this Class, and most classes
 receive a totalcross.io.Stream in their constructor parameter.
 This allows you to combine different streams to meet your needs.
\end_layout

\begin_layout Chapter
Stream
\end_layout

\begin_layout Standard
Stream is an abstract class that serves as the base class for all classes
 that handles I/O operations.
 It defines the interface and the basic behavior that all its subclasses
 must implement.
\end_layout

\begin_layout FieldList
\labelwidthstring 0
close() Closes this stream, releasing any resources associated to it.
\end_layout

\begin_layout FieldList
\labelwidthstring 0
readBytes(byte[]
\begin_inset space ~
\end_inset

buf,
\begin_inset space ~
\end_inset

int
\begin_inset space ~
\end_inset

start,
\begin_inset space ~
\end_inset

int
\begin_inset space ~
\end_inset

count) Tries to read count bytes from this stream to the given byte array
 buf, beginning from the position start.
 Returns the number of bytes actually read.
\end_layout

\begin_layout FieldList
\labelwidthstring 0
writeBytes(byte[]
\begin_inset space ~
\end_inset

buf,
\begin_inset space ~
\end_inset

int
\begin_inset space ~
\end_inset

start,
\begin_inset space ~
\end_inset

int
\begin_inset space ~
\end_inset

count) Tries to write count bytes to this stream from the given byte array
 buf, beginning from the position start.
 Returns the number of bytes actually written.
\end_layout

\begin_layout Standard
These three methods may throw an IOException, what usually means that something
 out of our control went wrong, preventing the method to be executed.
\end_layout

\begin_layout Standard
Stream subclasses usually throw more exceptions that extends IOException
 to denote more specific problems and allow you to properly handle the situation
, like FileNotFoundException.
\end_layout

\begin_layout Standard
Streams subclasses can be divided into two main groups:
\end_layout

\begin_layout Itemize
Classes that actually perform I/O operations, like File or Socket.
\end_layout

\begin_layout Itemize
Classes that wrap a Stream, providing features or operations that can be
 applied to any other Stream, like DataStream or BufferedStream.
\end_layout

\begin_layout Standard
We'll first look into this last group, which provides easier and more efficient
 ways of reading and writing data.
\end_layout

\begin_layout Chapter
DataStream/DataStreamLE
\end_layout

\begin_layout Standard
DataStream is a wrapper that you can place around any Stream such as a File,
 Socket or ByteArrayStream, which allows you to read and write TotalCross'
 primitive data types and objects, like integers, longs, doubles and Strings,
 in a simple and standard way.
 
\end_layout

\begin_layout Standard
Although TotalCross internally uses the little endian format, the DataStream
 class uses the big endian format - the standard Java format.
 To read and write using the little endian format, you must use the DataStreamLE
 class instead.
\end_layout

\begin_layout Itemize
DataStream has only one constructor:
\end_layout

\begin_deeper
\begin_layout FieldList
\labelwidthstring 0
DataStream(Stream
\begin_inset space ~
\end_inset

stream) Creates a DataStream which wraps the given Stream.
\end_layout

\end_deeper
\begin_layout Standard
Handling primitive data types:
\end_layout

\begin_layout Itemize
Byte
\end_layout

\begin_deeper
\begin_layout FieldList
\labelwidthstring 0
readByte() Reads a byte.
\end_layout

\begin_layout FieldList
\labelwidthstring 0
writeByte(byte
\begin_inset space ~
\end_inset

by) Writes a byte.
\end_layout

\begin_layout FieldList
\labelwidthstring 0
readUnsignedByte() Reads an unsigned byte, returning its value as int.
\end_layout

\begin_layout FieldList
\labelwidthstring 0
writeByte(int
\begin_inset space ~
\end_inset

by) Writes an unsigned byte, which is the first byte from the given int,
 which value should be between 0 and 255.
\end_layout

\end_deeper
\begin_layout Itemize
Boolean
\end_layout

\begin_deeper
\begin_layout FieldList
\labelwidthstring 0
readBoolean() Reads a byte as a boolean.
\end_layout

\begin_layout FieldList
\labelwidthstring 0
writeBoolean(boolean
\begin_inset space ~
\end_inset

bool) Writes a boolean as a byte.
\end_layout

\end_deeper
\begin_layout Itemize
Char
\end_layout

\begin_deeper
\begin_layout FieldList
\labelwidthstring 0
readChar() Reads two bytes as a char.
\end_layout

\begin_layout FieldList
\labelwidthstring 0
writeChar(char
\begin_inset space ~
\end_inset

c) Writes a char as two bytes.
\end_layout

\end_deeper
\begin_layout Itemize
Short
\end_layout

\begin_deeper
\begin_layout FieldList
\labelwidthstring 0
readShort() Reads two bytes as a short.
\end_layout

\begin_layout FieldList
\labelwidthstring 0
readUnsignedShort() Reads two bytes as an unsigned short, returning its
 value as int.
\end_layout

\begin_layout FieldList
\labelwidthstring 0
writeShort(int
\begin_inset space ~
\end_inset

i) Writes a short as two bytes.
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100line%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
There's only one method to write short, which receives an integer.
 It may be used to write signed and unsigned shorts.
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Int
\end_layout

\begin_deeper
\begin_layout FieldList
\labelwidthstring 0
readInt() Reads four bytes as an int.
\end_layout

\begin_layout FieldList
\labelwidthstring 0
writeInt(int
\begin_inset space ~
\end_inset

i) Writes an int as four bytes.
\end_layout

\end_deeper
\begin_layout Itemize
Long
\end_layout

\begin_deeper
\begin_layout FieldList
\labelwidthstring 0
readLong() Reads eight bytes as a long.
\end_layout

\begin_layout FieldList
\labelwidthstring 0
writeLong(long
\begin_inset space ~
\end_inset

l) Writes a long as eight bytes.
\end_layout

\end_deeper
\begin_layout Itemize
Float
\end_layout

\begin_deeper
\begin_layout FieldList
\labelwidthstring 0
readFloat() Reads four bytes as a float in IEEE 754 format, returning its
 value as double.
\end_layout

\begin_layout FieldList
\labelwidthstring 0
writeFloat(double
\begin_inset space ~
\end_inset

f) Writes a float as four bytes in IEEE 754 format.
\end_layout

\end_deeper
\begin_layout Itemize
Double
\end_layout

\begin_deeper
\begin_layout FieldList
\labelwidthstring 0
readDouble() Reads eight bytes as a double.
\end_layout

\begin_layout FieldList
\labelwidthstring 0
writeDouble(double
\begin_inset space ~
\end_inset

d) Writes a double as eight bytes.
\end_layout

\end_deeper
\begin_layout Standard
Handling char arrays:
\end_layout

\begin_layout FieldList
\labelwidthstring 0
readChars() Reads an array of chars, where its length is stored in the first
 two bytes as an unsigned short (limited to 65,535 characters).
\end_layout

\begin_layout FieldList
\labelwidthstring 0
writeChars(char[]
\begin_inset space ~
\end_inset

chars,
\begin_inset space ~
\end_inset

int
\begin_inset space ~
\end_inset

start,
\begin_inset space ~
\end_inset

int
\begin_inset space ~
\end_inset

len) Writes an array of chars, placing its length in the first two bytes
 as an unsigned short (limited to 65,535 characters).
\end_layout

\begin_layout FieldList
\labelwidthstring 0
readBigChars() Reads an array of chars, where its length is stored in the
 first four bytes as an int (limited to +2,147,483,647 characters).
\end_layout

\begin_layout FieldList
\labelwidthstring 0
writeBigChars(char[]
\begin_inset space ~
\end_inset

chars,
\begin_inset space ~
\end_inset

int
\begin_inset space ~
\end_inset

start,
\begin_inset space ~
\end_inset

int
\begin_inset space ~
\end_inset

len) Writes an array of chars, placing its length in the first four bytes
 as an int (limited to +2,147,483,647 characters).
\end_layout

\begin_layout Standard
Handling Strings:
\end_layout

\begin_layout FieldList
\labelwidthstring 0
readString() Reads a string, where its length is stored in the first two
 bytes as an unsigned short (limited to 65,535 characters).
\end_layout

\begin_layout FieldList
\labelwidthstring 0
writeString(String
\begin_inset space ~
\end_inset

s) Writes a string, placing its length in the first two bytes as an unsigned
 short (limited to 65,535 characters).
\end_layout

\begin_layout FieldList
\labelwidthstring 0
readBigString() Reads a string, where its length is stored in the first
 four bytes as an int (limited to +2,147,483,647 characters).
\end_layout

\begin_layout FieldList
\labelwidthstring 0
writeBigString(String
\begin_inset space ~
\end_inset

s) Writes a string, placing its length in the first four bytes as an int
 (limited to +2,147,483,647 characters).
\end_layout

\begin_layout FieldList
\labelwidthstring 0
readCString() - Reads a C-style (null terminated) string.
 (no implicit limit)
\end_layout

\begin_layout FieldList
\labelwidthstring 0
writeCString(String
\begin_inset space ~
\end_inset

s) Writes a C-style (null terminated) string.
 (no implicit limit)
\end_layout

\begin_layout Standard
Handling ASCII Strings:
\end_layout

\begin_layout Standard
These methods are used to read and write Strings comprised of only ASCII
 chars – each character is cast from/to byte, and requires 1 byte instead
 of 2 bytes.
 Make sure your strings have only characters between the ASCII range (0-255),
 because characters outside this range will not be properly handled.
\end_layout

\begin_layout FieldList
\labelwidthstring 0
readSmallString() Reads a small string, where its length is stored in the
 first byte as an unsigned byte (limited to 255 characters).
\end_layout

\begin_layout FieldList
\labelwidthstring 0
writeSmallString(String
\begin_inset space ~
\end_inset

s) Writes a small string, placing its length in the first byte as an unsigned
 byte (limited to 255 characters).
\end_layout

\begin_layout FieldList
\labelwidthstring 0
readFixedString(int
\begin_inset space ~
\end_inset

length) Reads a fixed length string (limited to +2,147,483,647 characters).
\end_layout

\begin_layout FieldList
\labelwidthstring 0
writeFixedString(String
\begin_inset space ~
\end_inset

s,
\begin_inset space ~
\end_inset

int
\begin_inset space ~
\end_inset

length,
\begin_inset space ~
\end_inset

char
\begin_inset space ~
\end_inset

pad) Writes a fixed length string (limited to +2,147,483,647 characters).
 If the given string is longer than the given length, it is truncated; If
 shorter, it is padded with the given char.
\end_layout

\begin_layout FieldList
\labelwidthstring 0
writeFixedString(String
\begin_inset space ~
\end_inset

s,
\begin_inset space ~
\end_inset

int
\begin_inset space ~
\end_inset

length) Same as the above, but shorter strings are padded with spaces.
\end_layout

\begin_layout Standard
Handling String arrays:
\end_layout

\begin_layout Standard
The methods may be used to handle string arrays, and both should be used
 together.
 This is because the size of the array is stored in the first two bytes
 as an unsigned short, before the very first string (e.g.
 if you write several strings with writeString, you cannot use readStringArray
 to read them, and vice-versa).
\end_layout

\begin_layout Standard
It's important to notice these methods handle strings like the readString
 and writeString methods, so the current character encoding will be used
 and their length stored as an unsigned short, therefore, the string array
 cannot contain a string with more than 65,535 characters.
\end_layout

\begin_layout FieldList
\labelwidthstring 0
readStringArray() Reads an array of strings, where its size is stored in
 the first two bytes as an unsigned short.
\end_layout

\begin_layout FieldList
\labelwidthstring 0
writeStringArray(String[]
\begin_inset space ~
\end_inset

v) Writes an array of strings, placing its size in the first two bytes as
 an unsigned short.
\end_layout

\begin_layout Standard
Handling Objects (Storable):
\end_layout

\begin_layout Standard
Objects that implements the interface Storable, may have its internal state
 persisted or retrieved directly using the following methods:
\end_layout

\begin_layout FieldList
\labelwidthstring 0
readObject() Reads an object which implements the Storable interface and
 was written using writeObject.
\end_layout

\begin_layout FieldList
\labelwidthstring 0
writeObject(Storable
\begin_inset space ~
\end_inset

s) Writes a Storable object.
\end_layout

\begin_layout Standard
Utility methods:
\end_layout

\begin_layout FieldList
\labelwidthstring 0
getStream() Returns the stream attached to this DataStream.
\end_layout

\begin_layout FieldList
\labelwidthstring 0
pad(int
\begin_inset space ~
\end_inset

n) Pads the stream writing n bytes with value 0.
\end_layout

\begin_layout FieldList
\labelwidthstring 0
skip(int
\begin_inset space ~
\end_inset

n) Skips reading the next n bytes in the stream (only forward!).
\end_layout

\begin_layout FieldList
\labelwidthstring 0
readBytes(byte[]
\begin_inset space ~
\end_inset

buf) Same as readBytes(buf, 0, buf.length).
\end_layout

\begin_layout FieldList
\labelwidthstring 0
writeBytes(byte[]
\begin_inset space ~
\end_inset

buf) Same as writeBytes(buf, 0, buf.length).
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100line%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
As a general rule, strings and arrays with null value are persisted as zero
 sized strings and arrays (e.g.
 a string persisted with writeString(null) is read as “” - a zero sized
 string, which is not a null value).
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
ByteArrayStream
\end_layout

\begin_layout Standard
The ByteArrayStream is a Stream that has an internal growable byte array,
 and it is commonly used as a buffer.
 
\end_layout

\begin_layout Standard
In I/O operations, usually it's faster and/or less resource consuming to
 send larger chunks of data at once, instead of sending several small chunks
 of data.
 You may use a ByteArrayStream as a buffer and wait until it reaches a minimum
 size performing any actual I/O operation.
\end_layout

\begin_layout Standard
Sample code:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Socket s = new Socket(host, 8080); // connect to our host
\end_layout

\begin_layout Plain Layout

PortConnector pc = new PortConnector(0, 9600); // open a serial connection
\end_layout

\begin_layout Plain Layout

ByteArrayStream bas = new ByteArrayStream(512); // length 512
\end_layout

\begin_layout Plain Layout

bas.readFully(s, 10, 0); /* reads from the given stream (our socket) until
 the maximum number of retries is reached, in this case, 10 times.
 */
\end_layout

\begin_layout Plain Layout

int available = bas.available();
\end_layout

\begin_layout Plain Layout

if (available > 0) // did we receive anything?
\end_layout

\begin_layout Plain Layout

	pc.writeBytes(bas.getBuffer(), 0, available); /* yes! Let's send the data
 over the serial connection.
 */
\end_layout

\end_inset


\end_layout

\begin_layout FieldList
\labelwidthstring 0
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100line%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
This difference is easily noticeable when dealing with external connections,
 like Socket or PortConnector, but don't forget their operations usually
 have a time limit (timeout), that must be adjusted according to your connection
 speed and the amount of data you want to be able to read or write in a
 single I/O operation.
 Using a low timeout to send or receive large amounts of data may cause
 problems.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
You may also use a ByteArrayStream with DataStream to ensure you received
 enough data before handling it.
\end_layout

\begin_layout Standard
Sample code:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Socket s = new Socket(host, 8080); // connect to our host
\end_layout

\begin_layout Plain Layout

ByteArrayStream bas = new ByteArrayStream(256); // length 256
\end_layout

\begin_layout Plain Layout

bas.readFully(s, 5, 0); /* reads from the given stream (our socket) until
 the maximum number of retries is reached, in this case, 5 times.
 */
\end_layout

\begin_layout Plain Layout

DataStream ds = new DataStream(bas); /* the DataStream wraps the ByteArrayStream
 instead of the Socket.
 */
\end_layout

\begin_layout Plain Layout

int value;
\end_layout

\begin_layout Plain Layout

if (bas.available() >= 4) // do we have at least 4 bytes available?
\end_layout

\begin_layout Plain Layout

	value = ds.readInt(); // yes! Then we can read an int from the buffer.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The ByteArrayStream is usually used as a read-only or write-only buffer,
 because its internal cursor is advanced every time a read or write operation
 is performed.
 However, you may use methods like setPos, reset, mark and skipBytes to
 navigate through the buffer and be able to perform read and write operations
 on the same buffer.
\end_layout

\begin_layout Standard
Like a Vector, the ByteArrayStream expands its internal buffer dynamically
 as needed (at a 20% rate).
\end_layout

\begin_layout Standard
The ByteArrayStream has two constructors:
\end_layout

\begin_layout FieldList
\labelwidthstring 0
ByteArrayStream(byte[]
\begin_inset space ~
\end_inset

buffer) Creates a ByteArrayStream, using the given byte array, which may
 not be empty, as the internal buffer.
 More often used to create read-only buffers.
\end_layout

\begin_layout FieldList
\labelwidthstring 0
ByteArrayStream(int
\begin_inset space ~
\end_inset

size) Creates a ByteArrayStream, with a newly created (empty) internal byte
 array of the given size.
 More often used to create write-only buffers.
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100line%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
Although the internal buffer is a private field, you may create a ByteArrayStrea
m with your own byte array or use methods like getBuffer and setBuffer to
 have a reference for this field.
 But you can't set the internal buffer to null or change its size without
 also updating its length and reseting its cursor position.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Methods inherited from Stream:
\end_layout

\begin_layout FieldList
\labelwidthstring 0
readBytes(byte[]
\begin_inset space ~
\end_inset

buf,
\begin_inset space ~
\end_inset

int
\begin_inset space ~
\end_inset

start,
\begin_inset space ~
\end_inset

int
\begin_inset space ~
\end_inset

count) Copies count bytes from this ByteArrayStream's buffer to the given
 byte array, starting at position start.
 The contents of the buffer are not changed, but its cursor is moved count
 positions.
\end_layout

\begin_layout FieldList
\labelwidthstring 0
writeBytes(byte[]
\begin_inset space ~
\end_inset

buf,
\begin_inset space ~
\end_inset

int
\begin_inset space ~
\end_inset

start,
\begin_inset space ~
\end_inset

int
\begin_inset space ~
\end_inset

count) Copies count bytes from the given byte array, starting at position
 start, to this ByteArrayStream's buffer, expanding it if necessary.
 The internal cursor is moved count positions.
\end_layout

\begin_layout FieldList
\labelwidthstring 0
close() Does nothing.
 The ByteArrayStream does not encapsulate an actual handler for I/O operations,
 so there's no nothing to be done.
\end_layout

\begin_layout Standard
Manipulating the internal array:
\end_layout

\begin_layout FieldList
\labelwidthstring 0
count() Returns the current cursor position in the buffer – the number of
 bytes read in read-only, or the number of bytes written in a write-only.
\end_layout

\begin_layout FieldList
\labelwidthstring 0
available() Returns the number of bytes available for reading or writing
 from the current cursor position (marked position of the buffer – current
 cursor position).
\end_layout

\begin_layout FieldList
\labelwidthstring 0
mark() Marks the current position as the buffer size and the cursor position
 to 0, so you may read from the buffer without going past the number of
 bytes actually available for reading.
\end_layout

\begin_layout FieldList
\labelwidthstring 0
reset() Resets the cursor position to 0 and sets the mark with the actual
 array size.
\end_layout

\begin_layout FieldList
\labelwidthstring 0
reuse() Shifts the bytes starting at the current position to the first position
 of the buffer – this way you may reuse the buffer without exceeding the
 buffer limits, which would make the buffer grow and consume more memory.
 This method also returns the number of bytes shifted, which may be used
 to move the cursor to the end of it and reuse the buffer without overwriting
 the shifted bytes.
\end_layout

\begin_layout FieldList
\labelwidthstring 0
skipBytes(int
\begin_inset space ~
\end_inset

count) Moves the cursor count bytes from the current position.
 A positive value moves the cursor forward, while a negative value moves
 the cursor backwards.
\begin_inset Newline newline
\end_inset


\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100line%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
This method 
\emph on
does not
\emph default
 throws an exception if the given argument exceeds the buffer bounds, instead,
 it returns -1.
\end_layout

\end_inset


\end_layout

\begin_layout FieldList
\labelwidthstring 0
setPos(int
\begin_inset space ~
\end_inset

newPos) Sets cursor position to the given value (which should be between
 0 and the position marked as the end of the buffer).
\begin_inset Newline newline
\end_inset


\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100line%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
This method 
\emph on
does not
\emph default
 check if the given value is valid, so make sure you're using it correctly.
\end_layout

\end_inset


\end_layout

\begin_layout FieldList
\labelwidthstring 0
setSize(int
\begin_inset space ~
\end_inset

newSize,
\begin_inset space ~
\end_inset

boolean
\begin_inset space ~
\end_inset

copyOldData) Resizes the internal buffer if the given size is greater than
 the position marked as the end of the buffer.
 If copyOldData is true, it also copies the contents of the current buffer
 to the new buffer, starting from 0 to the current cursor position.
 If the given size if equals or smaller than the marked position of the
 buffer, nothing is changed.
\end_layout

\begin_layout FieldList
\labelwidthstring 0
readFully(Stream
\begin_inset space ~
\end_inset

inputStream,
\begin_inset space ~
\end_inset

int
\begin_inset space ~
\end_inset

retryCount,
\begin_inset space ~
\end_inset

int
\begin_inset space ~
\end_inset

bufSize) Resets this ByteArrayStream and reads the maximum amount of data
 available from the given stream, marking the last position used as the
 end of the buffer.
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Itemize
The argument retryCount, if greater than 0, specifies the number of times
 the method should try to read data from the stream before returning.
 It will always try to read data at least once, even if retryCount is not
 a positive value.
\end_layout

\begin_layout Plain Layout
This is specially useful for streams that handle external connections, like
 Socket or PortConnector, you may specify 1 or any lower value for other
 streams, like File or PDBFile.
\end_layout

\begin_layout Itemize
Be careful when using this method with streams like File.
 It may read the whole file at once, resulting in a great loss of performance
 and resources (the buffer may be resized several times).
 In the worst scenario, the device will run out of memory and the application
 will be halted.
 In this case, you should check the size of the stream before using readFully.
\end_layout

\begin_layout Itemize
The argument bufSize specifies a minimum size for the internal buffer –
 therefore, if its value is equals or lower than the size of the buffer,
 it is not resized (i.e.
 you cannot use it to shrink the buffer).
 Otherwise, the buffer will be resized to match the given value.
\end_layout

\begin_deeper
\begin_layout Plain Layout
Please notice, the buffer will still grow if necessary, regardless of the
 bufSize value.
 So you cannot use it to limit the amount of data read, and you may specify
 a value 0 or lower if you do not wish to define a minimum size – this will
 not prevent its automatic resize.
\end_layout

\end_deeper
\begin_layout Itemize
The ByteArrayStream is reseted at the beginning of readFully, so you can't
 use it in a loop as a buffer for a stream, you must use the argument retryCount
 instead.
\end_layout

\begin_layout Itemize
Calling the method reset before readFully is pointless, since this is already
 done by readFully.
\end_layout

\begin_layout Itemize
After the readFully finishes reading to the internal buffer, it marks the
 current cursor position and sets the cursor to the first position of the
 array, so you may read from the buffer without going past the number of
 bytes actually available for reading.
\end_layout

\end_inset


\end_layout

\begin_layout FieldList
\labelwidthstring 0
getBuffer() Returns a reference to the internal buffer.
 The actual length of the buffer may differ from the current buffer size.
\end_layout

\begin_layout FieldList
\labelwidthstring 0
setBuffer(byte[] buffer) Assigns the given byte array as the internal buffer,
 reseting its current position and updating its size.
\end_layout

\begin_layout FieldList
\labelwidthstring 0
toByteArray() Returns a byte array, which is a copy of the contents of the
 internal buffer
\end_layout

\begin_layout Chapter
File
\end_layout

\begin_layout Standard
Being able to persist and retrieve data is very important for any application
 – and also a difficult task when you're dealing with different platforms
 and OS versions, each one with your own features and flaws.
\end_layout

\begin_layout Standard
The File class was designed to allow you to browse and manipulate the file
 system – with its directories and archives – of any supported device in
 a transparent and reliable manner.
\end_layout

\begin_layout Standard
A File object represents an archive or a directory of the device's file
 system, stored either on its non-volatile memory or in a memory card inserted
 on the device.
\end_layout

\begin_layout Standard
When creating a new File object, you may specify the open mode using one
 of the following constants:
\end_layout

\begin_layout FieldList
\labelwidthstring 0
DONT_OPEN The path argument denotes either a directory or an archive that
 may not exist.
 The given path is stored but the file isn't actually accessed (i.e.
 no resource is locked to manipulate the file).
\begin_inset Newline newline
\end_inset

This mode may be used to perform operations that do not require the allocation
 of any resources, or to manipulate directories.
 In fact, it is the only mode that allows directory manipulation.
\end_layout

\begin_deeper
\begin_layout FieldList
\labelwidthstring 0
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100line%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
Files created with mode DONT_OPEN don't need to be closed since there are
 no resources to be released, but you may call the close method anyway.
 However, calling the close method twice for the same file object (i.e.
 trying to close a file that was already closed) throws an IOException regardles
s of the File open mode used.
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout FieldList
\labelwidthstring 0
CREATE The given path denotes an archive that may not exist.
 If the archive does not exists, it is created and opened with read and
 write access, otherwise, it justs opens the existing file with read and
 write access.
\end_layout

\begin_layout FieldList
\labelwidthstring 0
READ_WRITE The given path denotes an archive to be opened with read and
 write access.
 The archive must exists, otherwise a FileNotFoundException is thrown.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100line%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
Use this mode when you want to manipulate an archive only if it already
 exists - don't forget to catch and handle the FileNotFoundException.
 This is more efficient than creating a file object in DONT_OPEN mode to
 check if the file exists and is not a directory.
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout FieldList
\labelwidthstring 0
CREATE_EMPTY The given path denotes an archive that may not exist.
 If the archive exists, it is replaced by an empty one, otherwise, a new
 one is created.
 Either way, the archive is opened with read and write access.
\end_layout

\begin_layout Standard
File constructors:
\end_layout

\begin_layout FieldList
\labelwidthstring 0
File(String
\begin_inset space ~
\end_inset

path,
\begin_inset space ~
\end_inset

int
\begin_inset space ~
\end_inset

mode,
\begin_inset space ~
\end_inset

int
\begin_inset space ~
\end_inset

slot) Creates a file object with the given path, using the given mode (which
 should be one of the above constants) and the specified slot.
\end_layout

\begin_layout FieldList
\labelwidthstring 0
File(String
\begin_inset space ~
\end_inset

path,
\begin_inset space ~
\end_inset

int
\begin_inset space ~
\end_inset

mode) Creates a file object with the given path, using the given mode (which
 should be one of the above constants) and the last available slot.
\end_layout

\begin_layout FieldList
\labelwidthstring 0
File(String
\begin_inset space ~
\end_inset

path) Creates a file object with the given path, using the DONT_OPEN mode
 and the last available slot.
\end_layout

\begin_layout Standard
The argument slot specifies the index of the storage media to be used.
 Usually the value used will be 1, which defaults to the device's internal
 non-volatile memory.
\end_layout

\begin_layout Standard
If the device has one or more slots for external storage medias (e.g.
 MM Cards and SD Cards), you may access them using a value greater than
 1 (e.g.
 if the device has one slot for a memory card, you may address it using
 the value 2).
\end_layout

\begin_layout Standard
You may also use the value -1 to access the storage media of higher index
 (i.e.
 1 if not external media is available, 2 if one external media is available,
 and so on...).
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100line%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
Always use '/' (slash) as the file separator, and never the '
\backslash
' (backslash), regardless of the target platform.
 Although the File constructor should be able to handle both slashes and
 backslashes right now, the backslash support may be removed in the future
 to increase performance.
 Besides, the slash is TotalCross' official file separator, so you'd better
 get used to it.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Depending on the target file type (directory or archive) and the used open
 mode, some methods may not be used, or have a different behavior.
 Using a method under the wrong circumstances will result in an IOException.
\end_layout

\begin_layout Standard
To clarify, we'll split the File methods into the four categories below:
\end_layout

\begin_layout Itemize
Archive and Directory methods – May be used with any file, regardless of
 the type and the open mode.
\end_layout

\begin_layout Itemize
Directory only methods – Can only be used with directories.
\end_layout

\begin_layout Itemize
Archive only methods – Can only be used with open archives (cannot be used
 with archives created in DONT_OPEN).
\end_layout

\begin_layout Itemize
Behavior depends on the file type – May be used with any file, but the method
 implementation and result depends on the file type.
\end_layout

\begin_layout Standard
Archive and Directory methods:
\end_layout

\begin_layout FieldList
\labelwidthstring 0
exists() Returns true if the file exists and false otherwise.
\end_layout

\begin_layout FieldList
\labelwidthstring 0
isDir() Returns true only if the file exists and is a directory, returning
 false otherwise.
 To check if a file is an archive, you must test if the file is not a directory
 and if the file exists.
 Obviously this method should only be used in mode DONT_OPEN, since it will
 always return false in any other mode.
\end_layout

\begin_layout FieldList
\labelwidthstring 0
getParent() Returns a new file object that references this file's parent
 directory, or null if this file does not have a parent directory.
 The new file object is created in DONT_OPEN mode.
\end_layout

\begin_layout FieldList
\labelwidthstring 0
rename(String
\begin_inset space ~
\end_inset

path) Renames the file with the given path.
\begin_inset Newline newline
\end_inset

This operation closes the file object, so you should not perform any operations
 after a rename.
\end_layout

\begin_layout FieldList
\labelwidthstring 0
delete() Removes the file from the file system.
 If the file is a directory, it must be empty, otherwise an IOException
 will be thrown.
 If the file does not exists, a FileNotFoundException is thrown.
\begin_inset Newline newline
\end_inset

This operation closes the file object, so you should not perform any operations
 after a delete.
\end_layout

\begin_layout FieldList
\labelwidthstring 0
close() Closes this file object, releasing any resources held by this object.
 Trying to close a file object twice (e.g.
 calling close twice, or rename and close) results in an IOException.
\begin_inset Newline newline
\end_inset

This operation closes the file object, so you should not perform any operations
 after a close.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100line%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
Although not necessary, you may close a file object created in DONT_OPEN
 mode.
 However, trying to close the same file object twice will always result
 in an IOException, regardless of the create mode used.
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
Directory only methods:
\end_layout

\begin_layout FieldList
\labelwidthstring 0
createDir() Creates the directory named by this path, including any necessary
 but nonexistent parent directories.
\end_layout

\begin_layout FieldList
\labelwidthstring 0
listFiles() Returns an array of strings denoting the files in this directory.
\end_layout

\begin_layout Standard
Archive only methods:
\end_layout

\begin_layout FieldList
\labelwidthstring 0
readBytes(byte[]
\begin_inset space ~
\end_inset

b,
\begin_inset space ~
\end_inset

int
\begin_inset space ~
\end_inset

off,
\begin_inset space ~
\end_inset

int
\begin_inset space ~
\end_inset

len) Attempts to read len bytes from the file into the given byte array,
 starting at the array's position off.
 Returns the number of bytes actually read.
\end_layout

\begin_layout FieldList
\labelwidthstring 0
writeBytes(byte[]
\begin_inset space ~
\end_inset

b,
\begin_inset space ~
\end_inset

int
\begin_inset space ~
\end_inset

off,
\begin_inset space ~
\end_inset

int
\begin_inset space ~
\end_inset

len) Attempts to write len bytes to the file from the given byte array,
 starting at the array's position off.
 Returns the number of bytes actually written.
\end_layout

\begin_layout FieldList
\labelwidthstring 0
flush() Flushes the stream, forcing any buffered bytes to be written on
 the file.
\end_layout

\begin_layout FieldList
\labelwidthstring 0
setPos(int
\begin_inset space ~
\end_inset

pos) Moves the file pointer for read and write operations to the given position.
\end_layout

\begin_layout FieldList
\labelwidthstring 0
getAttributes() Gets this file attributes, returning the attributes constants
 ORed together.
 (more information below)
\end_layout

\begin_layout FieldList
\labelwidthstring 0
setAttributes(int
\begin_inset space ~
\end_inset

attr) Sets this file attributes with the given attributes constants ORed
 together.
 (more information below)
\end_layout

\begin_layout FieldList
\labelwidthstring 0
getTime(byte
\begin_inset space ~
\end_inset

whichTime) Gets the time for the given time type constant.
 (more information below)
\end_layout

\begin_layout FieldList
\labelwidthstring 0
setTime(byte
\begin_inset space ~
\end_inset

whichTime,
\begin_inset space ~
\end_inset

Time
\begin_inset space ~
\end_inset

time) Sets the time for the given time type constant.
 (more information below)
\end_layout

\begin_layout FieldList
\labelwidthstring 0
setSize(int
\begin_inset space ~
\end_inset

newSize) Sets the size of this file.
 If newSize is greater than the current size, the file is resized to the
 given size, otherwise the file is truncated, discarding all bytes from
 the position newSize to the current end of file.
\end_layout

\begin_layout Standard
Behavior depends on the file type:
\end_layout

\begin_layout FieldList
\labelwidthstring 0
getSize() If the file is the root directory, returns the amount of free
 space available on this file system.
 If the file is an open archive, returns its size.
 If the file is neither the root directory nor an open archive, an IOException
 is thrown.
\end_layout

\begin_layout Section
File attributes
\end_layout

\begin_layout Standard
As shown above, you may use the methods getAttributes and setAttributes
 to retrieve or change the attributes of an archive (these operations are
 not supported for directories) with the following constants:
\end_layout

\begin_layout FieldList
\labelwidthstring 0
ATTR_ARCHIVE Often used to mark an archive for backup or removal.
\end_layout

\begin_layout FieldList
\labelwidthstring 0
ATTR_HIDDEN Hidden files are usually not listed on the file system.
\end_layout

\begin_layout FieldList
\labelwidthstring 0
ATTR_READ_ONLY Archives marked as read only cannot open with write access.
\end_layout

\begin_layout FieldList
\labelwidthstring 0
ATTR_SYSTEM Archives marked as system are normally used only by the OS,
 and should not be changed by the user.
\end_layout

\begin_layout Standard
However, these attributes are not supported by all platforms, and although
 you are not required to write platform specific code, you must be aware
 that you should not rely on certain attributes when writing cross-platform
 applications.
\end_layout

\begin_layout Standard
Below you can see the archive attributes support for each platform:
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
Win32 Full support.
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
WinCE Full support.
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
PalmOS Full support, but the usage of the ATTR_READ_ONLY constant is not
 advised.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100line%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
Files in PalmOS must be opened with write access to have their attributes
 changed, therefore, you cannot change the attributes of a read only file,
 because you're not allowed to open it with write access.
 A read only file cannot be changed, moved or deleted, only reading is allowed.
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Labeling
\labelwidthstring 00.00.0000
BlackBerry Supports only ATTR_HIDDEN and ATTR_READ_ONLY.
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
iPhone Supports only ATTR_READ_ONLY.
\end_layout

\begin_layout Section
File times
\end_layout

\begin_layout Standard
Usually a file has three attributes which represents its creation time,
 the last time it was accessed and the last time it was modified.
 TotalCross provides the following constants to be used with the methods
 setTime and getTime to retrieve and change these attributes:
\end_layout

\begin_layout FieldList
\labelwidthstring 0
TIME_CREATED Used to get or set the file's creation time.
\end_layout

\begin_layout FieldList
\labelwidthstring 0
TIME_ACCESSED Used to get or set the time the file was last accessed.
\end_layout

\begin_layout FieldList
\labelwidthstring 0
TIME_MODIFIED Used to get or set the time the file was last modified.
\end_layout

\begin_layout FieldList
\labelwidthstring 0
TIME_ALL Used to set all of the above times with the same value.
\end_layout

\begin_layout Standard
Unfortunately these operations are not fully supported by all platforms,
 so you must be aware that you should not rely on these values when writing
 cross-platform applications.
\end_layout

\begin_layout Standard
Below you can see the times attributes support for each platform:
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
Win32 Full support.
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
WinCE Supports only TIME_MODIFIED if the file is stored on the device's
 non-volatile memory.
 If the file is stored in an external FAT storage, it also supports TIME_CREATED.
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
PalmOS Full support.
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
BlackBerry Supports only TIME_MODIFIED with getTime – you may retrieve the
 time the file was last modified with getTime, but you cannot change it
 with setTime.
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
iPhone Full support with getTime, but you cannot set the attribute TIME_CREATED
 with setTime.
\end_layout

\begin_layout Part
COMPRESSION
\end_layout

\begin_layout Chapterstar
Overview
\end_layout

\begin_layout Standard
This section covers the usage of classes that handle data compression, inflating
 compressed data or deflating uncompressed data using streams.
\end_layout

\begin_layout Chapter
CompressedStream
\end_layout

\begin_layout Standard
Abstract class used as the basis for compression filters, such as ZLibStream
 and GZipStream.
\end_layout

\begin_layout Standard
Instances of subclasses of CompressedStream cannot be used for both read
 and write operations.
 At the object creation, you MUST choose if the new object is going to be
 used either for reading or writing compressed data, by passing one of the
 following constants to the class constructor:
\end_layout

\begin_layout FieldList
\labelwidthstring 0
DEFLATE Used to create a stream for data compression.
 In this mode, you may ONLY use write operations.
\end_layout

\begin_layout FieldList
\labelwidthstring 0
INFLATE Used to create a stream for data decompression.
 In this mode, you may ONLY use read operations.
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100line%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
Subclasses of CompressedStream that implements algorithms with different
 levels of compression, should always use a constant default value for data
 compression.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Also notice that closing a CompressedStream DOES NOT affect the underlying
 stream (the stream passed to the constructor).
 To also close the underlying stream, you must call its own close method
 after closing the CompressedStream.
\end_layout

\begin_layout Chapter
ZLibStream
\end_layout

\begin_layout Standard
Subclass of CompressedStream that implements data compression using the
 zlib algorithm.
\end_layout

\begin_layout Quote
“zlib is designed to be a free, general-purpose, legally unencumbered --
 that is, not covered by any patents - lossless data-compression library
 for use on virtually any computer hardware and operating system.
 The zlib data format is itself portable across platforms.
\begin_inset Quotes erd
\end_inset

 - 
\begin_inset CommandInset href
LatexCommand href
target "http://www.zlib.net/"

\end_inset


\end_layout

\begin_layout Chapter
GZipStream
\end_layout

\begin_layout Standard
Subclass of CompressedStream that implements data compression using the
 gzip algorithm.
\end_layout

\begin_layout Quote
“gzip (GNU zip) is a compression utility designed to be a replacement for
 compress.
 Its main advantages over compress are much better compression and freedom
 from patented algorithms.
 It has been adopted by the GNU project and is now relatively popular on
 the Internet.” - 
\begin_inset CommandInset href
LatexCommand href
target "http://www.gzip.org/"

\end_inset


\end_layout

\begin_layout Chapter
ZLib
\end_layout

\begin_layout Standard
Utility class that provides static methods to perform full stream compression
 and decompression using the zlib algorithm.
\end_layout

\begin_layout FieldList
\labelwidthstring 0
deflate(int
\begin_inset space ~
\end_inset

compressionLevel,
\begin_inset space ~
\end_inset

Stream
\begin_inset space ~
\end_inset

in,
\begin_inset space ~
\end_inset

Stream
\begin_inset space ~
\end_inset

out) Deflates the given stream in with the specified compression level,
 writing the result to the given stream out.
\end_layout

\begin_deeper
\begin_layout Standard
The compressionLevel value must be between -1 and 9, where:
\end_layout

\begin_layout Itemize
-1: Default compression level.
\end_layout

\begin_layout Itemize
0: Storage only, no compression.
\end_layout

\begin_layout Itemize
1 – 9: Defines nine levels of compression, being 1 the less efficient (also
 the fastest) and 9 the most efficient (also the slowest).
 
\end_layout

\begin_layout Standard
You may also use one of the constants below:
\end_layout

\begin_layout FieldList
\labelwidthstring 0
NO_COMPRESSION Constant for compression level 0.
\end_layout

\begin_layout FieldList
\labelwidthstring 0
BEST_SPEED Constant for compression level 1.
\end_layout

\begin_layout FieldList
\labelwidthstring 0
BEST_COMPRESSION Constant for compression level 9.
\end_layout

\begin_layout FieldList
\labelwidthstring 0
DEFAULT_COMPRESSION Constant for the platform's default compression level
 (usually 5 or 6), same as -1.
\end_layout

\end_deeper
\begin_layout FieldList
\labelwidthstring 0
inflate(Stream
\begin_inset space ~
\end_inset

in,
\begin_inset space ~
\end_inset

Stream
\begin_inset space ~
\end_inset

out,
\begin_inset space ~
\end_inset

int
\begin_inset space ~
\end_inset

sizeIn) Attempts to read the number of bytes specified by sizeIn from the
 the given stream in, inflating and writing to the given stream out.
 If sizeIn is -1, it will attempt to fully read the stream.
\end_layout

\begin_layout FieldList
\labelwidthstring 0
inflate(Stream
\begin_inset space ~
\end_inset

in,
\begin_inset space ~
\end_inset

Stream
\begin_inset space ~
\end_inset

out) Attempts to fully read the given stream in, inflating and writing to
 the given stream out.
 It's equivalent to the calling the above method passing the value -1 for
 sizeIn.
\end_layout

\begin_layout Chapter
GZip
\end_layout

\begin_layout Standard
Utility class that provides static methods to perform full stream compression
 and decompression using the gzip algorithm.
\end_layout

\begin_layout FieldList
\labelwidthstring 0
deflate(Stream
\begin_inset space ~
\end_inset

in,
\begin_inset space ~
\end_inset

Stream
\begin_inset space ~
\end_inset

out) Deflates the given stream in writing the result to the given stream
 out.
\end_layout

\begin_layout FieldList
\labelwidthstring 0
inflate(Stream
\begin_inset space ~
\end_inset

in,
\begin_inset space ~
\end_inset

Stream
\begin_inset space ~
\end_inset

out,
\begin_inset space ~
\end_inset

int
\begin_inset space ~
\end_inset

sizeIn) Attempts to read the number of bytes specified by sizeIn from the
 the given stream in, inflating and writing to the given stream out.
 If sizeIn is -1, it will attempt to fully read the stream.
\end_layout

\begin_layout FieldList
\labelwidthstring 0
inflate(Stream
\begin_inset space ~
\end_inset

in,
\begin_inset space ~
\end_inset

Stream
\begin_inset space ~
\end_inset

out) Attempts to fully read the given stream in, inflating and writing to
 the given stream out.
 It's equivalent to the calling the above method passing the value -1 for
 sizeIn.
\end_layout

\begin_layout Standard
The classes ZLib and GZip interface is almost identical, the only difference
 is that you may specify the desired compression level when deflating with
 ZLib.
\end_layout

\begin_layout Part
DESKTOP SYNCHRONIZATION
\end_layout

\begin_layout Chapterstar
Overview
\end_layout

\begin_layout Standard
TotalCross provides a Synchronization API to develop conduits, which are
 TotalCross desktop applications that automatically synchronize files from
 your device to your computer and vice-versa.
\end_layout

\begin_layout Standard
Since the conduit is actually a TotalCross application, you won't have to
 write a conduit for each device you want to support.
 However, there are a few limitations:
\end_layout

\begin_layout Itemize
Conduits can only be used in Windows 2000 and above, because currently this
 is the only desktop OS supported.
\end_layout

\begin_layout Itemize
Currently the synchronization API only supports WinCE and PalmOS devices.
\end_layout

\begin_layout Itemize
Its functionality is based on the desktop synchronization software provided
 for your target device, so you're required to have it installed on your
 desktop.
 The right synchronization software depends on the desktop OS and the target
 device OS, as listed below:
\end_layout

\begin_deeper
\begin_layout Itemize
WinCE device and Windows Vista – requires Windows Mobile Device Center version
 6.0 and above.
\begin_inset Newline newline
\end_inset


\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100line%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
Remember: The Windows Mobile Device Center is fully compatible only with
 Windows Mobile 2003 devices and later.
 (Refer to chapter 2 for more details)
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
WinCE device and Windows 2000+ (except for Windows Vista) – requires Microsoft
 ActiveSync.
 The version 4.5.0 works with most devices, but some devices may require another
 specific version.
\end_layout

\begin_layout Itemize
PalmOS device and Windows – requires the Palm Desktop with the HotSync Manager
 6.0.1.
 The conduit may work with other versions of the HotSync Manager, but the
 version 6.0.1 is recommended.
\end_layout

\end_deeper
\begin_layout Standard
A conduit is usually triggered by the desktop synchronization software under
 a specific circumstance.
 Its behavior is slightly different depending on the target device:
\end_layout

\begin_layout Itemize
WinCE – The conduit is executed whenever a device is connected to the desktop
 and recognized by the Microsoft ActiveSync or the Windows Mobile Device
 Center.
 No extra interaction is required.
\end_layout

\begin_layout Itemize
PalmOS – The conduit is executed during the HotSync operation, which must
 be started by the user.
\end_layout

\begin_layout Chapter
Conduit usage
\end_layout

\begin_layout Standard
A conduit is usually not executed directly by the user, instead, it is registere
d to be executed when a specific event occurs.
\end_layout

\begin_layout Standard
The Conduit class already implements methods to register, unregister or
 configure a conduit, that are executed by invoking the conduit executable
 from the command line passing the desired parameter:
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00
/rp Registers this conduit for PalmOS devices.
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00
/up Unregisters this conduit for PalmOS devices.
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00
/rw Registers this conduit for WinCE devices.
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00
/uw Unregisters this conduit for WinCE devices.
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00
/c Shows the configuration panel (if available) for this conduit.
\end_layout

\begin_layout Standard
For example, to register the PainterConduit sample to retrieve the image
 created with the Painter sample for a PalmOS device:
\end_layout

\begin_layout Standard

\family typewriter
PainterConduit.exe /rp
\end_layout

\begin_layout Standard
To unregister:
\end_layout

\begin_layout Standard

\family typewriter
PainterConduit.exe /up
\end_layout

\begin_layout Chapter
Conduit implementation
\end_layout

\begin_layout Standard
Placeholder for this section.
\end_layout

\begin_layout Part
NET
\end_layout

\begin_layout Chapter
Socket
\end_layout

\begin_layout Standard
The Socket class allows you to open TCP/IP connections from your device.
 To be able to establish a connection with a particular server, both the
 server and the device must be connected to a common network (e.g.
 a local network that connects your computers and devices, or the Internet).
\end_layout

\begin_layout Standard
A Socket object denotes a client-server connection over a network using
 the TCP/IP protocol, where the device acts as a client, which connects
 to a specific server port.
\end_layout

\begin_layout Standard
The Socket class does not provide many methods besides the ones inherited
 from Stream.
 After creating a socket, you'll usually just perform read and write operations,
 closing the socket after you're done.
\end_layout

\begin_layout Standard
However, streams that handle remote connections are more likely to fail
 due to hardware and communication problems, so we shouldn't handle socket
 operations the same way we do with file operations.
\end_layout

\begin_layout Standard
In TotalCross, socket's read and write operations are blocking with a timeout
 – that means that socket methods will block the thread until the operation
 is completed, or the timeout for the operation is reached.
 If the operation is completed, the method returns immediately, regardless
 of the amount of time left.
 Otherwise, the method will just return the amount of data processed.
\end_layout

\begin_layout Standard
It's important to notice that no exception is thrown if the method times
 out.
 This is just a way to prevent your thread from being blocked indefinitely
 because of communication problems.
 You may just keep executing the same method until it finishes processing
 all the data.
\end_layout

\begin_layout Standard
Socket constructors:
\end_layout

\begin_layout FieldList
\labelwidthstring 0
Socket(String
\begin_inset space ~
\end_inset

host,
\begin_inset space ~
\end_inset

int
\begin_inset space ~
\end_inset

port,
\begin_inset space ~
\end_inset

int
\begin_inset space ~
\end_inset

timeout,
\begin_inset space ~
\end_inset

boolean
\begin_inset space ~
\end_inset

noLinger) Creates a new socket, that attempts to establish a connection
 by looking up the given host and performing the 3 way TCP/IP handshake.
 The argument port specifies the server port to connect to, while timeout
 specifies the timeout for this operation in milliseconds.
 The argument noLinger indicates if a socket upon close should shutdown
 the connection immediately or check for any server response before closing.
\end_layout

\begin_layout FieldList
\labelwidthstring 0
Socket(String
\begin_inset space ~
\end_inset

host,
\begin_inset space ~
\end_inset

int
\begin_inset space ~
\end_inset

port,
\begin_inset space ~
\end_inset

int
\begin_inset space ~
\end_inset

timeout) Same as the above, but uses the default value false for the argument
 noLinger.
\end_layout

\begin_layout FieldList
\labelwidthstring 0
Socket(String
\begin_inset space ~
\end_inset

host,
\begin_inset space ~
\end_inset

int
\begin_inset space ~
\end_inset

port) Same as the above, but uses the default value 1500 (milliseconds)
 for the argument timeout.
\end_layout

\begin_layout FieldList
\labelwidthstring 0
Socket(String
\begin_inset space ~
\end_inset

host,
\begin_inset space ~
\end_inset

int
\begin_inset space ~
\end_inset

port,
\begin_inset space ~
\end_inset

int
\begin_inset space ~
\end_inset

timeout,
\begin_inset space ~
\end_inset

String
\begin_inset space ~
\end_inset

params) Opens a socket.
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100line%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
You cannot open a socket before the main event loop.
 In other words, you cannot open a socket in the app's constructor, but
 you can in the initUI method.
 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The socket general behavior, including the timeout for read and write operations
, are stored in the following public fields:
\end_layout

\begin_layout FieldList
\labelwidthstring 0
readTimeout The timeout value for read operations.
 Its default value is Socket.DEFAULT_READ_TIMEOUT.
\end_layout

\begin_layout FieldList
\labelwidthstring 0
writeTimeout The timeout value for write operations.
 Its default value is Socket.DEFAULT_WRITE_TIMEOUT.
\end_layout

\begin_layout FieldList
\labelwidthstring 0
refreshBeforeEachRead If set to true, the status of all connections will
 be checked and closed connections will be reopened before each read/write
 operation.
\begin_inset Newline newline
\end_inset


\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100line%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
This field is ONLY used in PalmOS devices.
 It is simply ignored on other platforms.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Usually you should not worry about the read and write timeouts.
 The default values will be fine in most cases.
 However, you may increase the timeout value if you experience problems
 with slow connections.
\end_layout

\begin_layout Standard
Reducing the timeout value is usually a bad idea.
 If your device has a high speed connection, the read and write methods
 should also be fast and return before the timeout is reached.
 However, reducing the timeout value won't give you any benefit, and may
 even decrease your program performance.
\end_layout

\begin_layout Standard
Methods for read and write operations:
\end_layout

\begin_layout FieldList
\labelwidthstring 0
readBytes(byte[]
\begin_inset space ~
\end_inset

buf) Attempts to read enough bytes from this socket to fill the given buffer.
\end_layout

\begin_layout FieldList
\labelwidthstring 0
readLine() Attempts to read a line of text from this socket.
 A line is a sequence of characters delimited by any character lower than
 blank.
 This method correctly handles newlines with 
\backslash
n or 
\backslash
r
\backslash
n.
\end_layout

\begin_layout FieldList
\labelwidthstring 0
writeBytes(byte[]
\begin_inset space ~
\end_inset

buf) Attempts to write the contents of the given buffer to this socket.
\end_layout

\begin_layout FieldList
\labelwidthstring 0
writeBytes(String
\begin_inset space ~
\end_inset

s) Attempts to write the given string to this socket.
\end_layout

\begin_layout Standard
Except for the method readLine, the methods above are just available for
 convenience and may be replaced by read/write calls inherited from Stream.
 This has a cost however - using these methods increases the number of method
 calls for each read/write operation by one (they actually just call the
 Stream methods).
 If your application makes heavy use of sockets, you may avoid using these
 methods to improve its performance.
\end_layout

\begin_layout Chapter
ServerSocket
\end_layout

\begin_layout Standard
This class implements server sockets.
 A server socket waits for requests to come in over the network.
 It may then accept the incoming TCP/IP connection and perform some operation
 based on that request, possibly returning a result to the requester.
\end_layout

\begin_layout Standard
ServerSocket constructors:
\end_layout

\begin_layout FieldList
\labelwidthstring 0
ServerSocket(int
\begin_inset space ~
\end_inset

port) Attempts to open a server socket at the specified port number.
 By default, the maximum number of simultaneous connections allowed is DEFAULT_B
ACKLOG and the default timeout for accept is DEFAULT_SOTIMEOUT, and the
 server is not bound to any specific local address.
 The port number must be between 0 and 65535.
\end_layout

\begin_layout FieldList
\labelwidthstring 0
ServerSocket(int
\begin_inset space ~
\end_inset

port,
\begin_inset space ~
\end_inset

int
\begin_inset space ~
\end_inset

timeout) Same as the above, but you may also specify the timeout value,
 in milliseconds, for the accept operation.
 This value must be a positive value, or 0 to wait forever.
\end_layout

\begin_layout FieldList
\labelwidthstring 0
ServerSocket(int
\begin_inset space ~
\end_inset

port,
\begin_inset space ~
\end_inset

int
\begin_inset space ~
\end_inset

timeout,
\begin_inset space ~
\end_inset

String
\begin_inset space ~
\end_inset

addr) Same as the above, but you may also specify a local address, which
 the server should bind to.
 If the argument addr has a null value, it is ignored and the server is
 not bind to any address.
\end_layout

\begin_layout FieldList
\labelwidthstring 0
ServerSocket(int
\begin_inset space ~
\end_inset

port,
\begin_inset space ~
\end_inset

int
\begin_inset space ~
\end_inset

timeout,
\begin_inset space ~
\end_inset

int
\begin_inset space ~
\end_inset

backlog,
\begin_inset space ~
\end_inset

String
\begin_inset space ~
\end_inset

addr) Same as the above, but you may also specify the maximum number of
 simultaneous connections allowed with the argument backlog, which must
 have a positive value.
\end_layout

\begin_layout Standard
You may retrieve the address and port values of this ServerSocket with getHost()
 and getLocalPort().
\end_layout

\begin_layout Standard
After creating a ServerSocket, you may use the method accept() to wait for
 incoming connections.
 This method blocks the thread for the amount of time specified by the timeout
 value passed to the constructor, returning a null value when the timeout
 is over, or until a connection request is received and accepted, returning
 a Socket instance representing the new connection.
\end_layout

\begin_layout Standard
The returned object is always a valid Socket instance, that may be used
 to transfer data between this server and the client that requested the
 connection, and that should be closed when no longer needed.
\end_layout

\begin_layout Standard
You should never use blocking operations on threads handling events and/or
 the graphical interface, otherwise the user won't be able to interact with
 the application.
 Take a look at the source code of the sample ServerSocketTest.
\end_layout

\begin_layout Standard
Finally, you may use the method close() to close this server socket, releasing
 any associated resources.
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100line%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
Remember to close any sockets associated to this server socket before closing
 it.
 Otherwise all open sockets will throw an IOException.
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
SOAP Webservices
\end_layout

\begin_layout Quote
“SOAP Version 1.2 (SOAP) is a lightweight protocol intended for exchanging
 structured information in a decentralized, distributed environment.
 It uses XML technologies to define an extensible messaging framework providing
 a message construct that can be exchanged over a variety of underlying
 protocols.
 The framework has been designed to be independent of any particular programming
 model and other implementation specific semantics.” - Definition from SOAP
 Version 1.2 Part 1: Messaging Framework (Second Edition) - 
\begin_inset CommandInset href
LatexCommand href
name "W3C Recommendation 27 April 2007"
target "http://www.w3.org/TR/2007/REC-soap12-part1-20070427/#intro"

\end_inset


\end_layout

\begin_layout Standard
Because of its implementation independence, the SOAP protocol is widely
 used on the implementation of Web Services.
\end_layout

\begin_layout Section
The SOAP class
\end_layout

\begin_layout Standard
This class represents a SOAP message that, when executed, is sent to the
 server in a HTTP request .
 The server response is then received, processed and the answer made available.
\end_layout

\begin_layout Standard
Before creating a instance of SOAP, you may set the following class fields:
\end_layout

\begin_layout FieldList
\labelwidthstring 0
prefix The prefix string used to start the request.
 Its default value is:
\end_layout

\begin_deeper
\begin_layout Standard

\family typewriter
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\family typewriter
<?xml version="1.0" encoding="UTF-8"?>
\end_layout

\begin_layout Plain Layout

\family typewriter
<soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/"
 xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLS
chema-instance">
\end_layout

\begin_layout Plain Layout

\family typewriter
<soapenv:Body>
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout FieldList
\labelwidthstring 0
suffix The suffix string used to finish the request.
 Its default value is:
\end_layout

\begin_deeper
\begin_layout Standard

\family typewriter
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\family typewriter
</soapenv:Body>
\end_layout

\begin_layout Plain Layout

\family typewriter
</soapenv:Envelope>
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout FieldList
\labelwidthstring 0
debug Changing this value to true enables debug mode, which writes XML parsing
 information on the DebugConsole (or the default error output when running
 on JDK).
\end_layout

\begin_layout Standard
To create a new SOAP instance, you must use the following constructor:
\end_layout

\begin_layout FieldList
\labelwidthstring 0
SOAP(String mtd, String uri) – Creates a new SOAP request where mtd specifies
 the remote method to be executed, and uri the address of the Web Service.
\end_layout

\begin_layout Standard
After creating a new SOAP object, you may set some of its following instance
 fields:
\end_layout

\begin_layout FieldList
\labelwidthstring 0
alternativeReturnTag By default, the XML parser used by SOAP will recognize
 as an answer tag, any tags whose name ends with “result” or “return” (ignoring
 the case).
 This field, if set, specifies an alternative answer tag name, recognizing
 any XML element that ends with the specified value as an answer tag.
\begin_inset Newline newline
\end_inset


\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100line%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
The alternativeReturnTag IS CASE SENSITIVE, unlike the SOAP default tag
 names.
 Also, the alternativeReturnTag does not replace the default values.
 It's just a new value with higher priority over the default ones.
\end_layout

\end_inset


\end_layout

\begin_layout FieldList
\labelwidthstring 0
namespace String that identifies the service's namespace.
 Its default value is: http://schemas.xmlsoap.org/soap/
\end_layout

\begin_layout FieldList
\labelwidthstring 0
openTimeout Specifies the connection open timeout value in milliseconds.
 Its default value is defined by the constant DEFAULT_OPEN_TIMEOUT.
\end_layout

\begin_layout FieldList
\labelwidthstring 0
readTimeout Specifies the connection read timeout value in milliseconds.
 Its default value is defined by the constant DEFAULT_READ_TIMEOUT.
\end_layout

\begin_layout FieldList
\labelwidthstring 0
mtd Stores the name of the remote method.
\end_layout

\begin_layout FieldList
\labelwidthstring 0
uri Stores the address to the Web Service.
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100line%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
You may change both the mtd and the uri values before executing the request.
 Although this seems to be pointless, because these values are passed to
 the constructor.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
If the remote method expects any arguments, you must set them using the
 setParam method.
 However, there are several versions of this method to cover different argument
 types.
 Listing all of them would be pointless, so we'll define a generic type
 that we'll refer as <type>, and may be one of the of the following:
\end_layout

\begin_layout Itemize
int
\end_layout

\begin_layout Itemize
boolean
\end_layout

\begin_layout Itemize
double
\end_layout

\begin_layout Itemize
String
\end_layout

\begin_layout Standard
So, whenever a SOAP method is described like “setParam(<type> param)”, you
 can safely assume there are four versions of this method, one for each
 type listed above.
\end_layout

\begin_layout Standard
SOAP methods for parameters setting:
\end_layout

\begin_layout FieldList
\labelwidthstring 0
setParam(<type>
\begin_inset space ~
\end_inset

param) Sets the given value in the method's argument order.
\end_layout

\begin_layout FieldList
\labelwidthstring 0
setParam(<type>[]
\begin_inset space ~
\end_inset

param) Sets the given array in the method's argument order.
\end_layout

\begin_layout FieldList
\labelwidthstring 0
setParam(<type>
\begin_inset space ~
\end_inset

param,
\begin_inset space ~
\end_inset

String
\begin_inset space ~
\end_inset

paramName) Sets the given value in the method's argument order, identifying
 it with the given name.
\end_layout

\begin_layout FieldList
\labelwidthstring 0
setParam(<type>[]
\begin_inset space ~
\end_inset

param,
\begin_inset space ~
\end_inset

String
\begin_inset space ~
\end_inset

paramName) Sets the given array in the method's argument order, identifying
 it with the given name.
\end_layout

\begin_layout FieldList
\labelwidthstring 0
setParam(byte[]
\begin_inset space ~
\end_inset

param,
\begin_inset space ~
\end_inset

String
\begin_inset space ~
\end_inset

paramName) Sets a byte array in the method's argument order, identifying
 it with the given name.
\end_layout

\begin_layout FieldList
\labelwidthstring 0
setParam(String
\begin_inset space ~
\end_inset

param,
\begin_inset space ~
\end_inset

String
\begin_inset space ~
\end_inset

paramName,
\begin_inset space ~
\end_inset

String
\begin_inset space ~
\end_inset

paramType) Sets a String in the method's argument order, identifying it
 with the given name and specifying its type as the given one.
\end_layout

\begin_layout FieldList
\labelwidthstring 0
setParam(String[]
\begin_inset space ~
\end_inset

param,
\begin_inset space ~
\end_inset

String
\begin_inset space ~
\end_inset

paramName,
\begin_inset space ~
\end_inset

String
\begin_inset space ~
\end_inset

paramType) Sets a String array in the method's argument order, identifying
 it with the given name and specifying its type as the given one.
\end_layout

\begin_layout FieldList
\labelwidthstring 0
setObjectParam(String
\begin_inset space ~
\end_inset

paramName,
\begin_inset space ~
\end_inset

String[]
\begin_inset space ~
\end_inset

fieldNames,
\begin_inset space ~
\end_inset

String[]
\begin_inset space ~
\end_inset

fieldValues) Sets an Object param in the method's argument order, by specifying
 its name, field names and field values.
\end_layout

\begin_layout Standard
The only thing left to do now is to execute the request and check the service's
 answer:
\end_layout

\begin_layout FieldList
\labelwidthstring 0
execute() This method simply executes the prepared SOAP request.
\end_layout

\begin_layout FieldList
\labelwidthstring 0
getAnswer() To retrieve the method's answer, you must call this method after
 the execute.
 The return type of this method is Object, but it may return only three
 different values:
\end_layout

\begin_deeper
\begin_layout FieldList
\labelwidthstring 0
null When the remote method has no return value or the execute failed for
 any reason.
\end_layout

\begin_layout FieldList
\labelwidthstring 0
String When the remote method returns a single value.
 If the expected value is not String, you must convert the received String
 to the right.
 (e.g.
 if you're expecting an int value, you can use Convert.toInt).
\end_layout

\begin_layout FieldList
\labelwidthstring 0
String[] When the remote method returns an array or an Object.
 If the expected value is not a String array, you must convert each value
 of the array to the right type.
 If it's an object, the array contains its field values.
\end_layout

\begin_layout Standard
The remote method return type is known, so you may just typecast the object
 returned by getAnswer to String or String array, converting its values
 if necessary.
\end_layout

\end_deeper
\begin_layout Chapter
HTTPS / LiteSSL
\end_layout

\begin_layout Section
Overview
\end_layout

\begin_layout Standard
The TotalCross LiteSSL native library is a wrapper library of the great
 axTLS package.
 The axTLS embedded SSL project written by Cameron Rich is a highly configurable
 client/server TLSv1 library designed for platforms with small memory requiremen
ts (see 
\begin_inset CommandInset href
LatexCommand href
target "http://axtls.cerocclub.com.au/index.htm"

\end_inset

 for more details).
\end_layout

\begin_layout Standard
The original package supports Linux, Win32, Solaris & Cygwin.
 The SuperWaba team added support for PalmOS5 and Symbian through an integration
 with the existing TotalCross VM network capabilities.
\end_layout

\begin_layout Standard
This native library adds support for SSL (Secured Sockets Layer) communications
 to secure data transfers between authenticated devices and/or servers.
\end_layout

\begin_layout Section
Security background
\end_layout

\begin_layout Standard
For general information about the features of TLS (Transport Layer Security)
 and its usage, you may read the Wiki page available at http://en.wikipedia.org/wi
ki/Transport_Layer_Security.
 If you are lucky, you may even read a good translation in your personal
 language.
\end_layout

\begin_layout Standard
The english version provides a basic protocol description for everyone.
 For those who want to go further, the reference is the TLS protocol version
 1.0 RFC 2246 available at http://tools.ietf.org/html/rfc2246.
\end_layout

\begin_layout Standard
Basically, TLS allows secured and authenticated communication between two
 components generally so-called client & server.
 It relies on X509 certificates, their associated private keys to encrypt
 and associated public keys to uncrypt exchanged data.
 The certificates could be self signed or signed by an Authority known as
 CA (Certification Authority) that have to be trusted.
\end_layout

\begin_layout Standard
Insofar the subject of SSL based security is well documented on the web,
 we won't go further in the TLS description and invite people interrested
 in diving more deeply in secured communications to read the plenty of articles,
 books and HOWTOs available on the Internet.
\end_layout

\begin_layout Section
Generating security material
\end_layout

\begin_layout Standard
We will concentrate on the more general deployment of X509 client or server
 certificates (http://en.wikipedia.org/wiki/X.509) signed by a Certification
 Authority (CA).
 First we will have to create our own CA, that could be replaced by any
 "well known" commercial CA such as Verisign, Thawte, etc.
 if you have the need for a public authority.
\end_layout

\begin_layout Standard
We will use openssl (
\begin_inset CommandInset href
LatexCommand href
target "www.openssl.org"

\end_inset

) as security engine to generate the security material involved in certificate
 based authentication/encryption.
 It's a well spread SSL implementation providing powerfull tools to create
 and manage all kinds of security materials available on many platforms.
\end_layout

\begin_layout Section
Create a private CA
\end_layout

\begin_layout Standard
Generate a self signed certificate that will be used as Certification Authority
 (CA).
 The authority will be valid for 10 years (approx 3650 days).
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\family typewriter
bash$ openssl req -new -x509 -days 3650 -keyout cakey.pem -out cacert.pem
\end_layout

\begin_layout Plain Layout

\family typewriter
Generating a 1024 bit RSA private key
\end_layout

\begin_layout Plain Layout

\family typewriter
.++++++
\end_layout

\begin_layout Plain Layout

\family typewriter
.....++++++
\end_layout

\begin_layout Plain Layout

\family typewriter
writing new private key to 'cakey.pem'
\end_layout

\begin_layout Plain Layout

\family typewriter
Enter PEM pass phrase: xxxxx
\end_layout

\begin_layout Plain Layout

\family typewriter
Verifying - Enter PEM pass phrase: xxxxx
\end_layout

\begin_layout Plain Layout

\family typewriter
-----
\end_layout

\begin_layout Plain Layout

\family typewriter
You are about to be asked to enter information that will be incorporated
\end_layout

\begin_layout Plain Layout

\family typewriter
into your certificate request.
\end_layout

\begin_layout Plain Layout

\family typewriter
What you are about to enter is what is called a Distinguished Name or a
 DN.
\end_layout

\begin_layout Plain Layout

\family typewriter
There are quite a few fields but you can leave some blank
\end_layout

\begin_layout Plain Layout

\family typewriter
For some fields there will be a default value,
\end_layout

\begin_layout Plain Layout

\family typewriter
If you enter '.', the field will be left blank.
\end_layout

\begin_layout Plain Layout

\family typewriter
-----
\end_layout

\begin_layout Plain Layout

\family typewriter
Country Name (2 letter code) [AU]:BR
\end_layout

\begin_layout Plain Layout

\family typewriter
State or Province Name (full name) [Some-State]:Rio de Janeiro state
\end_layout

\begin_layout Plain Layout

\family typewriter
Locality Name (eg, city) []:Rio de Janeiro
\end_layout

\begin_layout Plain Layout

\family typewriter
Organization Name (eg, company) [Internet Widgits Pty Ltd]:SuperWaba Ltda
\end_layout

\begin_layout Plain Layout

\family typewriter
Organizational Unit Name (eg, section) []:SuperWaba dev.
 department
\end_layout

\begin_layout Plain Layout

\family typewriter
Common Name (eg, YOUR name) []:SuperWaba Sample CA
\end_layout

\begin_layout Plain Layout

\family typewriter
Email Address []:guich@superwaba.com.br
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The first entry is the private key password.
 The private key is used to sign other certificates to assert they are authentic.
 The private key is protected by a password as a further security because
 the CA private key is a main secret that have to be protected.
\end_layout

\begin_layout Standard
Next you will have to fill in X500 attributes describing the certificate
 subject.
 In our case, we enter information describing the SuperWaba CA (Certification
 Authority).
 Any agent trusting this CA, will authenticate certificates that have been
 signed by it through the CA embedded public key.
\end_layout

\begin_layout Standard
We now have two files, "cakey.pem" containing an encrypted version of the
 CA private key protected by a password and "cacert.pem" containing an X509
 certificate embedding the CA public key that could be redistributed.
\end_layout

\begin_layout Standard
Finally, you have to create a text file named "ca.srl" with the content "00"
 for certicate signing counting, just execute the following command :
\end_layout

\begin_layout Standard

\family typewriter
bash$ echo “00” > ca.srl
\end_layout

\begin_layout Section
Create a client or server X509 certificate
\end_layout

\begin_layout Standard
First, you have to generate a new private key.
 LiteSSL supports unencrypted and aes128/256 encrypted private keys.
\end_layout

\begin_layout Standard

\family typewriter
bash$ openssl genrsa -aes128 -out mykey.pem 512
\end_layout

\begin_layout Standard
You may replace “-aes128” by “-aes256” for a stronger cipher, or remove
 “-aes128” at all to generate a private key that is not encrypted.
 When you ask for an encrypted key, you have to enter a password used in
 the ciphering.
 The last option represent the key size in bits, values between 512 and
 4096 bits for a higher security are accepted, but always keep in mind that
 higher security implies longer processing times especially critical on
 embedded devices.
\end_layout

\begin_layout Standard
Next, you have to generate a certificate request.
 This file could be transmitted to one of the commercial CA companies for
 signing or could be signed by our previously created private CA.
\end_layout

\begin_layout Standard

\family typewriter
bash$ openssl req -new -out my.req -key mykey.pem
\end_layout

\begin_layout Standard
add "-x509" if you want to generate a self signed certificate if you don't
 want to use a CA at all (in this case, you may name the file "mycert.pem"
 rather than "my.req" insofar, the out file will contain a finalized self-signed
 certificate rather than a certificate request.
\end_layout

\begin_layout Standard
Enter all information describing your client or your server component.
 The certificate request will be stored in the file "my.req".
\end_layout

\begin_layout Standard
Finally, we will sign the certificate with the CA.
\end_layout

\begin_layout Standard

\family typewriter
bash$ openssl x509 -CA cacert.pem -CAkey cakey.pem -CAserial ca.srl -req -in
 my.req -out mycert.pem -days 1460
\end_layout

\begin_layout Standard
The "cacert.pem" is the CA certificate, "cakey.pem" its above created PEM
 encrypted private key, "my.req" is the certificate request file generated
 previously and "mycert.pem" is the resulting signed certificate that can
 be used for authentication and encryption during 1460 days (4 years).
\end_layout

\begin_layout Section
Principle of an X509 authentication/encryption
\end_layout

\begin_layout Standard
X509 authentication/encryption is based on public/private key encryption
 that have a great characteristic.
 Indeed, the data ciphered by either key could only be deciphered by the
 other one.
\end_layout

\begin_layout Standard
A software component that have to be authenticated, such as a secured server
 may now be configured to deliver to any client the previously generated
 certificate (contained in “mycert.pem"), it have to load also the associated
 certificate private key.
 That private key is used to cipher data transmited to the client.
 On the other side, the client uses the public key embedded in the accepted
 server certificate to decipher the data from the server and cipher the
 data sent back to the server that the server can decipher with its private
 key.
 If the client is configured to trust any certificate that have been signed
 by the signing CA, it will be able to authenticate any certificate using
 the CA public key.
\end_layout

\begin_layout Section
LiteSSL features
\end_layout

\begin_layout Standard
The LiteSSL package supports both PEM and DER encrypted materials.
 DER (http://en.wikipedia.org/wiki/Distinguished_Encoding_Rules) is an ASN.1
 encoding of information, PEM (http://en.wikipedia.org/wiki/Privacy_Enhanced_Mail)
 is a base64 encoding of a DER encoded data with a header "-----BEGIN "
 and a trailer "-----END " followed by a material type name.
 A PEM file may be unencrypted or encrypted with AES128 or AES256 ciphers
 only.
\end_layout

\begin_layout Standard
LiteSSL also supports the pkcs8 encoding that is a private key encryption
 format.
 But it supports only one ciphering algorithm that is PBE-SHA1-RC4-128.
 Here is the commandline to convert a PEM encoded private key into a pkcs8
 encoded format.
 Always use the “.p8” file suffix to identify the pkcs8 format.
\end_layout

\begin_layout Standard

\family typewriter
bash$ openssl pkcs8 -topk8 -in mykey.pem -inform PEM -out mykey.p8 -outform
 DER -v1 PBE-SHA1-RC4-128
\end_layout

\begin_layout Standard
You will have to enter a password, that will be required to use the private
 key.
\end_layout

\begin_layout Standard
LiteSSL also supports pkcs12 that is a certificate/private key encryption
 format.
 But it supports only one ciphering algorithm that is PBE-SHA1-RC4-128.
 Here is the commandline to convert certificate and its associate encoded
 private key into a pkcs12 encoded format.
 Always use the “.p12” file suffix to identify the pkcs12 format.
\end_layout

\begin_layout Standard

\family typewriter
bash$ openssl pkcs12 -export -in server.pem -out server.p12 -name "myserver"
 -inkey server.key -certpbe PBE-SHA1-RC4-128 -keypbe PBE-SHA1-RC4-128
\end_layout

\begin_layout Standard
You will have to enter a password, that will be required to use the private
 key embedded in the pkcs12 encoded file.
\end_layout

\begin_layout Section
Restrictions
\end_layout

\begin_layout Standard
The Applet version is implemented on top of SUN's JSSE.
 This TLS implementation has some limitations that prevent the use of some
 security material formats supported by LiteSSL on devices.
 Thus, private keys have to be in pkcs8 format only and moreover they can't
 be password protected.
 You have to add the “-nocrypt” option to the commandline provided above
 to convert a PEM encoded private key to pkcs8 encoding.
\end_layout

\begin_layout Section
LiteSSL usage
\end_layout

\begin_layout Standard
The SSLUtil class provides functions to get information about the TLS stack
 layer.
\end_layout

\begin_layout Standard
The first class to instantiate is “SSLClient” or “SSLServer” (not currently
 supported).
 This class represents an SSL client or server context both inheriting from
 the “SSLCTX” class that provides many SSL context common services.
 The main feature concerns the security material loading.
 Use the “objLoad” to load material from files or memory.
 The arguments of this function are the material type (CA, X509 certificate,
 private keys, etc.), the filename or the memory containing the material
 and finally a password for private keys loading if they are password based
 encrypted.
\end_layout

\begin_layout Standard
To succeed the handshake with a server, you have to trust its self-signed
 certificate or trust the CA certificate who signed the server's certificate.
 Use objLoad(SSL_OBJ_X509_CACERT, “cacert.pem”, null) to trust the server's
 signing CA.
 If the server requires client authentication, you will have to send your
 own client certificate.
 Use objLoad(SSL_OBJ_X509_CERT, “mycert.pem”, null) to load your client certifica
te and objLoad(SSL_OBJ_RSA_KEY, “mykey.pem”, “pass”) to load the client certifica
te associated private key protected by the “pass” password.
\end_layout

\begin_layout Standard
Next, you have to call “connect” on the context instance to create an SSL
 instance linked with a previously created socket.
 The SSL handshake start immediatly to try to establish an authenticated/ciphere
d communication.
\end_layout

\begin_layout Standard
The SSL handshake succeeded if it the “connect” call returns an SSL instance
 and the “handshakeStatus” function call on that instance returns “SSL_OK”.
 Consequently, you may check the subject of the peer certificate with the
 “getCertificateDN” call to identify it and the context could be used to
 write and read ciphered data until the “dispose” call terminates the SSL
 communication.
 The peer receives a protocol alert to signal a link shutdown.
\end_layout

\begin_layout Standard
The SSL write of data returns the amount of bytes written or an error if
 the writing failed.
 The SSL read of data may return SSL_OK that indicates that the read is
 not yet terminated and may be called again to achieve the reading of a
 block of decipherable data.
\end_layout

\begin_layout Part
BARCODE SCANNER
\end_layout

\begin_layout Standard
The Scanner class allows the usage of the barcode reader of some of the
 most popular scanners.
\end_layout

\begin_layout Standard
For WINCE, the following devices are supported:
\end_layout

\begin_layout Itemize
SocketScan
\end_layout

\begin_layout Itemize
Symbol
\end_layout

\begin_layout Itemize
Dolphin
\end_layout

\begin_layout Itemize
Intermec
\end_layout

\begin_layout Standard
To use the Scanner class at the device, you must also install the scanner
 library included within the TotalCrossSDK, by copying the desired dll to
 the TotalCross folder on the device.
\end_layout

\begin_layout Standard
For PALMOS, you may use the Janam devices along with its native WEDGE applicatio
n.
\end_layout

\begin_layout Standard
TotalCross also supports the Opticon H16 bluetooth scanner.
\end_layout

\begin_layout Part
OPTIMIZATION TRICKS
\end_layout

\begin_layout Chapterstar
Overview
\end_layout

\begin_layout Standard
The purpose of this small, but highly important chapter, is to teach you
 how to improve your Java application's speed.
\end_layout

\begin_layout Standard
The TotalCross VM has an interpreter, which makes it a little slow for certain
 types of applications.
 It is not feasible to program in the same way for 300MHz (a typical PDA)
 and 3000 MHz processors (a typical desktop).
 By following the tricks presented in this tutorial, you'll be able to improve
 your application's performance.
 
\end_layout

\begin_layout Standard
TotalCross uses the virtual machine of BlackBerry (there's no C development
 kit for it, so we can't build our virtual machine on BlackBerry; instead,
 we only ported the TotalCross classes to run on top of the RIM Java API).
 This is the reason why the BlackBerry timings are different.
 
\end_layout

\begin_layout Standard
These tips and tricks can make a very big difference in speed not only when
 running your program in PDAs, but also on desktop systems.
 Most of them can be used in any Java environment, and are actually referenced
 in other books and tutorials, but others are explicitly TotalCross optimization
 tricks.
\end_layout

\begin_layout Standard
There are some proof timings (measured in microseconds – µ = 1 second /
 1,000,000) near a clock bullet.
 They are always shown per iteration, ie, taken the total time and divided
 by the number or iterations.
 All tests were performed in the following devices:
\end_layout

\begin_layout Itemize
Palm OS: Palm Centro, 312MHz – named Palm
\end_layout

\begin_layout Itemize
Windows Mobile: Toshiba G900, 400MHz – named Win
\end_layout

\begin_layout Itemize
BlackBerry Curve 8330, 312MHz – named BB
\end_layout

\begin_layout Itemize
iPhone 1.1.4, 412MHz – named iPhone
\end_layout

\begin_layout Chapter
The Tricks
\end_layout

\begin_layout Enumerate
Avoid method calls.
 Method calls in TotalCross (and, actually, in any platform or virtual machine)
 are extremely expensive when comparing to in-lined code.
 This is the most important optimization trick, and several other tricks
 inherit from this one.
 Lets see some common mistakes that people make:
\end_layout

\begin_deeper
\begin_layout Enumerate
Don't use method calls as the stop condition in for loops (assume v is a
 Vector):
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

for (int i =0; i < v.size(); i++)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Palm: 2.0, Win: 1.00, BB: 3.00, iPhone: 5.47
\end_layout

\begin_layout Standard
You can change it in a couple of ways:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

int n = v.size();
\end_layout

\begin_layout Plain Layout

for (int i=0; i < n; i++)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Palm: 0.67, Win: 0.40, BB: 1.07, iPhone: 1.47
\end_layout

\begin_layout Standard
...
 if the order of the loop matters, or
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

for (int i=v.size()-1; i >= 0; i--)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Palm: 0.67, Win: 0.40, BB: 0.93, iPhone: 1.40
\end_layout

\begin_layout Standard
...
 if the order of the loop doesn't matters.
\end_layout

\begin_layout Standard
The same care can be taken with an array's .length property.
 It always takes extra time to get the field, so it's better to assign it
 to a temporary variable and use the temp variable in the loop, or use the
 previous suggestions.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

for (int i =0; i < items.length; i++)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Palm: 0.67, Win: 0.47, BB: 3.20, iPhone: 1.53
\end_layout

\end_deeper
\begin_layout Enumerate
Avoid using get and set methods.
 This may go against standard object oriented practices, but in small Java
 devices it is necessary that you avoid this.
 If you have a simple member that is protected or private, and is set and
 get by using something like: 
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

protected String s;
\end_layout

\begin_layout Plain Layout

public void setS(String newS) {s = newS;}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Palm: 1.66, Win: 0.87, BB: 1.06, iPh: 2.65
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public String getS() {return s;}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Palm: 1.62, Win: 0.86, BB: 1.05, iPhone: 2.76
\end_layout

\begin_layout Standard
It will be better to make the member public and access it directly:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public String s;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
direct set (s=...): Palm: 0.51, Win: 0.28, BB: 0.67, iPhone: 0.69
\end_layout

\begin_layout Standard
direct get (...=s): Palm: 0.54, Win: 0.31, BB: 0.62, iPhone: 0.82
\end_layout

\begin_layout Standard
Note about final classes: in the first JDK versions (up to 1.1.x), making
 the get/set methods final or making the whole class final would make the
 compiler inline the methods when using the -O compiler option.
 From JDK 1.2.x and beyond this no longer holds true.
 We plan, however, to make the TotalCross' deployer inline methods, thus
 re-allowing the programmer to use get/set methods.
\end_layout

\end_deeper
\begin_layout Enumerate
Any other methods that are used in a loop are good candidates to be inlined
 directly.
 But please have good sense when doing this.
 There's no need to inline all your program in one big block.
 Just make sure you optimize the very inner loop and that's it.
\end_layout

\end_deeper
\begin_layout Enumerate
Avoid using Interfaces.
 If you have an interface that is frequently used (maybe in a loop) in your
 application, change it to an abstract class, if possible.
 This is necessary because interface methods cannot be dynamically bound
 by the VM, thus each method call must be looked up in the methods table
 each time it is called.
 In normal and in abstract classes, the method is looked up only once and
 then its address is bound and used in all subsequent calls.
\end_layout

\begin_deeper
\begin_layout Labeling
\labelwidthstring 00.00.0000000
interfaces Palm: 4.11, Win: 2.16, BB: 1.66, iPhone: 8.83
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000000
abstract
\begin_inset space ~
\end_inset

classes Palm: 1.70, Win: 0.79, BB: 1.53, iPhone: 2.54
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000000
normal
\begin_inset space ~
\end_inset

classes Palm: 1.70, Win: 0.79, BB: 1.46, iPhone: 2.53
\end_layout

\end_deeper
\begin_layout Enumerate
Use arithmetic shifts instead of power of 2 multiplications.
 For example, x*2 can be changed to x<<1, x*4 = x<<2, etc.
 The same is valid for divisions: x/2 = x>>1, x/4 = x>>2, etc.
 But be careful: this only works for positive numbers.
\end_layout

\begin_deeper
\begin_layout Labeling
\labelwidthstring 00.00.0000
*/ Palm: 0.79, Win: 0.58, BB: 1.39, iPhone: 1.02
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
<<>> Palm: 0.63, Win: 0.37, BB: 0.86, iPhone: 0.93
\end_layout

\end_deeper
\begin_layout Enumerate
Use & instead of % (modulus) when possible.
 The situations where this is possible is when you have x%2, x%4, x%8, x%16,
 x%(2 n).
 You can replace it by x&1, x&3, x&7, x&15, x&(2 n -1).
\end_layout

\begin_deeper
\begin_layout Labeling
\labelwidthstring 00.00.0000
% Palm: 0.57, Win: 0.48, BB: 1.03, iPhone: 0.76
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
& Palm: 0.49, Win: 0.27, BB: 0.63, iPhone: 0.70
\end_layout

\end_deeper
\begin_layout Enumerate
Use aliases when dealing with an array that stores classes.
 Instead of
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

centerX = pos[i].x;
\end_layout

\begin_layout Plain Layout

centerY = pos[i].y;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Palm: 1.15, Win: 0.63, BB: 1.35, iPhone: 1.61
\end_layout

\begin_layout Standard
use:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Coord c = pos[i];
\end_layout

\begin_layout Plain Layout

centerX = c.x;
\end_layout

\begin_layout Plain Layout

centerY = c.y;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Palm: 1.03, Win: 0.57, BB: 1.18, iPhone: 1.48
\end_layout

\begin_layout Standard
Because each time you access an array position, the VM checks for null pointer
 exceptions, array index out of bounds exceptions, and does a multiply to
 access the memory address, all which expends time.
\end_layout

\end_deeper
\begin_layout Enumerate
Use an array (E.g.: String[], int[], etc) instead of Vector when you know
 in advance the size and it will not grow or shrink.
 Adding elements to Vector require the call of addElement hundreds of times,
 which affects performance.
\end_layout

\begin_layout Enumerate
If you need to do lots of String concatenations, use a StringBuffer instead
 of direct String additions (+).
 This saves time and, especially, memory! It can avoid out-of-memory errors
 in some situations, specially when parsing text and/or xml.
 When in loop, remember to reuse StringBuffer objects, using the StringBuffer.set
Length(0).
 But note that when using StringBuffer to concatenate only a few Strings,
 there's no performance gain at all.
 In other words, optimize your program to use StringBuffer only when doing
 things in loops.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

String s = "";
\end_layout

\begin_layout Plain Layout

for (int i=0; i < LOOP3; i++) 
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	s += i;
\end_layout

\begin_layout Plain Layout

	if (n-- == 0)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		n = 100;
\end_layout

\begin_layout Plain Layout

		s = "";
\end_layout

\begin_layout Plain Layout

	} 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Palm: 126.00, Win: 134.00, BB: 331.40, iPhone: 225.2
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

for (int i=0; i < LOOP3; i++)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	sb.append(i);
\end_layout

\begin_layout Plain Layout

	if (n-- == 0)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		n = 100;
\end_layout

\begin_layout Plain Layout

		sb.setLength(0);
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Palm: 6.00, Win: 2.40, BB: 70.00, iPhone: 7.00
\end_layout

\begin_layout Standard
From this test, you can see that BlackBerry's garbage collector has a very
 poor performance, and thus, on that platform, you should avoid the creation
 of many objects.
\end_layout

\end_deeper
\begin_layout Enumerate
When using ListBox and ComboBox, don't initialize them by calling add repeatedly.
 Instead, create a new array with the data and assign it directly to the
 ListBox/ComboBox using the constructor that receives an array of Objects.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

for (int i=0; i < 10000; i++)
\end_layout

\begin_layout Plain Layout

	lb.add(Convert.toString(i));
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Palm: 35.00, Win: 45.60, BB: 212.30, iPhone: 76.60
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

String []s = new String[10000];
\end_layout

\begin_layout Plain Layout

for (int i=0; i < 10000; i++)
\end_layout

\begin_layout Plain Layout

	s[i] = Convert.toString(i);
\end_layout

\begin_layout Plain Layout

lb.add(s);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Palm: 19.00, Win: 8.80, BB: 132.80, iPhone: 33.10
\end_layout

\end_deeper
\begin_layout Enumerate
Use int instead of long and double whenever possible.
 The long type has to be emulated on 32-bit processors.
 Currently, almost all PDA processors have a math co-processor and thus
 double is a quite fast operation, although still slower than int.
\end_layout

\begin_deeper
\begin_layout Labeling
\labelwidthstring 00.00.0000
long Palm: 2.04, Win: 3.88, BB: 2.72, iPhone: 1.99
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
double Palm: 1.72, Win: 0.99, BB: 3.58, iPhone: 1.34
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
int Palm: 0.72, Win: 0.63, BB: 1.52, iPhone: 0.90
\end_layout

\end_deeper
\begin_layout Enumerate
It is always better to use a switch/case instead of lots of ifs.
 Even if the code isn't called much, a switch/case makes the code cleaner
 (like the suggested approach for the onEvent method – see the User Interface
 Tutorial).
\end_layout

\begin_deeper
\begin_layout Labeling
\labelwidthstring 00.00.0000
if/else Palm: 0.84, Win: 0.48, BB: 1.19, iPhone: 1.23
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
switch Palm: 0.72, Win: 0.43, BB: 1.04, iPhone: 1.20
\end_layout

\end_deeper
\begin_layout Enumerate
When using (Int)Vector and (Int)Hashtable and you have an estimate of the
 final size, construct it with that estimated size and not with the default
 constructor, to avoid buffer reallocation.
 Each time you add an element and the vector is filled, it allocates a new
 buffer 20% larger than the current one and copies all the contents to it,
 thus spending time and memory.
\end_layout

\begin_deeper
\begin_layout Labeling
\labelwidthstring 00.00.00000000000
starting
\begin_inset space ~
\end_inset

from
\begin_inset space ~
\end_inset

10 Palm: 5.00, Win: 2.4, BB: 43.60, iPhone: 7.30
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.00000000000
starting
\begin_inset space ~
\end_inset

from
\begin_inset space ~
\end_inset

10000 Palm: 3.00, Win: 1.7, BB: 16.90, iPhone: 6.30
\end_layout

\end_deeper
\begin_layout Enumerate
When using String.indexOf, use the method that receives an int value instead
 of the one that receives a String value if the string being searched has
 a length of one char.
\end_layout

\begin_deeper
\begin_layout Labeling
\labelwidthstring 00.00.0000
int Palm: 3.42, Win: 1.64, BB: 18.05, iPhone: 4.98
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
string Palm: 3.94, Win: 1.90, BB: 56.74, iPhone: 6.08
\end_layout

\end_deeper
\begin_layout Enumerate
Use aliases when accessing objects that are accessible by methods.
 For example, instead of:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

db.getResizeRecord().restartRecord(index);
\end_layout

\begin_layout Plain Layout

...
\end_layout

\begin_layout Plain Layout

db.getResizeRecord().endRecord();
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Use:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

ResizeRecord rs = db.getResizeRecord();
\end_layout

\begin_layout Plain Layout

rs.restartRecord(index);
\end_layout

\begin_layout Plain Layout

...
\end_layout

\begin_layout Plain Layout

rs.endRecord();
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Use the arithmetic shortcuts like x+=y, x-=y, x*=y, x/=y, x&=y, etc, instead
 of x=x+y, x=x-y, x=x*y, etc.
\end_layout

\begin_deeper
\begin_layout Labeling
\labelwidthstring 00.00.0000
x
\begin_inset space ~
\end_inset

=
\begin_inset space ~
\end_inset

x+y Palm: 0.53, Win: 0.27, BB: 0.70, iPhone: 0.71
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
x
\begin_inset space ~
\end_inset

+=
\begin_inset space ~
\end_inset

y Palm: 0.37, Win: 0.22, BB: 0.45, iPhone: 0.57
\end_layout

\end_deeper
\begin_layout Enumerate
Use local variables whenever possible, instead of instance variables, specially
 when they are used in loops.
 For example:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public class Test
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	int loopVar;
\end_layout

\begin_layout Plain Layout

	public void testLoop()
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		for (loopVar = 0; loopVar < 1000; loopVar++)
\end_layout

\begin_layout Plain Layout

			...
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Instead, make loopVar a local variable inside the testLoop method, moving
 it to inside the method.
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.00000000
instance
\begin_inset space ~
\end_inset

variable Palm: 0.92, Win: 0.46, BB: 1.03, iPhone: 1.25
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.00000000
local
\begin_inset space ~
\end_inset

variable Palm: 0.40, Win: 0.22, BB: 0.49, iPhone: 0.57
\end_layout

\begin_layout Standard
Another trick is to create a local copy of a class variable in the method
 when it is used in a loop.
 For instance:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

StringBuffer sb = new StringBuffer(1024);
\end_layout

\begin_layout Plain Layout

public void processSomething()
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	StringBuffer sb = this.sb;
\end_layout

\begin_layout Plain Layout

	sb.setLength(0);
\end_layout

\begin_layout Plain Layout

	...
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
When iterating over a String, be careful to choose the correct approach
 for the target platform.
 Not always the best approach for one platform is also the best for the
 others.
 In this case, you have three choices: iterate using charAt, iterate over
 the char array provided by toCharArray, or iterate over the byte array
 provided by getBytes.
 The last two approaches increases the memory usage because it creates arrays
 (the char array takes twice the memory of a byte array).
\end_layout

\begin_deeper
\begin_layout Standard
Using toCharArray:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

String s = "a string";
\end_layout

\begin_layout Plain Layout

char []c = s.toCharArray(); 
\end_layout

\begin_layout Plain Layout

int n = c.length;
\end_layout

\begin_layout Plain Layout

for (int i =0; i < n; i++)
\end_layout

\begin_layout Plain Layout

	...
 c[i] ...
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Palm: 98.50, Win: 61.95, BB: 243.20, iPhone: 151.10
\end_layout

\begin_layout Standard
Using getBytes:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

byte []b = s.getBytes();
\end_layout

\begin_layout Plain Layout

int n = b.length;
\end_layout

\begin_layout Plain Layout

for (int j =0; j < n; j++)
\end_layout

\begin_layout Plain Layout

	if (b[j] == (byte)'g')
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Palm: 94.50, Win: 54.75, BB: 155.75, iPhone: 363.85
\end_layout

\begin_layout Standard
Now, using charAt:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

int n = s.length();
\end_layout

\begin_layout Plain Layout

for (int i =0; i < n; i++)
\end_layout

\begin_layout Plain Layout

	...
 s.charAt(i) ...
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Palm: 272.5, Win: 134.55, BB: 108.90, iPhone: 557.30
\end_layout

\begin_layout Standard
The getBytes convert chars to bytes using the totalcross.sys.CharacterConvertion
 class.
 It is faster in TotalCross because it detects the standard CharacterConvertion
 class is being used, and in this case, the native implementation of chars2bytes
 is used.
\end_layout

\begin_layout Standard
The iPhone has a virtual memory that swaps unused portions to disk; this
 may explain why this test ran so slowly when comparing to the other platforms.
\end_layout

\end_deeper
\begin_layout Enumerate
The use of short and byte data types are slower than using int and also
 saves no memory at all.
 This happens because boolean, short and byte are internally stored as int
 and they have to be converted to/from int when are operated on.
 They should only be used when creating arrays; in such situation, they
 do save memory.
\end_layout

\begin_deeper
\begin_layout Labeling
\labelwidthstring 00.00.0000
int Palm: 0.47, Win: 0.27, BB: 0.72, iPhone: 0.68
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
short Palm: 0.53, Win: 0.32, BB: 0.71, iPhone: 0.81
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
byte Palm: 0.56, Win: 0.32, BB: 0.73, iPhone: 0.81
\end_layout

\end_deeper
\begin_layout Standard
Remember that although the time of each operation is small, in your whole
 program every speed improvement gained using the approaches described above
 will count a lot.
\end_layout

\begin_layout Standard
As a side note, running the same tests on SuperWaba 5.85, TotalCross 1.0 beta
 4 was 32% faster on Palm OS, and 10% faster on Windows Mobile.
\end_layout

\begin_layout Part
APPENDIXES 
\end_layout

\begin_layout Chapter
\start_of_appendix
Copyright
\begin_inset CommandInset label
LatexCommand label
name "chap:Copyright"

\end_inset


\end_layout

\begin_layout Standard
All contents of this tutorial, including text, programs, applets, source
 code, and images are copyrighted and owned by SuperWaba Ltda, all rights
 reserved.
 No material can be reproduced and/or distributed electronically or in print
 without written permission.
\end_layout

\begin_layout Chapter
Platform specific known features/flaws
\end_layout

\begin_layout Section
Palm OS
\end_layout

\begin_layout Standard
Palm OS has a very limited number of threads available to the programmer.
 In our tests, we couldn't create more than 10 threads.
\end_layout

\begin_layout Standard
Sending events to user interfaces created in a thread can lead to crash.
\end_layout

\begin_layout Section
Windows CE
\end_layout

\begin_layout Section
BlackBerry
\end_layout

\begin_layout Itemize
try/catch block with Throwable
\end_layout

\begin_deeper
\begin_layout Quote
“The BlackBerry JVM is optimized to eliminate the stack trace if it locates
 code that catches the exception using catch (Exception e).
 It does not eliminate the stack trace if your application catches the Throwable
 exception.
\end_layout

\begin_layout Quote
For example, the following code does not print a stack trace:
\end_layout

\begin_layout Quote
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

catch (IOException e) {
\end_layout

\begin_layout Plain Layout

	e.printStackTrace()
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Quote
To print a stack trace, write code like in the following example:
\end_layout

\begin_layout Quote
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

catch (Throwable t) {
\end_layout

\begin_layout Plain Layout

	t.printStackTrace();
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Quote
When you debug your application, to view the stack trace, catch a Throwable
 instance” - Excerpted from “BlackBerry Java Development Environment - Fundament
als Guide”
\end_layout

\begin_layout Standard
In short, the above means the following:
\end_layout

\begin_layout Itemize
When you catch an exception as Throwable, you may print the stack trace
 using printStackTrace.
 Otherwise, it assumes your code handled the exception properly and discards
 the stack trace.
 In this case printStackTrace will print nothing.
\end_layout

\begin_layout Itemize
When you catch an exception as Throwable, you don't actually stop the exception
 propagation.
 It only lets you inspect the exception for debugging purposes.
 The exception is still propagated to the caller method!
\end_layout

\begin_layout Itemize
Catching as Exception (or a subclass of it) allows you to stop the propagation,
 but does not give you access to the stack trace.
\end_layout

\begin_layout Itemize
It is not possible to retrieve stack trace or redirect the prinStackTrace
 method to other stream.
 Therefore, it's not possible to log exceptions in BlackBerry!
\end_layout

\begin_layout Standard
So be careful when using try/catch blocks with Throwable, it does not the
 same way on BlackBerry.
\end_layout

\end_deeper
\begin_layout Itemize
Finalize method support
\end_layout

\begin_deeper
\begin_layout Standard
Since BlackBerry does not support finalize methods, TotalCross implements
 it in a manner that objects are finalized only after the program quits,
 instead of doing it after every garbage collector runs.
\end_layout

\end_deeper
\begin_layout Section
iPhone
\end_layout

\begin_layout Chapter
Tutorials for third-party tools
\end_layout

\begin_layout Section
Deploying with Ant
\end_layout

\begin_layout Standard
Apache Ant is a Java-based build tool, similar to Make, that may be executed
 from the shell or from an IDE, like Eclipse.
\end_layout

\begin_layout Standard
The TotalCrossSDK comes with a sample Ant build file.
 Just copy the build.xml file located in TotalCrossSDK/docs/companion_resources/a
nt_build to your application's directory, and change its properties as described
 below:
\end_layout

\begin_layout Standard
Property Name
\end_layout

\begin_layout Standard
Example Value
\end_layout

\begin_layout Standard
Description
\end_layout

\begin_layout Standard
project name
\end_layout

\begin_layout Standard
“ACME”
\end_layout

\begin_layout Standard
Project's name
\end_layout

\begin_layout Standard
sdk.root
\end_layout

\begin_layout Standard
“C:/TotalCrossSDK”
\end_layout

\begin_layout Standard
TotalCrossSDK installation path
\end_layout

\begin_layout Standard
app.name
\end_layout

\begin_layout Standard
1.
 “C:/ACME/main/Live.class”
\end_layout

\begin_layout Standard
2.
 “C:/ACME/Live.jar”
\end_layout

\begin_layout Standard
3.
 “C:/ACME/main”
\end_layout

\begin_layout Standard
One of the below:
\end_layout

\begin_layout Standard
1.
 The path and name of the class that extends MainWindow (must end with .class).
\end_layout

\begin_layout Standard
2.
 The path to the jar that contains all classes and resources.
\end_layout

\begin_layout Standard
3.
 The path to where the class that extends MainWindow is located.
\end_layout

\begin_layout Standard
platforms
\end_layout

\begin_layout Standard
“-palm -wince -win32”
\end_layout

\begin_layout Standard
Platforms to deploy.
\end_layout

\begin_layout Standard
extra.args
\end_layout

\begin_layout Standard
“/k /v”
\end_layout

\begin_layout Standard
Any extra arguments you want to pass to the deployer.
\end_layout

\begin_layout Standard
target.dir
\end_layout

\begin_layout Standard
“.” (single dot - current path)
\end_layout

\begin_layout Standard
The target directory where the files will be created.
\end_layout

\begin_layout Section
Configuring Eclipse to Run and Debug TotalCross Programs
\end_layout

\begin_layout Standard
This is a guide to help you to setup the Eclipse IDE (www.eclipse.org) to
 develop TotalCross programs.
\end_layout

\begin_layout Standard
Because this isn't a guide for Eclipse or Java, it assumes the following:
\end_layout

\begin_layout Itemize
Java JDK 6 is installed and configured.
\end_layout

\begin_layout Itemize
The Eclipse IDE with Java Development Tools installed.
 Please notice this guide was created using the Eclipse Ganymede (version
 3.4.x) package “Eclipse IDE for Java Developers”, and the steps presented
 here may not be valid for other versions.
\end_layout

\begin_layout Itemize
We'll refer to the TotalCross location as TotalCrossSDK.
\end_layout

\begin_layout Standard
We'll use the UIGadgets sample that comes with the SDK to skip the programming
 and focus on the project setup:
\end_layout

\begin_layout Enumerate
Create a new Java Project: Open the menu File and click on New > Java Project.
\end_layout

\begin_layout Enumerate
Choose a project name for your project and click on Finish.
 We'll use UIGadgets.
\end_layout

\begin_layout Enumerate
Click on “+” to expand the project and right-click on the folder “src” and
 choose “Import...”.
\end_layout

\begin_layout Enumerate
On the new “Import” dialog shown, click on “+” to expand the folder “General”,
 select “File System” and click “Next >”.
\end_layout

\begin_layout Enumerate
Now write the complete file path to the UIGadgets example, or use “Browse”
 to navigate to the file system.
 Our source is located at TotalCrossSDK/src/tc/samples/ui/gadgets.
\end_layout

\begin_layout Enumerate
After inputing the source location, check the file “UIGadgets.java” on the
 right panel; Below you can see the default input folder is “UIGadgets/src”,
 change it to “UIGadgets/src/tc/samples/ui/gadgets” and click on “Finish”.
\end_layout

\begin_layout Enumerate
Now we can see our project has tc.samples.ui.gadgets.UIGadgets.java on it, but
 it is also displaying several build errors.
 To fix this, right-click on the project and choose “Properties”.
\end_layout

\begin_layout Enumerate
On the left panel, select “Java Build Path”; Then, on the right panel, click
 on the “Libraries” tab and on the button “Add External JARs...”; Browse your
 file system to TotalCrossSDK/dist and select the file “tc.jar”.
\end_layout

\begin_layout Enumerate
Now the “Libraries” tab should also show the “tc.jar”.
 Click on “+” to expand it and select “Javadoc location”.
 Now click on the button “Edit...” to open a new dialog, then browse your file
 system and select the TotalCrossSDK/docs/html/ directory and press “Ok”
 to confirm.
\end_layout

\begin_layout Enumerate
Back to the “Libraries” tab, select “Source attachment” and click on the
 button “Edit...” to open a new dialog, then browse your file system and select
 the TotalCrossSDK/src directory and press “Ok” to confirm.
 This finishes the build path configuration.
\end_layout

\begin_layout Enumerate
Look again at the left panel and select “Java Compiler”.
 Check the option “Enable project specific settings” and change the “Compiler
 compliance level” to “1.3”.
\end_layout

\begin_layout Enumerate
Press “Ok” to confirm and close the “Properties” dialog.
\end_layout

\begin_layout Enumerate
Re-build the project and the build errors should all be gone.
 (Skip this step if your Eclipse is configured to Build automatically).
\end_layout

\begin_layout Chapter
Referenced images
\end_layout

\end_body
\end_document
